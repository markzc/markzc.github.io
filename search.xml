<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[SpringMVC第二阶段]]></title>
      <url>%2F2016%2F12%2F28%2FSpringMVC02%2F</url>
      <content type="text"><![CDATA[SpringMvc[TOC] 高级参数绑定批量删除(数组） 从请求中接受参数，多个id&lt;input type=&quot;checkbox&quot; name=&quot;ids&quot; value=&quot;${item.id}&quot;/&gt; 可以在QuertVo定义一个int[] ids;这样在页面的 &lt;input type=&quot;checkbox&quot;&gt;中的name是ids,然后再controller中接受参数用QueryVo即可 批量修改（List集合） QueryuVo中需要封装List&lt;Items&gt; itemList; 页面上input框的name属性 ： vo中的集合属性名称+[集合索引]+.泛型中对应的属性名称用来使controller中的方法，接收返回的List\。 &lt;input type=&quot;text&quot; value=&quot;${item.name }&quot; name=&quot;itemList[${status.index }].name&quot;&gt; @RequestMapping 写在方法上：标记url到请求方法的映射，其实就是通过浏览器中的url找到对应的controller方法 写在类上：窄化请求映射，其实就是为了防止你起的url跟你同事的起的url相同，请求错乱的情况在类上加了一层目录，访问的时候要在地址上加上这个参数 ，这样在访问的时候就需要在前面加一个item,localhost:8080/SpringMvc01/item/list.action 限制请求的类型：get post,参数中加注解 @RequestMapping（value=&quot;/list&quot;,method=RequestMethod.POST） 限制请求类型后必须是该类型的访问请求才能访问此方法，如果是其他访问类型报405 默认是get类型controller方法返回值 请求转发：浏览器中的url不发生改变，request域中的数据能带入转发后的方法中重定向：浏览器中的url发生改变，request域中的数据不能带入重定向后的方法中 String 返回一个普通的页面: 就认为是页面地址 请求转发 在SpringMvc中请求转发可以让controller方法返回值为String类型，那么返回的字符串以forword:开头的为请求转发,当然路劲也是url 路劲 12345//request.setAttribute(&quot;id&quot;, items.getId()); model.addAttribute(&quot;id&quot;, items.getId());//在springMvc中请求转发可以让controller方法返回值为String类型, 那么返回的字符串以forward:开头的为请求转发,//forward:字符串后面跟需要访问的url路径return &quot;forward:toEdit.action&quot;; 重定向 在SpringMvc中请求转发可以让controller方法返回值为String类型，那么返回的字符串以`redirect:’的为重定向 123model.addAttribute(&quot;id&quot;, items.getId());//在springMvc中重定向, 返回的值以redirect:字符串开头, 后面跟需要重定向的urlreturn &quot;redirect:toEdit.action&quot;; model model可以把数据带到重定向后的方法，因为model底层是request域而且对其做了扩展model.addAttribute(&quot;itemList&quot;, list); 不管是转发还是重定向都能把model中的值带到抵达的方法中 还有一种情况就是同时有model跟request向域中set值的时候，不管谁在前面，在转发的时候会把model里面的值在放入与里边一遍。所以在取出来的时候的值是model.addAttribute里边的值。 ModelAndView.addObject(&quot;itemList&quot;, list);如果想用这个类就必须返回值为ModelAndView类型的，同样也是存到了model中。 相对路径和绝对路径 springMvc中请求转发和重定向,后面的url路径以斜杠/开头为绝对路径, 不以斜杠/开头的为相对路径 相对路径: 相对路径是相对于当前路径 最多只限于当前类下的url路径进行跳转使用 绝对路径: 从项目名后开始算 一般在从一个controller方法中一条转到另一个controller方法中使用 但是所有路径都可以写成绝对路径, 是无敌的 void 当返回值为void的时候，只能借助原生的request,response 这样就不走SpringMvc的视图解析了，相当于破坏了SpringMvc的体系结构，所以不推荐使用 123456//转发public void update(Items items, HttpServletRequest request, HttpServletResponse response, Model model) throws Exception&#123; itemsService.updateItemsById(items); request.setAttribute(&quot;items&quot;, items); request.getRequestDispatcher(&quot;/WEB-INF/jsp/editItem.jsp&quot;).forward(request, response);&#125; 但是在ajax发送请求的时候，需要回掉函数返回数据的时候，可以使用这种原生的方法。 SpringMvc中的异常处理 异常分类： 运行时异常： 自定义异常： 自定义异常： 新建一个自定义异常的类继承Exception，里面有一个Message属性,实现get，set 12public class CustomException extends Exception&#123; private String message; 在自定义一个处理异常的类CustomGlobalExceptionReslover继承HandlerExceptionResolver,重写里面的方法 123456789101112131415public class CustomGlobalExceptionReslover implements HandlerExceptionResolver&#123; @Override public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object arg2, Exception exce) &#123; String msg=&quot;&quot;; if(exce instanceof CustomException)&#123; msg=exce.getMessage(); &#125;else&#123; msg=&quot;不好意思, 系统繁忙, 请联系管理员!&quot;; &#125; ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(&quot;msg&quot;,msg); modelAndView.setViewName(&quot;error&quot;); return modelAndView; &#125; 然后再SpringMvc的配置文件中配置一下,把自定义异常的处理类交给Spring即可&lt;bean class=&quot;com.zc.exception.CustomGlobalExceptionReslover&quot; /&gt; 测试 123456789//测试运行时异常//int i=1/0;//测试自定义异常if(true)&#123;CustomException exception = new CustomException(); exception.setMessage(&quot;测试自定义异常&quot;); throw exception;&#125; 图片上传 springMvc中对图片上传有接口的支持, 但是没有实现,所以需要第三方实现. 用的是FileUpload,先导包,然后配置文件配置一下 1234567&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;!-- 设置上传文件的最大尺寸为5MB --&gt; &lt;property name=&quot;maxUploadSize&quot;&gt; &lt;value&gt;5242880&lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; 然后在form标签上设置enctype=&quot;multipart/form-data&quot; 文件上传项&lt;input type=&quot;file&quot; name=&quot;pictureFile&quot;/&gt; 然后再controller中的参数中增加一个MultipartFile pictureFile用来接收文件上传项 123456789101112131415@RequestMapping(&quot;/update&quot;)public String update(MultipartFile pictureFile,Items items, Model model) throws Exception&#123; //1. 获取图片的完整名称 String fileName = pictureFile.getOriginalFilename(); //2. 生成随机字符串+源文件的扩展名组成新文件名, 防止图片重名 String newFileName = UUID.randomUUID().toString() + fileName.substring(fileName.lastIndexOf(&quot;.&quot;)); //3. 将图片保存到硬盘中 pictureFile.transferTo(new File(&quot;E:\\image\\&quot; + newFileName)); //4. 将图片名称保存到数据库中 items.setPic(newFileName); itemsService.updateItemsById(items); model.addAttribute(&quot;id&quot;, items.getId()); return &quot;redirect:toEdit.action&quot;;&#125; tomcat中有配置的图片服务器 双击tomcat，打开底下第二个视图 点击Add External Web Module... 上面就是服务器存放图片的地址，把图片放入这个路径下，通过下面那个自定义的地址就能访问到 例如：设置底下的路劲为pic则可以在服务器中访问，上面路劲下的图片http://localhost:8080/pic/aaa.jpg json数据交互 让SpringMvc自动将接受的json格式字符串转换成java对象，将pojo对象转换成json串返回给页面 SpingMvc中对json的支持有接口但是无实现，所以需要第三方的实现，杰克逊的jar包，在企业中SpringMvc.xml配置注解驱动，那么这样的SpringMvc就跟杰克逊的jar包完美集成不用任何配置 @RequestBody 作用: 将接收到的json格式字符串自动转换成pojo对象, 要求json的key必须等于pojo中对应的属性名称 @ResponseBody作用: 将返回的pojo对象自动转换成json格式字符串返回 如果想返回一个json的话，可以把想要转的实体返回，返回值也是他的类型只要加一个注解就行@ResponseBody 1234567891011121314151617$.ajax(&#123; type:&quot;post&quot;, url:&quot;$&#123;pageContext.request.contextPath &#125;/items/sendJson&quot;, contentType:&quot;application/json;charset=utf-8&quot;, data:&apos;&#123;&quot;name&quot;:&quot;测试商品&quot;,&quot;price&quot;:99.9&#125;&apos;, success:function(data)&#123; alert(data); &#125;&#125;);@RequestMapping(&quot;/sendJson&quot;)@ResponseBodypublic Items sendJson(@RequestBody Items items) throws Exception&#123; System.out.println(items); return items;&#125; RESTful支持 就是url的一个命名规范，要求url中只能是名词，没有动词，但是由于国内开发人员英文水平不太好，所以不严格要求, 但是要求url中没有问号传参 例如：http://blog.csdn.net/beat_the_world/article/details/45621673 添加DispatcherServlet的rest配置 当web.xml中配置url-partten为斜杠/的时候会拦截静态资源不放行 可以在SpringMvc.xml放行dispathcerServlet中被拦截的静态资源 location:配置页面引用时放行的路径 mapping:放心的静态资源的位置 例如：这样&lt;mvc:resources location=&quot;/js/&quot; mapping=&quot;/js/**&quot;/&gt;配置之后就能访问到引入的js了 URL 模板模式映射 路劲：${pageContext.request.contextPath }/toEdit/${item.id} @RequestMapping(value=&quot;/toEdit/{id}&quot;)：{×××}占位符，请求的URL可以是“/viewItems/1”或“/viewItems/2”，通过在方法中使用@PathVariable获取{×××}中的×××变量。 @PathVariable用于将请求URL中的模板变量映射到功能处理方法的参数上。 12345678@RequestMapping(&quot;/toEdit/&#123;id&#125;&quot;)public String toEdit(@PathVariable(&quot;id&quot;) String id,Model model) throws Exception&#123; //现在id就能用了 //调用 service查询商品信息 Items items = itemsService.findItemsById(id); model.addAttribute(&quot;item&quot;, items); return &quot;toEdit&quot;;&#125; 当然也可以有多个参数：${pageContext.request.contextPath }/toEdit/${item.id}/${item.name} 这样在接收的时候，后面跟两个占位符即可 12@RequestMapping(&quot;/toEdit/&#123;id&#125;/&#123;name&#125;&quot;)public String toEdit(@PathVariable(&quot;id&quot;) String id,@PathVariable(&quot;name&quot;) String name,Model model) throws Exception&#123; 拦截器 作用: 拦截请求 先创建一个拦截器的类interceptor实现HandlerInterceptor，重写里面的三那个方法 123456789101112131415161718192021222324252627public class Interceptor1 implements HandlerInterceptor &#123; //执行时机: controller方法已经执行, modelAndView已经返回 //使用场景: 可以记录日志信息 @Override public void afterCompletion(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3) throws Exception &#123; System.out.println(&quot;====Interceptor1=======afterCompletion===&quot;); &#125; //执行时机: controller方法已经执行, modelAndview还没有返回 //使用场景: 可以在这里进行全局的数据的加工处理, 比如全局都需要一个天气信息, 就可以在这里加入, 全局都能取到天气的数据 @Override public void postHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, ModelAndView arg3) throws Exception &#123; System.out.println(&quot;====Interceptor1=======postHandle===&quot;); &#125; //执行时机: controller方法没有执行, modelAndView还没有返回 //使用场景: 做权限校验的时候, 判断session中是否有用户的登录信息 //返回值是boolean类型, 返回true放行, 返回false拦截住不放行 @Override public boolean preHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2) throws Exception &#123; System.out.println(&quot;====Interceptor1=======preHandle===&quot;); return true; &#125;&#125; 然后再配置文件配置一下 123456789&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!-- 拦截所有路径 --&gt; &lt;mvc:mapping path="/**"/&gt; &lt;!-- 不拦截某个路径 --&gt; &lt;mvc:exclude-mapping path="/user/**"/&gt; &lt;bean class="com.zc.interceptor.Interceptor01"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; 然后每次请求中执行顺序：preCompletion , postCompletion , afterCompletion 多个拦截器执行顺序: 多个拦截器的执行顺序preCompletion等于springMvc.xml中配置拦截器的顺序 postCompletion , afterCompletion与springMvc.xml中配置拦截器的顺序相反]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SpringMVC第一阶段]]></title>
      <url>%2F2016%2F12%2F28%2FSpringMVC01%2F</url>
      <content type="text"><![CDATA[springMVC什么是springMVC springMVC是spring公司出品的一个表现层框架 springMVC作用 从请求中接受数据 将处理好的数据返回给页面 入门程序 建项目，引jar包 创建包结构，控制层用controller 处理流程 3.在web.xml中配置dispacherServlet 123456789101112131415&lt;servlet&gt; &lt;servlet-name&gt;springMvc&lt;/servlet-name&gt; &lt;servlet-class&gt;&lt;/servlet-class&gt; &lt;!-- tomcat一启动就加载 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springMvc&lt;/servlet-name&gt; &lt;!-- /* 拦截所有路劲，都会进入dispatherServlet中但不放行，所以不能使用 *.action 拦截url路劲以.action结尾的，这样的路劲才能进入dispatherServlet / 拦截所有路劲，但是不包括j.sp，但是 js,css,png,jpg 等都会被拦截而不放行 --&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 如果没有配置springMvc的核心配置文件的位置，那么会默认去找 上面Servlet-name的值-servlet.xml 这个名称的配置文件。 当然也可以手动配置12345//在上面的`&lt;servlet-class&gt;`下面加&lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:SpringMvc.xml&lt;/param-value&gt;&lt;/init-param&gt; 4.这里采用注解的方式 现在配置文件中开启包的扫描&lt;context:component-scan base-package=&quot;cn.itcast.controller&quot;/&gt; 然后再在controller中的类ItemsController上加上@Controller 在list方法上加@RequestMapping(&quot;/list&quot;) 表示标记url到请求方法的映射，其实就是通过url找到需要的controller方法 相当于一个map @RequestMapping(value=&quot;/list&quot;)也是对的，@RequestMapping(name=&quot;/list&quot;)自己测的是对的，但是网上说不对。。。 配置注解驱动：下面会详细讲&lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;/&gt; 5.跳转： ModelAndView modelView = new ModelAndView(); 模型和视图：模型放了返回给页面的数据，视图指定了页面的地址 在SpringMvc中model底层中其实是将数据放入了request中，并且对request域进行了扩展 modelView.addObject(&quot;itemList&quot;,itemList); 将返回的页面的数据放入model中其实就相当于放入了request域中 modelView.setViewName(&quot;/WEB-INF/jsp/itemList.jsp&quot;); 指定页面的位置 这里面的路劲叫做逻辑路径，就是页面地址的字符串 可以配置视图解析器，配置路劲前面跟后面的东西12345//前面是/WEB-INF/jsp/，后面是.jsp&lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/jsp/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt;&lt;/bean&gt; 最后返回return modelView; 逻辑路径：就是页面地址的字符串物理路径：是根据逻辑路径中的地址来加载页面成view对象 然后再通过访问：.../list.action 就可以访问到ItemsController里面的list方法，并执行完毕之后跳转到/WEB-INF/jsp/itemList.jsp中 springMvc的三大组件： 处理器映射器： 处理器适配器 视图解析器 如果没有手动配置处理器映射器跟处理器适配器可以正常运行，但每个请求都会去找springmvc默认的文件DispatcherServlet.properties,去里面找合适的处理器映射器跟处理器适配器，这样会降低系统的访问效率 所以我们需要手动配置处理器映射器跟处理器适配器，就不用去默认的配置文件中找了，加快效率 老版本：在DispatcherServlet.properties中呢， 新版本：在包下面的类中， 在公司中都不用，用这个&lt;mvc:annotation-driven /&gt; 注解驱动：自动配置最新版本的处理器映射器跟处理器适配器 只是为了方便 面试题：注解驱动和注解扫描是否都是需要配置的？为什么？区别是什么？ 注解驱动:是为我们自动配置最新版的注解形式的处理器映射器和处理器适配器 注解扫描:扫描指定包下有@controller注解的类 两个东西不是一回事, 不要混淆视听 视图解析器：作用是将前缀和后缀分开在我们的controller中写页面地址的时候方便使用 配置好前缀跟后缀后：页面的路劲=前缀+controller中的地址+后缀 1234&lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value=""&gt;&lt;/property&gt; &lt;property name="suffix" value=""&gt;&lt;/property&gt;&lt;/bean&gt; 架构流程 用户发送请求至前端控制器DispatcherServlet. DispatcherServlet收到请求调用HandlerMapping处理器映射器。 处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 DispatcherServlet通过HandlerAdapter处理器适配器调用处理器. 执行处理器(Controller，也叫后端控制器)。 Controller执行完成返回ModelAndView. HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet DispatcherServlet将ModelAndView传给ViewReslover视图解析器. ViewReslover解析后返回具体View. DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。 DispatcherServlet响应用户. 组件说明 DispatcherServlet：前端控制器 用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。 HandlerMapping：处理器映射器 HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 Handler：处理器 Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。 由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。 HandlAdapter：处理器适配器 通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。 View Resolver：视图解析器 View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户. View：视图 springmvc框架提供了很多的View视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是jsp。 一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。 说明：在springmvc的各个组件中，处理器映射器、处理器适配器、视图解析器称为springmvc的三大组件。需要用户开放的组件有handler、view Mybatis跟SpringMvc跟Spring架构整合 model.addAttribute(&quot;item&quot;,items);其实就是将数据放入了request域中并做了扩展 SpringMvc规定只有controller方法返回一个普通的字符串，就认为是页面的名称，会走视图解析器拼接完整的页面路径 架构整合思路dao层：映射文件，接口文件，pojo使用逆向工程自动生成sqlMapConfig.xml mybatis核心配置文件中可以为空的但是必须有ApplicationContext-dao.xml数据源，连接池，会话工厂，mapper包扫面 service层：ApplicationContext-service.xml 配置@Service注解扫面ApplicationContext-trans.xml 注解事务 controller层：SpringMvc.xml注解扫描，注解驱动，视图解析器 具体实现 导入jar包，配置配置文件，创建包结构 通过mybatis的逆向工程生成dao跟pojo 创建一些列的配置文件 参数绑定 从页面中接受参数： 默认支持的类型(需要哪个加哪个)：HttpServletRequest，HttpServletResponse，HttpSession，model(可以理解为Request域) 简单类型：String,double,integer,long,boolean等 pojo类型 pojo包装类QueryVo 自定义转换器converter 默认支持的类型的意思就是可以在方法的参数上直接加参数，就会就收到 12345678910//演示SpringMvc默认支持的参数@RequestMapping("/toEdit")public String toEdit(HttpServletRequest request,Model model)&#123; String id=request.getParameter("id"); Item items=itemsService.findItemById(Integer.parseInt(id)); //将数据放入model中，其实就是将数据放入了request域中并做了扩展 model.addAttribute("items",items); //SpringMvc规定只有controller方法返回一个普通的字符串，就认为是页面的名称，会走视图解析器拼接完整的页面路径 return "editItems";&#125; 2.简单类型:接收的变量名称必须等于页面上的input框的name值，SpringMvc自动进行类型转化 123public String update(Integer id,String name)&#123; &#125; 3.pojo类型:接收pojo中的属性值必须等于页面上的input框的name值 123public String update(Items items)&#123; &#125; 4.QueryVo:如果传入的是QueryVo，那么页面上框的name值是属性.属性.属性。。。 12345678910111213141516public class QueryVo&#123; private Items items; private String ids;&#125;&lt;form action="$&#123;pageContext.request.contextPath &#125;/search.action" mothod="post"&gt;&lt;input type="input" name="items.name" /&gt;&lt;input type="input" name="items.price" /&gt;&lt;/form&gt;@RequestMapping("/search")public String search(QueryVo vo) throws Exception&#123; System.out.println(vo); return "success";&#125; 自定义转换SpringMvc可以进行简单类型的自动类型的转换，但是无法转化日期类型，所以需要自定义转化器来转换 可以在建一个CustomerGlobalStrToDateConverter类实现Converter接口 1234567891011121314public class CustomerGlobalStrToDateConverter implements Converter&lt;String, Date&gt; &#123; @Override public Date convert(String source) &#123; try &#123; //具体转换内容 Date date = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss").parse(source); return date; &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 在SpringMvc.xml配置文件中配置一下 12345678&lt;bean id="conversionService" class="org.springframework.format.support.FormattingConversionServiceFactoryBean"&gt; &lt;property name="converters"&gt; &lt;set&gt; &lt;!-- 自定义全局字符串转日期转换器 --&gt; &lt;bean class="CustomerGlobalStrToDateConverter全路劲"/&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; 传入参数的注解1234@RequestMapping(value=&quot;/list&quot;) public ModelAndView list()&#123; &#125; 在括号中添加参数@RequestParam(defaultValue = &quot;1&quot;) Long id 表述默认传入的参数是1 如果传入一个新的id就是那个新的 添加@RequestParam(required = boolean) Long id false：传与不传没区别 true：不传参数就会报400错误 添加@RequestParam(&quot;id&quot;) Long id 不传就会报400 编码问题因为SpringMvc不像Struts2一样能自动解决乱码问题，所以需要手动解决如果是post提交可以，配置一个过滤器：get提交可以手动编解码或配置tomcat SpringMvc跟Struts2的区别 struts2： struts2的核心控制器是filter 接收参数：模型驱动(也就是全局类型的对象，但是他是不安全的所以他的核心控制器需要配置成多例) 返回参数：struts2使用值栈 springMvc： SpringMvc核心控制器是servlet 接受参数：springMvc采用方法级别的局部变量来接受参数，局部变量用完就销毁，所以线程是安全的 返回数据：springMvc使用request域]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Shiro]]></title>
      <url>%2F2016%2F12%2F05%2FShiro%2F</url>
      <content type="text"><![CDATA[shiroShiro安全框架什么是Shiro 它是一个安全框架，用于解决系统的认证和授权问题，同时提供了会话管理，数据加密机制。 传统登陆方式 Shiro登陆方式 Shiro的内部组织结构 可以用在javaEE环境。Shiro可以帮助我们完成：认证，授权，加密，会话管理，与Web集成，缓存等。 primary Concerns 主要的功能： Authentication 认证 Authorization 授权 Session Management 会话管理 Cryptography 加密 应用程序如何使用Shiro框架 Shiro SecurityManager:安全管理,最核心的控制器Realm域 :程序员提供的安全数据 可以看出，程序员只关注两部分： 如何获取Subject. 如何定义一个符合规定的Realm域（密码比较器的定义也是程序员干的） Shiro使用时要配置相关过滤器(anon,authc,authcBasic,perms,port,rest,roles,ssl,user,logout) Shiro中有十个拦截器，但可以只配置一个代理的就行，以一当十1234567891011121314//shiro的filter必须在struts2的filter之前，否则action无法创建&lt;filter&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; //这里的名字在spring中还会用到 &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 使用引入依赖pom.xml或jarbao12345&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-all&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt; 配置过滤器（上面有）配置shiro配置文件 在applicationContext.xml中配置shiro配置文件,放在事务管理器之前配置，Spring中引入生成Shiro的动态代理，使用cglib的方式&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot; /&gt; 同时添加专门配置shiro的配置文件&lt;import resource=&quot;spring/applicationContext-shiro.xml&quot;/&gt; 和ehcache支持ehcache-shiro.xml里面放(记得在pom中引入依赖)： 1234567891011&lt;ehcache updateCheck=&quot;false&quot; name=&quot;shiroCache&quot;&gt; &lt;defaultCache maxElementsInMemory=&quot;10000&quot; eternal=&quot;false&quot; timeToIdleSeconds=&quot;120&quot; timeToLiveSeconds=&quot;120&quot; overflowToDisk=&quot;false&quot; diskPersistent=&quot;false&quot; diskExpiryThreadIntervalSeconds=&quot;120&quot; /&gt;&lt;/ehcache&gt; 写配置文件 新建一个applicationContext-shiro.xmlShiro的配置的文件 里面的约束就是Spring的约束，因为Spring与Shire天生就是一对 具体内容 SecurityManager配置 配置Realm域 密码比较器 代理如何生成？ 用工厂来生成Shiro的相关过滤器 配置缓存：ehcache缓存 安全管理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 &lt;description&gt;Shiro的配置文件&lt;/description&gt; &lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt; &lt;property name=&quot;realm&quot; ref=&quot;authRealm&quot;/&gt;&lt;!-- 引用自定义的realm --&gt; &lt;!-- 缓存 --&gt; &lt;property name=&quot;cacheManager&quot; ref=&quot;shiroEhcacheManager&quot;/&gt; &lt;/bean&gt; &lt;!-- 自定义权限认证 --&gt; &lt;bean id=&quot;authRealm&quot; class=&quot;自定义了一个Realm域的包名&quot;&gt; &lt;property name=&quot;userService&quot; ref=&quot;userService&quot;/&gt; &lt;!-- 自定义密码加密算法 --&gt; &lt;property name=&quot;credentialsMatcher&quot; ref=&quot;passwordMatcher&quot;/&gt; &lt;/bean&gt; &lt;!-- 设置密码加密策略 md5hash --&gt; &lt;bean id=&quot;passwordMatcher&quot; class=&quot;自定义密码比较器的全路径&quot;/&gt; &lt;!-- filter-name这个名字的值来自于web.xml中filter的名字 --&gt; &lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt; &lt;!--登录页面 --&gt; &lt;property name=&quot;loginUrl&quot; value=&quot;/index.jsp&quot;&gt;&lt;/property&gt; &lt;!-- 登录成功后 --&gt; &lt;property name=&quot;successUrl&quot; value=&quot;/home.action&quot;&gt;&lt;/property&gt; &lt;!-- 还有过滤器过滤的属性`filterChainDefinitions` anon（匿名访问）可以直接访问 authc（认证）不登录不可以直接访问 --&gt; &lt;property name=&quot;filterChainDefinitions&quot;&gt; &lt;!-- /**代表下面的多级目录也过滤 --&gt; &lt;value&gt; /index.jsp* = anon /home* = anon /sysadmin/login/login.jsp* = anon /sysadmin/login/logout.jsp* = anon /login* = anon /logout* = anon /components/** = anon /css/** = anon /images/** = anon /js/** = anon /make/** = anon /skin/** = anon /stat/** = anon /ufiles/** = anon /validator/** = anon /resource/** = anon /** = authc /*.* = authc &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 用户授权/认证信息Cache, 采用EhCache 缓存 --&gt; &lt;bean id=&quot;shiroEhcacheManager&quot; class=&quot;org.apache.shiro.cache.ehcache.EhCacheManager&quot;&gt; &lt;property name=&quot;cacheManagerConfigFile&quot; value=&quot;classpath:ehcache-shiro.xml&quot;/&gt; &lt;/bean&gt; &lt;!-- 保证实现了Shiro内部lifecycle函数的bean执行 --&gt; &lt;bean id=&quot;lifecycleBeanPostProcessor&quot; class=&quot;org.apache.shiro.spring.LifecycleBeanPostProcessor&quot;/&gt; &lt;!-- 生成代理，通过代理进行控制 --&gt; &lt;bean class=&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot; depends-on=&quot;lifecycleBeanPostProcessor&quot;&gt; &lt;property name=&quot;proxyTargetClass&quot; value=&quot;true&quot;/&gt; &lt;/bean&gt; &lt;!-- 安全管理器 --&gt; &lt;bean class=&quot;org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor&quot;&gt; &lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot;/&gt; &lt;/bean&gt; 自定义realm 在认证、授权内部实现机制中都有提到，最终处理都将交给Realm进行处理。 因为在Shiro中，最终是通过Realm来获取应用程序中的用户、角色及权限信息的。 通常情况下，在Realm中会直接从我们的数据源中获取Shiro需要的验证信息。可以说，Realm是专用于安全框架的DAO. 记得配置到配置文件 注入userService跟credentialsMatchar密码比较器(父类的父类中已经有了，所以就不用再注入了) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * 自定义了一个Realm域 （主要作用是提供安全数据：用户，角色，模块） * @author Administrator * */public class AuthRealm extends AuthorizingRealm &#123; //注入userService private UserService userService; public void setUserService(UserService userService) &#123; this.userService = userService; &#125; //授权 /** * 验证用户是否具有某某权限 * 当jsp页面上碰到Shiro标签时就会调用这个方法，当第一次碰到时才调用这个方法 */ protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection pc) &#123; //1.得到用户信息 User user = (User) pc.fromRealm(this.getName()).iterator().next(); //2.通过对象导航,得到用户的角色列表 Set&lt;Role&gt; roles = user.getRoles(); List&lt;String&gt; permissions = new ArrayList&lt;String&gt;(); //3.遍历角色列表，得到用户的每个角色 for(Role role :roles)&#123; //得到每个角色 ，并通过对象导航，进一步加载这个角色下的模块列表 Set&lt;Module&gt; modules = role.getModules(); //遍历模块的集合，得到每个模块信息 for(Module module :modules)&#123; permissions.add(module.getName()); &#125; &#125; //声明AuthorizationInfo的一个子类对象 SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); info.addStringPermissions(permissions); return info; &#125; /** * 认证（在登录时就会调用这个方法） Subject.login(); * 参数：AuthenticationToken代表用户在界面上输入的用户名和密码 * 返回值不为null就会执行密码比较器 */ protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; //1.将token转化为子类对象 UsernamePasswordToken upToken = (UsernamePasswordToken) token; //2.从token中获取用户在界面输入的用户名 String username = upToken.getUsername(); //3.调用业务逻辑，根据用户名查询用户对象 List&lt;User&gt; userList = userService.find(&quot;from User where userName=?&quot; , User.class, new String[]&#123;username&#125;); if(userList!=null &amp;&amp; userList.size()&gt;0)&#123; //查询到了用户对象，说明用户名是正确的 User user = userList.get(0); //principal 代表用户信息 credentials 代表用户的密码 第三个参数：只要是一个字符串就可以 AuthenticationInfo info = new SimpleAuthenticationInfo(user,user.getPassword(),this.getName()); return info; &#125; //4.组织返回的结果 return null; &#125;&#125; 自定义的密码比较器CustomCredentialsMatcher 继承SimpleCredentialsMatcher 重写了密码比较的方法 第一个参数AuthenticationToken 代表用户在界面上输入的用户名和密码 第二个参数AuthenticationInfo 代表了当前这个用户在数据库中的信息，就会有加密后的密码 返回值： true证明密码比较成功了 false证明密码比较失败，密码输入错误，程序会抛出异常12345678910public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) &#123; //1.将用户在界面输入的密码进行加密 UsernamePasswordToken upToken = (UsernamePasswordToken) token;//向下转型 String inputpwd = new String(upToken.getPassword()); String inputpwdEncrypt = Encrypt.md5(inputpwd, upToken.getUsername());//md5hash算法进行加密 //2.将用户在数据库中的密码读取出来 String dbPwd = info.getCredentials().toString(); //3.进行比较 return super.equals(inputpwdEncrypt, dbPwd); &#125; 自己的程序与Shiro交互12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class LoginAction extends BaseAction &#123; private static final long serialVersionUID = 1L; private String username; private String password; public String login() throws Exception &#123; //如果username是空的则表示还没有登陆跳转到登陆页面 if(UtilFuns.isEmpty(username))&#123; return &quot;login&quot;; &#125; try &#123; //1.与Shiro交互 Subject subject = SecurityUtils.getSubject(); //2.调用subject中的方法，来实现登录 //将用户在界面输入的用户名密码进行封装 UsernamePasswordToken token = new UsernamePasswordToken(username, password); //当login执行时，就会自动跳入authRealm域中的认证方法 subject.login(token); //3.从Shiro中取出用户登录结果信息 User user = (User) subject.getPrincipal(); //4.将用户信息保存到session中 session.put(SysConstant.CURRENT_USER_INFO, user); return SUCCESS; &#125; catch (Exception e) &#123; e.printStackTrace(); request.put(&quot;errorInfo&quot;, &quot;登录失败，用户名或密码错误！&quot;); return &quot;login&quot;; &#125; &#125; //退出 public String logout()&#123; session.remove(SysConstant.CURRENT_USER_INFO); //删除session return &quot;logout&quot;; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; 面使用shiro标签，/home/title.jsp 主菜单当页面上出现shiro标签的时候就会去授权，然后比较集合中是否有这一项，有就显示没有就不显示12345&lt;%@ taglib uri=&quot;http://shiro.apache.org/tags&quot; prefix=&quot;shiro&quot;%&gt;&lt;shiro:hasPermission name=&quot;sysadmin&quot;&gt;&lt;span id=&quot;topmenu&quot; onclick=&quot;toModule(&apos;sysadmin&apos;);&quot;&gt;系统管理&lt;/span&gt;&lt;/shiro:hasPermission&gt; shiro的实现图解 shiro的执行流程 使用shiro实现用户登录 授权的过程 md5hash 比md5强大的加密算法md5hash： 破解md5： 破解思路，暴力破解，因为md5是一 一 对应方式，所以如果有一个大的数据字典就很容易破解 或者如果能够操作数据库把密码改成一个自己知道的密文即可，md5hash不知道具体加密的次数跟盐所以行不通 md5hash算法加密： md5hash因为同样的明文对应不一样的密文，所以不好破解 因为加密的时候有三个参数:原文，盐(用什么参数加密),跟加密的次数]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ZTree]]></title>
      <url>%2F2016%2F12%2F03%2FZTree%2F</url>
      <content type="text"><![CDATA[zTree zTree是中国人写的非常强大的一个”树”，下面介绍一种非常经典的多级目录勾选树。 zTree生成一个多级目录的勾选树：基于角色模块分配，两个表是多对多的关系。 把相关的js，css引入进来 在要用zTree的地方引进这些样式跟js12345&lt;link rel=&quot;stylesheet&quot; href=&quot;$&#123;ctx&#125;/components/zTree/css/zTreeStyle/zTreeStyle.css&quot; type=&quot;text/css&quot; /&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;$&#123;ctx&#125;/components/zTree/js/jquery-1.4.4.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;$&#123;ctx&#125;/components/zTree/js/jquery.ztree.core-3.5.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;$&#123;ctx&#125;/components/zTree/js/jquery.ztree.excheck-3.5.min.js&quot;&gt;&lt;/script&gt; 进入到模块分配页面1234567891011/** * 进入到模块分配页面 */public String tomodule() throws Exception &#123; //1.根据角色id,得到角色对象 Role role = roleService.get(Role.class, model.getId()); //2.将角色对象放入值栈中 super.push(role); //3.跳页面 return &quot;tomodule&quot;;&#125; 配置页面123456789101112&lt;script&gt;var zTreeObj;var setting = &#123; check : &#123; enable : true &#125;, data : &#123; simpleData : &#123; enable : true &#125; &#125;&#125;; 使用ajax从服务器端接受数据生成对应的树123456789101112131415$(function()&#123; $.ajax(&#123; type:&quot;GET&quot;, url:&quot;$&#123;ctx&#125;/sysadmin/roleAction_loadJSONTreeNodes.action?id=$&#123;id&#125;&quot;, dataType:&quot;json&quot;, success:initzTree &#125;);&#125;);function initzTree(data)&#123; //1.初始化树 zTreeObj = $.fn.zTree.init($(&quot;#jkTree&quot;), setting, data); //2.展开树上的所有结点 zTreeObj.expandAll(true);&#125; 服务器传过来的数据为了加载zTree树上的结点，zTree树上结点的数据结构：12 [&#123;&quot;id&quot;:&quot;编号&quot;,&quot;pId&quot;:&quot;父结点的编号&quot;,&quot;name&quot;:&quot;结点名称&quot;,&quot;checked&quot;:&quot;true|false&quot;&#125;, &#123;&quot;id&quot;:&quot;编号&quot;,&quot;pId&quot;:&quot;父结点的编号&quot;,&quot;name&quot;:&quot;结点名称&quot;,&quot;checked&quot;:&quot;true|false&quot;&#125;] 使用什么技术来生成这样json串 JSON-lib FastJSON GSON 自己手动拼接 其实自己拼接是最方便的因为可以，实现在拼接的时候能够实现自己需要的业务 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public String loadJSONTreeNodes() throws Exception &#123; //1.根据角色 id加载角色对象 Role obj = roleService.get(Role.class, model.getId()); //2.对象导航，得到当前这个角色所具有的模块列表 Set&lt;Module&gt; moduleSet = obj.getModules(); //3.加载数据库中所有的模块列表 List&lt;Module&gt; moduleList = moduleService.find(&quot;from Module where state=1&quot;, Module.class, null); //4.拼接JSON串 StringBuilder sb = new StringBuilder(); sb.append(&quot;[&quot;); int size=moduleList.size();//得到集合中元素的个数 for(Module module :moduleList)&#123; size--; //遍历出每个模块 sb.append(&quot;&#123;\&quot;id\&quot;:\&quot;&quot;).append(module.getId()); sb.append(&quot;\&quot;,\&quot;pId\&quot;:\&quot;&quot;).append(module.getParentId()); sb.append(&quot;\&quot;,\&quot;name\&quot;:\&quot;&quot;).append(module.getName()); sb.append(&quot;\&quot;,\&quot;checked\&quot;:\&quot;&quot;); if(moduleSet.contains(module))&#123; //当前用户具有的这个模块 sb.append(&quot;true&quot;); &#125;else&#123; sb.append(&quot;false&quot;); &#125; sb.append(&quot;\&quot;&#125;&quot;); if(size&gt;0)&#123; sb.append(&quot;,&quot;); //当size=0时，说明集合中没有其它元素要遍历了，此时的元素是最后一个元素，后面不能添加逗号了 &#125; &#125; sb.append(&quot;]&quot;); //输出 HttpServletResponse response = ServletActionContext.getResponse(); //设置编码 response.setContentType(&quot;application/json;charset=UTF-8&quot;);//json数据的mime类型：application/json response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);//设置响应消息头，没有缓存 response.getWriter().write(sb.toString());//向客户端输出 return NONE;&#125; 使FastJson转换Json,使用的时候在所有的工具中速度最快(效率没有上面的快，因为需要创建很多对象，跟遍历集合) list—-&gt;数组 map—–&gt;键值对123456789101112131415List&lt;Map&lt;String,object&gt;&gt; list = new ArrayList&lt;Map&lt;String,object&gt;&gt;();for(Module module : moduleList)&#123; Map&lt;String,object&gt; maps=new Map&lt;String,object&gt;(); maps.put(&quot;id&quot;,module.getId()); maps.put(&quot;pId&quot;,module.getParentId()); maps.put(&quot;name&quot;,module.getName()); boolean flag= false; if(moduleSet.contains(module))&#123; flag=true; &#125; maps.put(&quot;ckecked&quot;,flag); list.add(maps);&#125;String jsonStr = Json.toJSONString(list); FastJson中 对象转String用toJSONString 字符串转Json用Parse 根据服务器端的数据获取所被选择的节点123456789101112131415161718192021function submitCheckedNodes() &#123; var nodes = new Array(); nodes = zTreeObj.getCheckedNodes(true); //取得选中的结点 var str = &quot;&quot;; for (i = 0; i &lt; nodes.length; i++) &#123; if (str != &quot;&quot;) &#123; str += &quot;,&quot;; &#125; str += nodes[i].id; &#125; //把选中的节点id拼成一个字符串传到action $(&apos;#moduleIds&apos;).val(str);&#125;&lt;/script&gt;//把选中的节点id拼成一个字符串传到action&lt;input type=&quot;hidden&quot; id=&quot;moduleIds&quot; name=&quot;moduleIds&quot; value=&quot;&quot; /&gt;//zTree树&lt;div&gt; &lt;ul id=&quot;jkTree&quot; class=&quot;ztree&quot;&gt;&lt;/ul&gt; &lt;/div&gt; 实现模块分配123456789101112131415161718192021222324/*** 实现模块分配* &lt;input type=&quot;hidden&quot; name=&quot;id&quot; value=&quot;$&#123;id&#125;&quot;/&gt;&lt;input type=&quot;hidden&quot; id=&quot;moduleIds&quot; name=&quot;moduleIds&quot; value=&quot;&quot; /&gt;*/public String module() throws Exception &#123; //1.根据角色id,得到角色对象 Role role = roleService.get(Role.class, model.getId()); //2.切割模块的id字符串 String []mids = moduleIds.split(&quot;,&quot;);//模块id的数组 //创建一个模块列表的集合 Set&lt;Module&gt; moduleSet = new HashSet&lt;Module&gt;(); //3.遍历每个模块的id for(String id :mids)&#123; Module m = moduleService.get(Module.class, id);//加载出模块对象 moduleSet.add(m);//将加载出来的模块对象，放入模块列表中 &#125; //3.设置角色与模块的关系 role.setModules(moduleSet); //4.保存角色与模块的关系 roleService.saveOrUpdate(role); //5.跳页面 return &quot;alist&quot;;&#125; 每一个数据类型都有自己的mime的文件类型： json是：application/json,Tomcat会在web.xml中校验mime类型 所以需要设置编码： response.setContentType(&quot;application/json;charset=UTF-8&quot;); 设置响应消息头，没有缓存 response.setHeader(Cache-Control,) 注： Ztree可以通过setting的callback属性添加事件 1234var setting = ｛callback:&#123; onClick:function()&#123;&#125;&#125;｝ Ztree树的容器class必须是ztree Ztree树容器是&lt;li&gt; 也可以接受一个text数值在转成json zTree的加载过程：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[maven第二阶段]]></title>
      <url>%2F2016%2F11%2F30%2Fmaven02%2F</url>
      <content type="text"><![CDATA[Maven Maven的拆分与聚合 一个完整的早期开发好的crm项目，现在要使用maven工程对它进行拆分，这时候就可以将dao拆解出来形成表现独立的工程，同样service,action也都这样拆分 工程拆分之后，将来还要聚合（聚合就是将拆分的工程进一步组合在一起，又形成一个完整的项目） 为了达到聚合的目标，所以今天会引入 父工程（maven project） 子模块(maven module) dao ,service, web 开发步骤： 创建一个maven父工程创建后的父工程如下：从它的目录结构可以看出，父工程本身不写代码，它里面有一个pom.xml文件，这个文件可以将多个子模块中通用的jar所对应的坐标，集中在父工程中配置，将来的子模块就可以不需要在pom.xml中配置通用jar的坐标了 创建这个父工程的子工程点击next,进入下图：点击next： 再次查看父工程的pom.xml工程 查看子模块的pom.xml,发现多了一个parent结点并且内部所包含的结点，其实就是父工程的坐标12坐标=groupId+artifactId+version 组织名 项目名 版本 冲突问题的解决通过添加&lt;exclusion&gt;标签来解决冲突 在父工程中引入了struts-core,hibernate-core，就发现jar包是有冲突的 Javassist存在版本上冲突问题，一个高版本一个低版本 解决：去除struts2中的javassist，就要在struts依赖中右键 进入下图 会在工程中添加： 依赖调解原则maven自动按照下边的原则调解： 第一声明者优先原则 在pom文件定义依赖，先声明的依赖为准 struts-spring-plugins和spring-context中都有spring-beans，前者是4.2.4版本比较高。 测试：如果将struts-spring-plugins放在spring-context前面，系统将导入spring-beans-4.2.4。 分析：由于spring-context在前边以spring-context依赖的spring-beans-4.2.4为准，所以最终spring-beans-4.2.4添加到了工程中。 路径近者优先原则 还是以上面为例子：如果手动引入一个spring-beans,则会导入手动引入的这个，因为这个不需要依赖其他的jar包而存在，找到的时候路劲最短。 使用版本锁定实现冲突解决 首先父工程中pom.xml文件中添加&lt;dependencyManagement&gt; 在父工程中锁定，他本身并不引入坐标，他会规定他所依赖的项目要引这个坐标时，会在锁定的版本前面有一个小锁，开发的时候就要选择锁定的那个版本。 锁定之后父项目并没有引入这个坐标，这是锁定了而已 然后哪个项目需要在引入 在使用坐标时，对于同一个框架，引入多次时，它的版本信息就会多次出现，所以 可以借用常量的思想，将这些版本号提取出来，在需要用到的时候，直接写版本的常量名称就可以了。 引上面的常量 依赖关系依赖具有传递性，但不是无限传递的，传递的规则如下：解决方法：如果在依赖传递过程中，导致jar包丢失，我们的做法很简单，就是再导入一次坐标 依赖具有传递性： action依赖于service，如果在service中引入dao，那么在action中引入service的时候会把dao引入进来 如果想把引入的jar包所依赖的jar包全部干掉就再上面解决冲突中的代码中&lt;artifactId&gt;*&lt;/artifactId&gt; &lt;groupId&gt;*&lt;/groupId&gt;加*即可 继续开发添加service跟dao 创建一个maven module项目创建结束后，父工程中结构如下：父工程的pom.xml文件如下： 在service的pom.xml文件中引入dao的jar包 Web层的子模块创建：web层的packing就不是jar了web是要依赖service 配置文件的添加： 整合applicationContext的时侯，因为每层要用到的配置不一样，所以可以把它分为三个配置文件最后在通过123&lt;import resource=&quot;classpath:spring/applicationContext-dao.xml&quot;/&gt;&lt;import resource=&quot;classpath:spring/applicationContext-service.xml&quot;/&gt;&lt;import resource=&quot;classpath:spring/applicationContext-action.xml&quot;/&gt; 这种方式把三个配置文件整合到一起，放到web层下。 hibernate中的配置如下(有一些改进的地方)： 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;property name=&quot;dialect&quot;&gt; org.hibernate.dialect.MySQLDialect &lt;/property&gt; &lt;property name=&quot;show_sql&quot;&gt;true&lt;/property&gt; &lt;property name=&quot;format_sql&quot;&gt;false&lt;/property&gt; &lt;!-- 自动建表以前是update但是不规范 --&gt; &lt;property name=&quot;hbm2ddl.auto&quot;&gt;none&lt;/property&gt; &lt;!-- 懒加载，配合web.xml中配置的 openSessionInViewFilter --&gt; &lt;property name=&quot;hibernate.enable_lazy_load_no_trans&quot;&gt;true&lt;/property&gt; &lt;!--校验模式 JPA java persistent api--&gt; &lt;property name=&quot;javax.persistence.validation.mode&quot;&gt;none&lt;/property&gt; &lt;mapping resource=&quot;cn/itcast/domain/Customer.hbm.xml&quot;/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 还需要注意，hibernate的映射文件要建好对应的包结构\src\main\resources\cn\itcast\domain PO类(实体类的七个规范)： 是一个共有类 提供私有的属性 提供共有的getter与setter 实现java.io.Serializable 提供一个无参的构造方法 不要使用final修饰 如果是基本数据类型，要使用它的包装类 私服搭建下载nexus并安装 下载 Nexus 是Maven仓库管理器，通过nexus可以搭建maven仓库，同时nexus还提供强大的仓库管理功能，构件搜索功能等。 下载Nexus， 下载地址： http://www.sonatype.org/nexus/archived/ 安装并运行： 解压进入到指定的目录：nexu-2.12.0.01-bundle\nexus-2.12.0.-01\bin 执行nexus.bat install 安装成功就会在服务中新增一个nexus服务 卸载进入到bin目录下执行：nexus.bat uninstall 启动 启动： 方法一：直接进入到bin目录中执行nexus.bat start 方法二：直接进入到服务列表中启动 配置 查看nexus的配置文件conf/nexus.properties 123456789# Jetty sectionapplication-port=8081 # nexus的访问端口配置application-host=0.0.0.0 # nexus主机监听配置(不用修改)nexus-webapp=$&#123;bundleBasedir&#125;/nexus # nexus工程目录nexus-webapp-context-path=/nexus # nexus的web访问路径# Nexus sectionnexus-work=$&#123;bundleBasedir&#125;/../sonatype-work/nexus # nexus仓库目录runtime=$&#123;bundleBasedir&#125;/nexus/WEB-INF # nexus运行程序目录 访问： http://localhost:8081/nexus/ 登陆成功之后会有四种仓库类型： hosted，宿主仓库，部署自己的jar到这个类型的仓库，包括releases和snapshot两部分，Releases公司内部发布版本仓库、 Snapshots 公司内部测试版本仓库 proxy，代理仓库，用于代理远程的公共仓库，如maven中央仓库，用户连接私服，私服自动去中央仓库下载jar包或者插件。 group，仓库组，用来合并多个hosted/proxy仓库，通常我们配置自己的maven连接仓库组。 virtual(虚拟)：兼容Maven1 版本的jar或者插件 nexus仓库默认在目录中： 仓库的介绍： central：代理仓库，代理中央仓库 apache-snapshots：代理仓库存储snapshots构件，代理地址https://repository.apache.org/snapshots/ central-m1：virtual类型仓库，兼容Maven1 版本的jar或者插件 releases：本地仓库，存储releases构件。 snapshots：本地仓库，存储snapshots构件。 third party：第三方仓库 public：仓库组 七个仓库对应着本地服务器的nexus-2.12.0-01-bundle/sonatype-work/nexus/storage 测试,上传到私服使用install会把项目打包放到本地仓库中 要想打包发到本地仓库跟私服你中就要执行以下步骤： 需要在客户端即部署dao工程的电脑上配置maven环境，并修改maven目录/conf/settings.xml 文件，配置连接私服的用户和密码 。此用户名和密码用于私服校验，因为私服需要知道上传的账号和密码 是否和私服中的账号和密码一致。 12345678910&lt;server&gt; &lt;id&gt;releases&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt;&lt;server&gt; &lt;id&gt;snapshots&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;admin123&lt;/password&gt;&lt;/server&gt; 在pom.xml中加入一段配置： 12345678910 &lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;releases&lt;/id&gt; &lt;url&gt;http://localhost:8081/nexus/content/repositories/releases/&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;snapshots&lt;/id&gt; &lt;url&gt;http://localhost:8081/nexus/content/repositories/snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt; &lt;/distributionManagement&gt; 意思为：配置私服仓库的地址，本公司的自己的jar包会上传到私服的宿主仓库，根据工程的版本号决定上传到哪个宿主仓库，如果版本为release则上传到私服的release仓库，如果版本为snapshot则上传到私服的snapshot仓库 现在就可以用deploy命令上传到私服中的snapshots 从私服上下载jar包需求 没有配置nexus之前，如果本地仓库没有，去中央仓库下载，通常在企业中会在局域网内部署一台私服服务器，有了私服本地项目首先去本地仓库找jar，如果没有找到则连接私服从私服下载jar包，如果私服没有jar包私服同时作为代理服务器从中央仓库下载jar包，这样做的好处是一方面由私服对公司项目的依赖jar包统一管理，一方面提高下载速度，项目连接私服下载jar包的速度要比项目连接中央仓库的速度快的多。 在setting.xml中配置仓库当然得先保证：本地仓库中跟项目中没有需要的jar包，这里显示dao 把下面的配置文件放到maven的setting配置文件的profile结点中,意思是告诉maven本地找不到去哪个私服找（注意如果是在别人的私服中找记得改ip） 1234567891011121314151617181920212223242526272829&lt;profile&gt;&lt;!--profile的id--&gt; &lt;id&gt;dev&lt;/id&gt; &lt;repositories&gt; &lt;repository&gt; &lt;!--仓库id，repositories可以配置多个仓库，保证id不重复--&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;!--仓库地址，即nexus仓库组的地址--&gt; &lt;url&gt;http://localhost:8081/nexus/content/groups/public/&lt;/url&gt; &lt;!--是否下载releases构件--&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;!--是否下载snapshots构件--&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;!-- 插件仓库，maven的运行依赖插件，也需要从私服下载插件 --&gt; &lt;pluginRepository&gt; &lt;!-- 插件仓库的id不允许重复，如果重复后边配置会覆盖前边 --&gt; &lt;id&gt;public&lt;/id&gt; &lt;name&gt;Public Repositories&lt;/name&gt; &lt;url&gt;http://localhost:8081/nexus/content/groups/public/&lt;/url&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;/profile&gt; 找的时候会到public公共仓库中去找，因为，公共仓库中包含下面几个仓库，会依次寻找： 为了使得这些配置生效需要在配置一下在profile结点下边配置一下： 123 &lt;activeProfiles&gt; &lt;activeProfile&gt;dev&lt;/activeProfile&gt; &lt;/activeProfiles&gt; 现在在项目中把dao关掉，会报错，在update一下，就会去本地找，找不到再去私服中找，然后找到了先下载到本地仓库中然后就能够使用了就不会报错了 管理仓库组 nexus中包括很多仓库，hosted中存放的是企业自己发布的jar包及第三方公司的jar包，proxy中存放的是中央仓库的jar，为了方便从私服下载jar包可以将多个仓库组成一个仓库组，每个工程需要连接私服的仓库组下载jar包。 打开nexus配置仓库组，如下图：上图中仓库组包括了本地仓库、代理仓库等。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mybatis第二阶段]]></title>
      <url>%2F2016%2F11%2F28%2Fmybatis02%2F</url>
      <content type="text"><![CDATA[Mybatis第二阶段输入映射跟输出映射 输入映射（dao传入参数类型） 简单类型 #{}占位符：传入参数是简单类型(String,double,integer),#{}里面的名称随意写 ${}拼接符：传入的参数是简单类型(String,double,integer),${}里面必须是value pojo #{}:传入参数是pojo类，#{}变量类型必须是pojo类中的属性.属性.属性。。。 ${}:传入参数是pojo类，#{}变量类型必须是pojo类中的属性.属性.属性。。。 输出映射(dao的返回值类型) 简单类型：只有返回值为一行一列的时候，返回的才可以使简单类型 pojo类型： 使用resultType属性进行自动映射，查询的sql语句返回的列名必须和pojo的属性名称一一对应 使用resultMap手动映射将列名跟pojo类中的属性一一映射 List：使用resultType属性进行自动映射，要写list中的泛型的类型 使用resultMap的时候首先先要定义： resultMap的使用 id属性:resultMap的唯一标识 type属性:返回的结果集标识 id标签：指定主键列的映射关系 column列:数据库中的列名 property:pojo类中的属性名称 result标签:指定非主键列的映射关系 column列:数据库中的列名 property:pojo类中的属性名称 association标签：指定单个对象的映射关系 里面也是id跟result 然后在使用的时候在，sql语句的标签上直接写resultMap=上面resultMap的id即可 动态sql 作用：在一些高级查询的时候，sql语句中的where条件可能多也可能少，所以这时候就要动态的拼接sql 在要写sql语句的后边可以添加： where标签作用： 可以自动添加where关键字 可以去掉第一个条件中的and关键字 where里边也有if标签：判断传入的参数是否为空等判断条件用 全局sql语句 sql标签：封住sql语句，封装后别的sql语句中可以重用这个条件. include标签：引用封装好的sql语句，例如&lt;include refide=&quot;userWhere&quot;&gt;&lt;/include&gt;. 12345678910111213141516171819&lt;!-- sql标签的作用是封装sql语句可以重用 --&gt;&lt;sql id=&quot;userWhere&quot;&gt; &lt;!-- where标签作用: 1. 可以自动添加where关键字, 2. 可以去掉第一个条件中的and关键字 --&gt; &lt;where&gt; &lt;if test=&quot;username != null and username != &apos;&apos;&quot;&gt; and username like &apos;%$&#123;username&#125;%&apos; &lt;/if&gt; &lt;if test=&quot;sex != null and sex != &apos;&apos;&quot;&gt; and sex =#&#123;sex&#125; &lt;/if&gt; &lt;/where&gt;&lt;/sql&gt;&lt;select id=&quot;findUserByNameAndSex&quot; parameterType=&quot;cn.itcast.pojo.User&quot; resultType=&quot;cn.itcast.pojo.User&quot;&gt; select * from user &lt;!-- 引用封装好的sql语句 --&gt; &lt;include refid=&quot;userWhere&quot;&gt;&lt;/include&gt;&lt;/select&gt; where中的foreach标签，拼接功能：遍历传入的集合数据 collection: 要遍历的集合变量 item: 每遍历一次当前的变量数据 open:循环开始拼接的字符串 close:循环结束拼接的字符串 separator:分隔符 12345678910&lt;select id="findUserByIds" parameterType="cn.itcast.pojo.QueryVo" resultType="cn.itcast.pojo.User"&gt; select * from user&lt;select id="findUserByIds" parameterType="cn.itcast.pojo.QueryVo" resultType="cn.itcast.pojo.User"&gt; select * from user &lt;where&gt; &lt;foreach collection="ids" item="id" open="id in(" close=")" separator=","&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 关联映射一对一 以订单表跟用户表为例,订单跟用户从整体上来看是多对一，但是从局部上来看是一对一 使用自动映射resultType,可以封装大而全的自定义pojo把要接受的数据的属性全都封装在其中 12345678910111213//集成订单对象, 拥有订单对象中所有属性和方法, 又加入了user的属性public class CustomOrdersAndUser extends Orders&#123; private Integer uid; private String username;// 用户姓名 private String sex;// 性别 private Date birthday;// 生日 private String address;// 地址//映射文件&lt;select id="findOrdersAndUser1" resultType="cn.itcast.pojo.CustomOrdersAndUser"&gt; select o.*, u.id uid, u.username, u.birthday,u.sex,u.address from orders o, user u where o.user_id = u.id&lt;/select&gt; 使用手动映射resultMap,需要手动指定sql的列名和pojo中的属性名的关系，在resultMap中可以使用association标签来映射单个对象的关系 123456789101112131415161718192021222324252627282930313233343536373839public class Orders &#123; private Integer id; private Integer userId; private String number; private Date createtime; private String note; private User user;public class User &#123; private Integer id; private String username;// 用户姓名 private String sex;// 性别 private Date birthday;// 生日 private String address;// 地址 private List&lt;Orders&gt; ordersList;//映射文件&lt;resultMap type="cn.itcast.pojo.Orders" id="ordersAndUserResultMap"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="user_id" property="userId"/&gt; &lt;result column="number" property="number"/&gt; &lt;result column="createtime" property="createtime"/&gt; &lt;!-- association标签: 指定对应单个对象的映射关系 property: 将查询出的用户的数据放入Orders对象中的user属性中保存 javaType: property中指定的user属性的类型 --&gt; &lt;association property="user" javaType="cn.itcast.pojo.User"&gt; &lt;id column="uid" property="id"/&gt; &lt;result column="username" property="username"/&gt; &lt;result column="birthday" property="birthday"/&gt; &lt;result column="sex" property="sex"/&gt; &lt;result column="address" property="address"/&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;!-- 一对一手动映射为 --&gt; &lt;select id="findOrdersAndUser2" resultMap="ordersAndUserResultMap"&gt; select o.*, u.id uid, u.username, u.birthday,u.sex,u.address from orders o, user u where o.user_id = u.id&lt;/select&gt; 多对多 自动映射是用不了的，所以使用手动映射12345678910111213141516171819202122&lt;resultMap type="cn.itcast.pojo.User" id="userAndOrdersResultMap"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="username" property="username"/&gt; &lt;result column="birthday" property="birthday"/&gt; &lt;result column="sex" property="sex"/&gt; &lt;result column="address" property="address"/&gt; &lt;!-- collection标签指定对集合对象关系映射 property:将查询出的订单数据放入User对象中的ordersList属性中保存 ofType: ordersList的泛型的类型 --&gt; &lt;collection property="ordersList" ofType="cn.itcast.pojo.Orders"&gt; &lt;id column="oid" property="id"/&gt; &lt;result column="user_id" property="userId"/&gt; &lt;result column="createtime" property="createtime"/&gt; &lt;result column="number" property="number"/&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id="findUserAndOrders" resultMap="userAndOrdersResultMap"&gt; select u.*,o.id oid, o.user_id, o.createtime, o.number from user u, orders o where u.id = o.user_id&lt;/select&gt; mybatis跟spring的整合 映射文件, 接口, mybatis核心配置文件 Application-Context.xml spring的配置文件, 这里面配置了数据源, 连接池, 会话工厂, 引入原生dao或者是动态代理的接口 使用 导入jar包：mybatis,spring,两者的整合包，还有log4j包，数据库连接的包… 创建appliationContext.xml配置文件 加载jdbc配置文件 配置数据库连接池 配置会话工厂 1234567891011121314151617181920&lt;!-- 加载配置文件 --&gt;&lt;context:property-placeholder location="jdbc.properties" /&gt;&lt;!-- 数据库连接池 --&gt;&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driver&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;property name="maxActive" value="10" /&gt; &lt;property name="maxIdle" value="5" /&gt;&lt;/bean&gt;&lt;!-- 配置会话工厂 --&gt;&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 配置mybatis核心配置文件的位置 --&gt; &lt;property name="configLocation" value="classpath:sqlMapConfig.xml"&gt;&lt;/property&gt; &lt;!-- 引用上面配置好的数据源 --&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt; 测试原生DAO开发 在spring的配置文件中配置UserDao,把会话工厂给配置进去 123&lt;bean id="userDao" class="cn.itcast.dao.UserDaoImpl"&gt; &lt;property name="sqlSessionFactory" ref="sqlSessionFactory"&gt;&lt;/property&gt;&lt;/bean&gt; 接口 1234public interface UserDao &#123; public User findUserbyId(Integer id); public List&lt;User&gt; findUserByName(String userName);&#125; 实现类 1234567891011121314151617public class UserDaoImpl extends SqlSessionDaoSupport implements UserDao &#123;@Override public User findUserbyId(Integer id) &#123; //会话是线程不安全的, 所以它的最佳使用范围在方法体内 SqlSession openSession = this.getSqlSession(); User user = openSession.selectOne("test.findUserById", id); return user; &#125; @Override public List&lt;User&gt; findUserByName(String userName) &#123; //会话是线程不安全的, 所以它的最佳使用范围在方法体内 SqlSession openSession = this.getSqlSession(); List&lt;User&gt; list = openSession.selectList("test.findUserByUserName", userName); return list; &#125;&#125; 动态代理的方式引入单个Mapper（不常用）123456&lt;bean id="userMapper" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt; &lt;!-- 配置mapper接口的全路径名称呢 --&gt; &lt;property name="mapperInterface" value="cn.itcast.mapper.UserMapper"&gt;&lt;/property&gt; &lt;!-- 引入会话工厂 --&gt; &lt;property name="sqlSessionFactory" ref="sqlSessionFactory"&gt;&lt;/property&gt;&lt;/bean&gt; 但是这种方法有一个局限性，就是每一个dao都要配置一下，代码量太大了，所以一般用下面这种方法 使用包扫描的方式批量引入整个包下的mapper 推荐使用包扫描的时候不用引入会话工厂, 它会自动调用当前配置文件下的会话工厂配置 实例化引用的时候, 使用类名, 首字母小写 1234&lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 引入包的全路径名称 --&gt; &lt;property name="basePackage" value="cn.itcast.mapper"&gt;&lt;/property&gt;&lt;/bean&gt; 逆向工程 作用：替我们连接数据库根据表生成pojo,接口和映射文件 导入三个包: 还有数据库连接包 mapper生成配置文件 在generatorConfig.xml中配置mapper生成的详细信息，注意改下几点： 添加要生成的数据库表 文件所在包路径 mapper文件所在包路径 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;context id="testTables" targetRuntime="MyBatis3"&gt; &lt;commentGenerator&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name="suppressAllComments" value="true" /&gt; &lt;/commentGenerator&gt; &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt; &lt;jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql://localhost:3306/mybatis" userId="root" password="admin"&gt; &lt;/jdbcConnection&gt; &lt;!-- &lt;jdbcConnection driverClass="oracle.jdbc.OracleDriver" connectionURL="jdbc:oracle:thin:@127.0.0.1:1521:yycg" userId="yycg" password="yycg"&gt; &lt;/jdbcConnection&gt; --&gt; &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 NUMERIC 类型解析为java.math.BigDecimal --&gt; &lt;javaTypeResolver&gt; &lt;property name="forceBigDecimals" value="false" /&gt; &lt;/javaTypeResolver&gt; &lt;!-- targetProject:生成PO类的位置 --&gt; &lt;javaModelGenerator targetPackage="cn.itcast.ssm.po" targetProject=".\src"&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name="enableSubPackages" value="false" /&gt; &lt;!-- 从数据库返回的值被清理前后的空格 --&gt; &lt;property name="trimStrings" value="true" /&gt; &lt;/javaModelGenerator&gt; &lt;!-- targetProject:mapper映射文件生成的位置 --&gt; &lt;sqlMapGenerator targetPackage="cn.itcast.ssm.mapper" targetProject=".\src"&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name="enableSubPackages" value="false" /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- targetPackage：mapper接口生成的位置 --&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="cn.itcast.ssm.mapper" targetProject=".\src"&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name="enableSubPackages" value="false" /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定数据库表 --&gt; &lt;table tableName="items"&gt;&lt;/table&gt; &lt;table tableName="orders"&gt;&lt;/table&gt; &lt;table tableName="orderdetail"&gt;&lt;/table&gt; &lt;table tableName="user"&gt;&lt;/table&gt; &lt;!-- &lt;table schema="" tableName="sys_user"&gt;&lt;/table&gt; &lt;table schema="" tableName="sys_role"&gt;&lt;/table&gt; &lt;table schema="" tableName="sys_permission"&gt;&lt;/table&gt; &lt;table schema="" tableName="sys_user_role"&gt;&lt;/table&gt; &lt;table schema="" tableName="sys_role_permission"&gt;&lt;/table&gt; --&gt; &lt;!-- 有些表的字段需要指定java类型 &lt;table schema="" tableName=""&gt; &lt;columnOverride column="" javaType="" /&gt; &lt;/table&gt; --&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 使用java类生成mapper文件： 12345678910111213141516171819Public void generator() throws Exception&#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; File configFile = new File("generatorConfig.xml"); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); &#125; Public static void main(String[] args) throws Exception &#123; try &#123; GeneratorSqlmap generatorSqlmap = new GeneratorSqlmap(); generatorSqlmap.generator(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 运行，拷贝生成的mapper文件到工程中指定的目录中 Mapper.xml的文件拷贝至mapper目录内 Mapper.java的文件拷贝至mapper目录内 注意：mapper xml文件和mapper.java文件在一个目录内且文件名相同。 逆向工程注意事项 Mapper文件内容不覆盖而是追加 Mapper.xml文件已经存在时，如果进行重新生成则mapper.xml文件内容不被覆盖而是进行内容追加，结果导致mybatis解析失败。 解决方法：删除原来已经生成的mapper xml文件再进行生成。 Mybatis自动生成的po及mapper.java文件不是内容而是直接覆盖没有此问题 Table schema问题 下边是关于针对oracle数据库表生成代码的schema问题： Schma即数据库模式，oracle中一个用户对应一个schema，可以理解为用户就是schema。 当Oralce数据库存在多个schema可以访问相同的表名时，使用mybatis生成该表的mapper.xml将会出现mapper.xml内容重复的问题，结果导致mybatis解析错误。 解决方法： 在table中填写schema，如下：&lt;table schema=&quot;XXXX&quot; tableName=&quot; &quot; &gt; XXXX即为一个schema的名称，生成后将mapper.xml的schema前缀批量去掉，如果不去掉当oracle用户变更了sql语句将查询失败。 快捷操作方式：mapper.xml文件中批量替换：“from XXXX.”为空 Oracle查询对象的schema可从dba_objects中查询，如下：select * from dba_objects]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[maven第一阶段]]></title>
      <url>%2F2016%2F11%2F27%2Fmaven01%2F</url>
      <content type="text"><![CDATA[Maven第一阶段Maven 的好处maven： 专家，内行 最直观的效果(项目的大小小很多): 传统项目 Maven 项目 分析出maven优点是如何实现的 依赖管理 就是对jar包管理的过程 分析jar包查找的过程： 在项目与maven的仓库之间有索引，所以速度也不会变慢 项目的一键构建什么是构建： 找到编译好的项目目录下运行 mvn tomcat：run，就会自动转成war放到apach下并打开服务器，然后还有提示输入的网址 Maven的安装 下载之后直接解压即可 对应的目录结构： Maven的配置及仓库的位置配置环境变量 电脑上需安装环境，安装JDK1.7 +版本 （将配置环境变量path ） 配置MAVEN_HOME ，变量值就是你的安装 的路径（bin目录之前一级目录）,然后将 %MAVEN_HOME%/bin 加入环境变量path 配置完之后可以用 mvn -version 或简写为 mvn -v 来查看版本信息3.3.9来确定是否安装成功。 仓库的配置 但是使用mvn tomcat：run ，还是不能使用，因为在默认情况下会通过 pom.xml 这个配置文件先在本地仓库中找，找不到再去远程仓库，找不到再去中央仓库. 仓库的分类 本地仓库自己电脑上的仓库 远程仓库：公司内部的服务器上 中央仓库apache服务器上呢：有些收费的jar包没有例如：Oraclehttp://repo1.maven.org/maven2 配置maven的查找本地仓库的路劲： 找到maven的安装目录下的conf下的settings.xml打开 配置&lt;localRepository&gt;本地仓库的地址&lt;/localRepository&gt; maven工程的标准目录结构既符合maven目录规范，又符合web项目规范Maven的目录结构的规范： Maven 命令使用dos窗口，进入到有pom.xml的目录即可。 mvn compile 编译 compile是maven工程的编译命令，作用是将src/main/java下的文件编译为class文件输出到target目录下。 mvn test 单元测试，先编译在运行单元测试类 test是maven工程的测试命令， mvn test ,会执行src/test/java 下的单元测试类。 mvn clean 清除编译 clean是maven工程的清除命令，执行clean会删除target目录及内容。 mvn package：java项目导jar包，web项目导war包 package是maven工程的打包命令，对于java工程执行package打包成jar包，对于web工程打包成war包。 mvn install(install 第二次执行的时候，不会删除没有修改的内容，只会修改更改过的内容) install是maven工程的安装命令，执行install将maven打成jar包或war包发布到本地仓库。 当后面的命令执行时，前面的操作过程也都会自动执行， Eclipse中使用maven配置 高版本的eclipse中内置maven的插件，在windows中的属性中找到maven属性配置Installations中路劲改为自己的maven的路劲点击add ２. 在eclipse中配置仓库的位置 ３. 构建索引 ｀Window—show view ——other———-maven Repositories｀ ４． 重构索引 使用１. 在eclipse中创建一个maven工程 ２. 选择maven project ３. 点next进入下面的界面 ４. 可以看到一个helloworld工程，但报错(添加下面的内容就OK了) （有的时候web的目录结构不会自动生成，所以需要在webapp下加一个WEB_INF/web.xml） ５. src/java/main创建了一个Servlet，但报错 ６. 要解决问题，就是要将servlet-api-xxx.jar包放进来，作为maven工程应当添加servlet的坐标，从而导入它的jar 直接打开helloworld工程的pom.xml文件，再添加坐标 ７. 添加后自动生成的结果如下： 一般web项目需要 servlet-api 2.5跟 jsp-api:2.0８. 添加包的坐标时，还可以指定这个jar包将来的作用范围 jar包冲突 通过命令运行的tomcat是仓库中的插件，跟以前的tomcat没关系因为刚才自己引入了servlet跟jsp的jar包但是，tomcat中自己已经内置了这两个jar包了所以会发生冲突所以需要插入jar包的时候选择一下作用范围：provided ９. 调整jdk,在pom.xml文件中添加如下配置： 运行时，jdk版本低于1.7的时候也会报错，把下面的代码配置到pom.xml中即可调整版本到1.7 12345678910111213&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.7&lt;/source&gt; &lt;target&gt;1.7&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 有的时候改了jdk版本也会报错，重新删除刷一遍，不行再多来几遍。 注意的一些问题 maven有错误的时候可以右键maven--&gt;update project,然后有的时候就不会报错了 有的时候也会报错，剪贴然后重新粘贴保存一下 到服务器上运行有两种方式： 运行maven仓库中的Tomcat插件，右键项目然后找到run as ---&gt; 里面有好多maven的命名，也可以有maven build...自己敲命令，运行在在服务器上就是tomcat:run 也能像以前web中那样，先把项目加入服务器中在运行 仓库中的插件默认运行的Tomcat6的版本，下面是切换版本的方法： 1234567891011121314151617181920212223242526Tomcat6:&lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;tomcat-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt; &lt;configuration&gt; &lt;path&gt;/wp&lt;/path&gt; &lt;port&gt;8080&lt;/port&gt; &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt; &lt;url&gt;http://localhost:8080/manager/html&lt;/url&gt; &lt;server&gt;tomcat6&lt;/server&gt; &lt;/configuration&gt; &lt;/plugin&gt;Tomcat7: &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;configuration&gt; &lt;port&gt;9090&lt;/port&gt; &lt;path&gt;/mgr&lt;/path&gt; &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt; &lt;server&gt;tomcat7&lt;/server&gt; &lt;/configuration&gt;&lt;/plugin&gt; 简要说明一下： path 是访问应用的路径 port 是tomcat 的端口号 uriEncoding URL按UTF-8进行编码，这样就解决了中文参数乱码。 Server 指定tomcat名称。 运行：右键-----&gt; run as -----&gt;maven build..:tomcat:run Tomcat的版本就要改为tomcat7:run]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[easyUI]]></title>
      <url>%2F2016%2F11%2F23%2FeasyUI%2F</url>
      <content type="text"><![CDATA[easyUI什么是EasyUI JQuery EasyUI 是一组基于Jquery的UI插件集合体，而JQuery EasyUI的目标就是帮助Web开发者更轻松的打造出功能丰富并且美观的UI界面。开发者不需要编写复杂的javaScript，也不需要对Css样式有深入的了解，开发者需要了解的只是一点简单的HTML的标签 界面效果 是用于后台界面的 使用准备 下载，解压 找到需要的相应的jar包(2个)，还有两个css 导入 locale plugins themes ,里面有相应的界面需要的css，js等 1234&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;../themes/default/easyui.css&quot;&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;../themes/icon.css&quot;&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery.easyui.min.js&quot;&gt;&lt;/script&gt; 使用 使用EasyUI有两种方式(超链接来做示范) 使用标签的方式&lt;a href=&quot;#&quot; class=&quot;easy-linkbutton&quot; data-options=&quot;iconCls:&#39;icon-search&#39;&quot;&gt;超链接&lt;/a&gt; iconCls:代表图片 使用js 12345678910&lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; $(&quot;#btn&quot;).linkbutton(&#123; iconCls:&apos;icon-add&apos; &#125;); &#125;);&lt;/script&gt;&lt;a id=&quot;btn&quot; href=&quot;#&quot;&gt;超链接&lt;/a&gt; 注意使用的时候就不能在引入jquery的包了，要不显示不出来（自己测得，不知道对不对） EasyUI的组件EasyUI 的组件：LayOut(布局) 在LayOut上加EasyUI的属性:data-options=&quot;fit:true&quot; //表示适应父类 上面的各个布局可以删除 属性split:true表示可以变换大小 上面的文字，大小都可以改 EasyUI 的组件：Accordion（分类）Accordion 的概述分类空间允许用户使用多面板，但在同一时间只会显示一个。每个面板都内建支持展开和折叠功能。点击一个面板的标题将会展开或折叠面板主体。面板内容可以通过指定的href属性使用ajax方式读取面板内容，用户可以定义一个被选中的面板，如果未指定，那么第一个面板就是默认的 Accodion的使用 我们可以更改或修改面板的一些功能以后再重新创建它。1234//定义在展开和折叠的时候是否显示动画效果。 默认是有的$(&apos;#aa&apos;).accordion(&#123; animate:false&#125;); 布局嵌套分类可以达到想要的结果 EasyUI 的组件：Tabs（选项卡） 选项卡是可以关的，因为上面有一个属性是：data-options:&quot;closabled:true&quot; 可以点一个按钮创建一个新的选项卡 如果存在打开，不存在新建一个新的选项卡 可以在选项卡中放内容，这里用到了&lt;iframe src=&quot;&quot;&gt; ,只要一打开这个选项卡，iframe中就会加载src的路径，会向服务器请求内容 为了防止a标签中的地址自己也打开一个界面,可以在方法中加一个return false; EasyUI 的组件：Datagrid（数据表格） EasyUI 的组件：Window（窗口）属性设置为closed:true是关闭窗口并隐藏的，所以可以加一个事件来弹出窗口 窗口里放一个表单，可以把其变成Ajax方式提交，返回参数后还需要变为json对象 因为没有json的参数 所以将字符串转换为Json var jsonData=eval(&quot;(&quot;+data+&quot;)&quot;) 显示消息： slide滑动 修改：弹出的key跟转json的key相同就会数据回显 text-decoration:none; 这个标签的属性会让链接的文字没有下划线]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mybatis第一阶段]]></title>
      <url>%2F2016%2F11%2F23%2Fmybatis01%2F</url>
      <content type="text"><![CDATA[mybatis第一阶段什么是mybits mybits是apache的一个持久层的框架，之前叫做ibatis,后来代码迁移到google code上，现在代码是在github上. MyBatis是一个优秀的持久层框架，它对jdbc的操作数据库的过程进行封装，使开发者只需要关注 SQL 本身，而不需要花费精力去处理例如注册驱动、创建connection、创建statement、手动设置参数、结果集检索等jdbc繁杂的过程代码。 Mybatis通过xml或注解的方式将要执行的各种statement（statement、preparedStatement、CallableStatement）配置起来，并通过java对象和statement中的sql进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射成java对象并返回。 Mybits的入门 企业建包的时候实体类用 pojo 而不用domain，原因是domain不规范，只能测试用，正式的是 pojo JDBC中存在的一些问题 频繁创建释放资源，比较浪费 sql语句在代码中硬编码不利于维护 传入参数硬编码在代码中不利于维护 遍历结果硬编码不利于维护 复习JDBC 加载数据库驱动 创建并获取数据库链接 创建jdbc statement对象 设置sql语句 设置sql语句中的参数(使用preparedStatement) 通过statement执行sql并获取结果 对sql执行结果进行解析处理 释放资源(resultSet、preparedstatement、connection) Mybatis的架构 mybatis配置 SqlMapConfig.xml ，此文件作为mybatis的全局配置文件，配置了mybatis`的运行环境等信息。 mapper.xml文件即sql映射文件，文件中配置了操作数据库的sql语句。此文件需要在SqlMapConfig.xml中加载。 通过mybatis环境等配置信息构造SqlSessionFactory即会话工厂 由会话工厂创建sqlSession即会话，操作数据库需要通过sqlSession进行。sqlSession线程是不安全的，所以把他最好放在局部方法中 mybatis底层自定义了Executor执行器接口操作数据库，Executor接口有两个实现，一个是基本执行器、一个是缓存执行器。 Mapped Statement也是mybatis一个底层封装对象，它包装了mybatis配置信息及sql映射信息等。mapper.xml文件中一个sql对应一个Mapped Statement对象，sql的id即是Mapped statement的id。 Mapped Statement对sql执行输入参数进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql前将输入的java对象映射至sql中，输入参数映射就是jdbc编程中对preparedStatement设置参数。 Mapped Statement对sql执行输出结果进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql后将输出结果映射至java对象中，输出结果映射过程相当于jdbc编程中对结果的解析处理过程。 Mybatis的使用 下载jar包在github上，核心包跟依赖包，还需要连接数据库的包https://github.com/mybatis/mybatis-3/releases 创建一个congif的文件夹，创建核心配置文件 pooled:mybatis的连接池 创建映射文件 namespace命名空间: 引入约束： 入门程序： 手动引入log4j跟以前的不一样: 123456# Global logging configurationlog4j.rootLogger=DEBUG, stdout# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 需求： 根据用户id查询用户 根据用户名模糊查询用户信息列表 添加用户 修改用户 删除用户 核心配置文件约束： 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configurationPUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; 映射配置文件约束： 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapperPUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;test&quot;&gt;&lt;/mapper&gt; 根据用户id查询用户 外部资源文件jdbc.properties 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8jdbc.username=rootjdbc.password=123 编写核心配置文件 123456789101112131415161718&lt;configuration&gt; &lt;!-- 引入存放用户名密码的资源文件 --&gt; &lt;properties resource=&quot;jdbc.properties&quot;/&gt; &lt;!-- 和spring整合后 environments配置将废除--&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!-- 使用jdbc事务管理--&gt; &lt;transactionManager type=&quot;JDBC&quot; /&gt; &lt;!-- 数据库连接池--&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; 编写映射配置文件 namespace：命名空间，用于隔离sql语句，后面会讲另一层非常重要的作用。 id:sql语句的唯一标识 parameterType: 指定传入参数类型 resultType:指定返回值类型 #{}占位符, 起到占位的作用, 如果传入的参数类型为简单类型(String, double, long, boolean,integer等), 那么#{}中的变量名称可以随便写 12345&lt;mapper namespace=&quot;test&quot;&gt; &lt;select id=&quot;findUserById&quot; parameterType=&quot;java.lang.Integer&quot; resultType=&quot;cn.itcast.pojo.User&quot;&gt; select * from user where id=#&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; mybatis框架需要加载映射文件，将Users.xml添加在SqlMapConfig.xml，如下： 123&lt;mappers&gt; &lt;mapper resource=&quot;sqlmap/User.xml&quot;/&gt;&lt;/mappers&gt; 测试： 12345678910111213//加载核心配置文件String resource = &quot;sqlMapConfig.xml&quot;;//把核心配置文件通过流读入InputStream inputStream = Resources.getResourceAsStream(resource);//根据核心配置文件的流来创建会话工厂SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream);//获取会话SqlSession openSession = factory.openSession();//通过会话执行sql语句, 第一个参数: 调用的sql语句, namespace+.+sql语句id, 第二个参数为传入sql语句的参数//当整个配置文件中只有唯一的一个会话的时候可以省略前面的namespaceUser user = openSession.selectOne(&quot;test.findUserById&quot;, 1);System.out.println(user); 根据用户名字模糊查询用户信息如果查询结果返回集合, 那么可以调用selectList方法, selectList方法返回的结果就是一个集合, 那么mybatis不知道里面的泛型是什么,所以需要配置泛型的类型${}拼接符, 作用是字符串原样拼接, 如果传入的参数是简单类型(String, double, long, boolean,integer等),那么${}中的变量名称必须是value-注意: 如果使用${}拼接符有可能造成sql注入的风险 映射配置文件 123&lt;select id=&quot;findUserByUserName&quot; parameterType=&quot;java.lang.String&quot; resultType=&quot;cn.itcast.pojo.User&quot;&gt; select * from user where username like &apos;%$&#123;value&#125;%&apos;&lt;/select&gt; 测试 123456789String resource = &quot;sqlMapConfig.xml&quot;;InputStream inputStream = Resources.getResourceAsStream(resource);//创建会话工厂SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream);//创建会话SqlSession openSession = factory.openSession();List&lt;User&gt; userList = openSession.selectList(&quot;test.findUserByUserName&quot;, &quot;张&quot;);System.out.println(userList); 插入用户 配置文件 123&lt;insert id=&quot;insertUser&quot; parameterType=&quot;cn.itcast.pojo.User&quot;&gt; INSERT INTO user (username, birthday, sex, address) values(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)&lt;/insert&gt; 测试 123456789101112131415161718192021@Testpublic void testInsertUser() throws Exception &#123; String resource = &quot;sqlMapConfig.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); //创建会话工厂 SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream); //创建会话 SqlSession openSession = factory.openSession(); User user = new User(); user.setUsername(&quot;老王&quot;); user.setSex(&quot;1&quot;); user.setBirthday(new Date()); user.setAddress(&quot;北京昌平&quot;); //执行添加 openSession.insert(&quot;test.insertUser&quot;, user); //提交事务, mybatis会替我们自动开启事务,但是不知道在哪行代码后提交, 所以需要我们手动提交事务 openSession.commit(); System.out.println(user);&#125; 自增主键返回 通过修改sql映射文件，可以将mysql自增主键返回： 12345678select LAST_INSERT_ID()mysql数据库函数, 用来返回最后增加的数据的主键idkeyProperty: 将查询出的主键数据放入传入参数User对象中的id属性中保存order相对于insert语句的执行顺序, 在insert前执行是before, 在insert后执行是after,由于mysql的自增原理执行完insert语句之后才将主键生成，所以这里selectKey的执行顺序为afterresultType: keyProperty中指定属性的类型 --&gt;&lt;selectKey keyProperty=&quot;id&quot; order=&quot;after&quot; resultType=&quot;java.lang.Integer&quot;&gt; select LAST_INSERT_ID()&lt;/selectKey&gt; Mysql使用 uuid实现主键 需要增加通过select uuid()得到uuid值 注意这里使用的order是“BEFORE” 12345678&lt;insert id=&quot;insertUser&quot; parameterType=&quot;cn.itcast.mybatis.po.User&quot;&gt;&lt;selectKey resultType=&quot;java.lang.String&quot; order=&quot;BEFORE&quot; keyProperty=&quot;id&quot;&gt;select uuid()&lt;/selectKey&gt;insert into user(id,username,birthday,sex,address) values(#&#123;id&#125;,#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)&lt;/insert&gt; 修改 配置文件 123&lt;update id=&quot;updateUserById&quot; parameterType=&quot;cn.itcast.pojo.User&quot;&gt; update user set username=#&#123;username&#125; where id=#&#123;id&#125;&lt;/update&gt; 测试 123456789101112131415String resource = &quot;sqlMapConfig.xml&quot;;InputStream inputStream = Resources.getResourceAsStream(resource);//创建会话工厂SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream);//创建会话SqlSession openSession = factory.openSession();User user = new User();user.setUsername(&quot;老李&quot;);user.setId(28);//调用sql语句执行openSession.update(&quot;test.updateUserById&quot;, user);//提交openSession.commit(); 删除 配置文件 123&lt;delete id=&quot;delUserById&quot; parameterType=&quot;int&quot;&gt; delete from user where id=#&#123;id&#125;&lt;/delete&gt; 测试 123456789101112String resource = &quot;sqlMapConfig.xml&quot;;InputStream inputStream = Resources.getResourceAsStream(resource);//创建会话工厂SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream);//创建会话SqlSession openSession = factory.openSession();//调用sql语句执行删除openSession.delete(&quot;test.delUserById&quot;, 29);//提交openSession.commit(); 核心配置文件加载映射文件的几种方式： mappers里面配置： mapper url:不推荐使用, 因为如果配置url就要写映射文件的绝对路径, 这样部署到linux系统的时候需要更改, 所以不方便 resource:映射文件的相对路径 class:接口的全路径名:一般动态代理开发的时候使用这种方式 1.要求接口文件和映射文件在同一个目录下 2.要求接口文件和映射文件除扩展名外名称必须完全一样 package：通过包扫描的方式批量引入mapper，name:指定包的路径名称 &lt;package name=&quot;cn.itcast.mapper&quot;/&gt; Dao的生成方式原生dao开发 需要程序员编写dao接口跟实现类 编写接口DAO 123456public interface UserDao &#123; public User findUserbyId(Integer id); public List&lt;User&gt; findUserByName(String userName);&#125; 实现类 123456789101112131415161718192021222324private SqlSessionFactory factory;//工厂由外部传入public UserDaoImpl(SqlSessionFactory factory) &#123; this.factory = factory;&#125;@Overridepublic User findUserbyId(Integer id) &#123; //会话是线程不安全的, 所以它的最佳使用范围在方法体内 SqlSession openSession = factory.openSession(); User user = openSession.selectOne(&quot;test.findUserById&quot;, id); return user;&#125;@Overridepublic List&lt;User&gt; findUserByName(String userName) &#123; //会话是线程不安全的, 所以它的最佳使用范围在方法体内 SqlSession openSession = factory.openSession(); List&lt;User&gt; list = openSession.selectList(&quot;test.findUserByUserName&quot;, userName); return list;&#125; 测试:用单元测试的@Before注解，先把SessionFactory实例化 1234567891011121314151617181920212223242526private SqlSessionFactory factory;//@Before是在@Test之前执行@Beforepublic void init() throws Exception&#123; String resource = &quot;sqlMapConfig.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); factory = new SqlSessionFactoryBuilder().build(inputStream);&#125;@Testpublic void testFindUserById() throws Exception &#123; //实例化userDao UserDao userDao = new UserDaoImpl(factory); User user = userDao.findUserbyId(1); System.out.println(user);&#125;@Testpublic void testFindUserByUserName() throws Exception&#123; //实例化userDao UserDao userDao = new UserDaoImpl(factory); List&lt;User&gt; list = userDao.findUserByName(&quot;张&quot;); System.out.println(list);&#125; 动态代理的开发方式 需要程序员编写dao接口,实现类由Mybaits生成 一般就不用dao作为包名了，用 mapper 接口 1234public interface UserMapper &#123; public User findUserById(Integer id); public List&lt;User&gt; findUserByUserName(String name);&#125; 配置文件 1234567891011121314&lt;mapper namespace=&quot;cn.itcast.mapper.UserMapper&quot;&gt; &lt;!-- id:sql语句的唯一标识 parameterType: 指定传入参数类型 resultType:指定返回值类型 --&gt; &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;cn.itcast.pojo.User&quot;&gt; select * from user where id=#&#123;id&#125; &lt;/select&gt; &lt;select id=&quot;findUserByUserName&quot; parameterType=&quot;java.lang.String&quot; resultType=&quot;cn.itcast.pojo.User&quot;&gt; select * from user where username like &apos;%$&#123;value&#125;%&apos; &lt;/select&gt;&lt;/mapper&gt; 动态代理dao开发方式规范： 映射文件中namespace必须等于接口的全路径名称 映射文件中的sql语句id必须等于接口中的方法名称 映射文件中传入参数类型parameterType指定类型, 必须等于接口中方法的传入参数类型 映射文件中的返回的结果集类型必须等于接口方法的返回值类型 引入映射文件的时候用&lt;package class=&quot;mapper&quot;/&gt; 生成的实现类在内存中找不到， SqlMapConfig.xml文件说明 配置的时候各个配置是有顺序的，不匹配会报错 properties :里面有resourse意思是引入配置文件例如JDBC的用户名跟密码 typeAliases:给单个类起别名 typeAlias&lt;typeAlias type=&quot;cn.itcast.pojo.User&quot; alias=&quot;user&quot;/&gt; type: 起别名的pojo的全路径名 alias: 自定义的别名 package:使用包扫描的方式批量给整个包下面的pojo起别名&lt;package name=&quot;cn.itcast.pojo&quot;/&gt; name:包的全路径名称 别名就是类名, 不区分大小写, 推荐根据java命名规则来使用别名 #{}和${}的区别 #{}表示一个占位符号 通过#{}可以实现preparedStatement向占位符中设置值，自动进行java类型和jdbc类型转换 #{}可以有效防止sql注入。 #{}可以接收简单类型值或pojo属性值。 如果parameterType传输单个简单类型值，#{}括号中可以是value或其它名称。 ${}表示拼接sql串，例如模糊查询的时候使用 通过${}可以将parameterType 传入的内容拼接在sql中且不进行jdbc类型转换 ${}可以接收简单类型值或pojo属性值，如果parameterType传输单个简单类型值，${}括号中只能是value。 parameterType和resultType parameterType：指定输入参数类型，mybatis通过ognl从输入对象中获取参数值拼接在sql中。 resultType：指定输出结果类型，mybatis将sql查询结果的一行记录数据映射为resultType指定类型的对象。 测试类中的selectOne和selectList selectOne查询一条记录，如果使用selectOne查询多条记录则抛出异常： 1org.apache.ibatis.exceptions.TooManyResultsException: Expected one result (or null) to be returned by selectOne(), but found: 3 at org.apache.ibatis.session.defaults.DefaultSqlSession.selectOne(DefaultSqlSession.java:70) selectList可以查询一条或多条记录。 hibernate和mybatis区别： hibernate： hibernate是一个orm框架，需要编写hql语句，自动化程度高，但是学习成本也高，使用复杂，但是写代码效率高，开发速度快. 使用场景：一般外包公司使用较多，因为开发速度快，一些传统项目也在用，oa,crm,erp mybatis: mybatis不是一个完全的orm框架，需要编写sql语句，学习成本低，比较简单。 使用场景：在互联网企业用的一般都是，电商，互联网金融等。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[fileUpload]]></title>
      <url>%2F2016%2F11%2F07%2FfileUpload%2F</url>
      <content type="text"><![CDATA[文件上传文件上传 文件上传的概念： 什么是文件上传，将本地的文件，通过流，写入到服务器上。 文件上传的技术 jspSmartUpload：应用在jsp中的文件上传和下载的组建。（应用在Model1年代） fileUpload ： Apache下的一个子项目，在java的环境下实现文件的上传 Servlet3.0 ： 注解开发，文件上传（API不全 ），异步请求 struts2 ： 支持文件上传（底层FileUpload） 文件上传的要素： 表单提交的方式是post(get有大小限制) 表单中必须有文件上传项，而且必须要有name属性跟值。&lt;input type=&quot;file&quot; name=&quot;upload&quot;&gt; 表单中必须要有enctype属性值为multipart/form-data要不拿不到文件内容 enctype有默认值为application/x-www-form-urlencoded如果不改的话，上传文件的时候只能上传文件名 enctype属性值为multipart/form-data时就不能用getParameter();来获得属性了要用String name =fileItem.getFiledName();来获得名字，用String value=fileItem.getString(&quot;编码方式&quot;);获得值 文件上传的原理分析 FileUpload文件上传的步骤分析123456789101112131415161718192021222324252627282930313233341.创建一个磁盘文件项工厂DiskFileItemFactory diskFileItemFactory=new DiskFileItemFactory();2.创建核心解析类ServletFileUpload servletFileUpload=new ServletFileUpload(diskFileItemFactory);3.解析request，返回List集合List&lt;FileItem&gt; list = servletFileUpload.parseRequest(request);4.遍历集合获得每个部分的内容，获得每个部分，如果是文件上传项，完成文件上传工作操作。for(FileItem fileItem:list)&#123; //4.1判断是否是普通项 if(fileItem.isFileField())&#123; //普通项 //接受到普通项的名字跟值 String name =fileItem.getFiledName(); String value=fileItem.getString(); &#125;else&#123; //文件项 //获得文件名跟输入流 String fileName=fileItem.getName(); InputStream is=fileItem.getInputStream(); //获得文件上传的路径： String path =this.getServletContext.getRealPath(&quot;/upload&quot;); OutputStream os=new FileOutputStream(path + &quot;/&quot;+fileName); //两个流对接 int len =0; byte[] b=new byte[1024]; while((len=is.read(b))!=-1)&#123; os.write(b,0,len); &#125; is.close(); os.close(); &#125; //删除临时文件 fileItem.delete();&#125; FileUpload中API DiskFileItemFactory：磁盘文件项工厂 12345//设置缓冲区的大小3MdiskFileItemFactory.setSizeThreshold(3*1024*1024);//设置临时文件存放的路径（比缓冲区大才会生成临时文件）String path=this.getServletContext.getRealPath(&quot;/temp&quot;);diskFileItemFactory.setRepository(new File(path)); ServletFileUpload 判断表单中的enctype属性是否是multipart/form-data 解析 request 设置中文文件名乱码 设置上传的当个文件大小 设置上传的总文件大小 FileItem 判断是普通项还是文件上传项 普通项(获得普通项名) 普通项(获得普通项的值) 上传项(获得文件名) 上传项(获得文件输入流) 删除临时文件 文件上传的问题解决 文件名路径重名（老版本的浏览器带文件名路径） 12345int id=fileName.lastIndexOf(&quot;/&quot;);if(id!= -1)&#123; //说明文件名中不包含路径 fileName=fileName.substring(id+1);&#125; 文件名重名(可以封装成一个工具类) 12int idx=fileName.laseIndexOf(&quot;.&quot;);String extetion=fileName.substring(idx); String newFileName=UUID.randomUUID().toString().replace(&quot;-&quot;,&quot;&quot;)+extetion; 一个目录下存放的文件过多(目录分离) 按时间分离：一个星期一个目录 按用户分离：一个用户一个目录 按个数分离：一个目录下放300个 按算法分离：按照特定的目录分离算法进行分离 123456789//算法分离（工具类中）//获得唯一文件名的hashcode值int code1=uuidFileName.hashCode();//让这个值&amp;0xf 到一个一级目录int d1=code1 &amp; 0xf;//让hashcode值右移4位int code2=code1&gt;&gt;&gt;4;int d2 = code2 &amp; 0xf; //作为2级目录return &quot;/&quot;+d1+&quot;/&quot;+d2; 以此类推可以得到最多8级目录，每级中有16个不同的值。使用这个工具类时如下： 注：在文件上传的时候因为form表单中的enctype属性值为mulipart/form-data时就不能用getParameter()了,所以就不能继承basicServlet了，要单独自己写一个servlet Struts中的文件上传 Struts2中实现文件上传的基本的功能： 在Struts2中实现文件上传是通过拦截器实现的 提供三个对象的属性即可： 上传的文件名：表单上传的名称+FileName. private String uploadFileName; 上传的文件类型：表单上传名称+ContentType. private String uploadContentType; 上传的文件 文件类型的表单上传项。 private Fileupload. 12345678910111213141516171819202122232425262728//实现文件上传，首先提供这三个属性private String uploadFileName;private String uploadContentType;private File upload;//记得要提供set方法//在指定的方法中实现文件上传private String uploadAction()&#123; //判断是否选中文件 if(upload != null)&#123; //文件上传的路劲 String realPath=&quot;.....&quot;; //可以获得唯一文件名 String uuidFileName = UploadUtils.getUUIDFileName(uploadFileName); //获得目录分离的路劲 String path = UploadUtils.getPath(uuidFileName); File file = new File (realPath + path); if(!file.exists())&#123; file.mkdirs(); &#125; //创建一个文件目录 String str=readPath+path+&quot;/&quot;+uuidFileName; File dickFile = new File (str); //实现文件上传 FileUtils.copyFile(upload,dickFile); &#125; return &quot;saveSuccess&quot;;&#125; 文件上传的参数都在 default.properties 中呢 有的则需要在拦截器中设置 1234567//设置拦截器需要在配置文件中&lt;action&gt;标签中设置&lt;interceptor-ref name=&quot;defaultStack&quot;&gt; &lt;!-- 数据的最大值 --&gt; &lt;param name=&quot;fileUpload.maximumSize&quot;&gt;1048576&lt;/param&gt; &lt;!-- 后缀名 --&gt; &lt;param name=&quot;fileUpload.allows&quot;&gt;.jpg&lt;/param&gt;&lt;/interceptor-ref&gt; 还需要在配置文件中设置input标签，如果上传内容与拦截器中规定的不同会走Input标签 还能再input返回的页面设置&lt;s:fielderror/&gt;显示上传的错误信息 uploadUtils123456789101112131415161718192021222324252627282930313233343536373839import java.util.UUID;/** * 文件上传的工具类 * @author zc * */public class UploadUtils &#123; /** * 获得唯一文件名的方法： * @param fileName * @return */ public static String getUUIDFileName(String fileName)&#123; // aaa.txt --- sdklflsdf.txt int idx = fileName.lastIndexOf(&quot;.&quot;); String extetion = fileName.substring(idx); return UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;)+extetion; &#125; /** * 获得分录分录的路径： * @param args */ public static String getPath(String uuidFileName)&#123; // 获得唯一文件名的hashCode值。 int code1 = uuidFileName.hashCode(); // 让这个值&amp;0xf 得到一个一级目录。 int d1 = code1 &amp; 0xf;// 作为1级目录. // 让hashCode值右移4位: int code2 = code1 &gt;&gt;&gt; 4; int d2 = code2 &amp; 0xf; // 作为2级目录. return &quot;/&quot;+d1+&quot;/&quot;+d2; &#125; public static void main(String[] args) &#123; System.out.println(&quot;986a6146e9104e00838c123bcc371cd3.txt&quot;.hashCode()); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[oracle总结]]></title>
      <url>%2F2016%2F11%2F01%2Foracle%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[总结 基本查询：select 别名，distinct去重，nvl处理空值，||连接符 条件查询：where &gt;=,&lt;=,=,&lt;&gt; 范围查询：between and,in,is not null,is null 模糊查询：like ‘%’; 排序查询：order by 函数 单行函数 字符函数：upper（），lower（），length（），replace（） 数值函数：round（），trunc（），mod（） 日期函数：sysdate，add_months() 转换函数:to_char()，to_date(),to_number() 通用函数:nvl() 多行函数 count\sum\avg\max\min 分组查询：group by：在分组统计时候，在select 出现的普通字段，在group by 中必须出现，在group by中出现的普通字段，在select 中可以不出现过滤：having： where条件在分组之前的查询条件，having在分组后得到结果对结果进一步筛选多表关联查询 笛卡儿积：通过查询的结果，发现员工表中每条记录，都跟部门表的每条数据进行连接查询。得到结果就是一个笛卡尔积。在笛卡尔积的基础上，进一步设置关联条件（子表的外键字段=主表的主键字段），就得到内连接。 内连接 where tab1.字段 = tab2.字段 外连接 left join ，right join， where tab1.字段 = tab2.字段(+) DDL语句 创建表空间–代表项目的开始,只有dba权限的角色才有权限创建表空间create tablespace 表空间名 datafile &#39;文件路径&#39; size 100m autoextend on next 10m; 创建用户create user 用户名 identified by 密码 default tablespace 默认表空间; 用户授权（connect ，resource，dba）grant connect,resource to itcast; 创建表create table 表名( 字段名 字段类型, ); truncake表名，直接摧毁表结构后重构表，比delete要快很多，但是没法按照条件删除 约束 0.主键约束 primary key 唯一约束 unique 非空约束 not null 检查约束 check(gender in(1,2)) 外键约束 constraint 外键名 foreign key(字段) references 对应表(对应字段) 对表中列的属性修改 alter table 表名 moddify 列名 alter table 表名 add 列名 alter table 表名 drop column 列名 alter table 表名 rename column 列名 to 新列名 数据的增删改查 select,update,delete,insert 集合操作 并集 union all交集 intersect差集 minus 视图 create view 视图名 as 查询语句 with read ``only:虚表，本身不存在数据，数据来源于原始表 索引 create index 索引名 on 表名(列名):目的是提高检索速度 序列create sequence 序列名;nextval-&gt;currval:类似于MySql的自动增长 exists &amp; not exists 同义词 create synonym 同义词名 for 其他用户.表名; 同义词和视图的区别： 不需要dba权限就可以创建同义词 视图可以隐藏列，同义词不可以去掉列只是整张表的复制 SQL&gt; shutdown和startup]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[oracle第三阶段]]></title>
      <url>%2F2016%2F10%2F30%2Foracle03%2F</url>
      <content type="text"><![CDATA[Oracle 第三阶段PL/SQL存储语言PL/SQL（Prodedure Language/SQL）PLSQL 是Oracle对sql语言的过程化扩展，指在SQL命名语言中增加了过程 PLSQL语言123456[delcare] -- 声明部分（变量，光标，例外）begin[excetion] -- 异常处理end; PLSQL的赋值 定义number变量，定义PI常量，定义记录型变量，定义引用型变量12345678910111213declare i number:=1; --变量赋值 j number; PI constant number :=3.14; --常量赋值 pemp emp%rowtype; --记录型变量赋值 pname emp.ename%type; --引用型变量pname用的ename的数据类型begin j:=2; --变量也可以在这赋值 dbms_output.put_line(i); dbms_output.put_line(j); select * into pemp from emp where empno=7788; --记录型变量引用 select ename into pname from emp where empno=7788; --引用型变量引用end; pemp 记录型变量，只能存储一条记录，用pemp.empno来取值 if分支123456begin if 条件判断 then elsif 条件判断 then else end if;end; 从控制台输入一个数字，如果数字是1，则输出我是1 123456789declare i number :=&amp;num;begin if (i=1) then --括弧可写可不写 dbms_output.put_line(&apos;我是1&apos;); elsif dbms_output.put_line(&apos;我不是1&apos;); end if;end； 如果输入的年龄在18岁以下，输出未成年人，18~40：成年人，40以上 老年人1234567891011declare i number :=&amp;i;begin if i&lt;18 then dbms_output.put_line(&apos;未成年人&apos;); elsif i&lt;40 then dbms_output.put_line(&apos;成年人&apos;); else dbms_output.put_line(&apos;老年人&apos;); end if;end; loop循环 语法1： while 循环条件 loop end loop; 语法2：(常用) loop exit when 退出循环条件； end loop; 语法3: for i in 1..10 loop end loop; 语法1实现在控制台输出1~10 12345678declare i number :=1;begin while i&lt;11 loop dbms_output.put_line(i); i:=i+1; end loop;end; 语法2实现在控制台输出1~10(掌握) 123456789declare i number :=1;begin loop exit when i &gt;10; dbms_output.put_line(i); i:=i+1; end loop;end; 语法3实现在控制台输出1~10 1234567declarebegin for i in 1..10 loop dbms_output.put_line(i); end loop;end; 光标（游标） 光标：就是在ＰＬ/SQL编程中结果集的概念 语法：cursor 光标名称 is select查询语句; 提取游标： 123456 open 游标名称; loop fetch 游标名称 into 变量; exit when 游标%notfound; end loop; close 游标名称; 使用光标输出emp表中7369的员工信息 123456789declare cursor emp_cur is select * from emp where empno=7369; pemp emp%rowtype;begin open emp_cur; fetch emp_cur into pemp; dbms_output.put_line(pemp.ename); close emp_cur;end; 输出指定部门的员工信息 123456789101112declare cursor emp_cur(dno number) is select * from emp where deptno=dno; pemp emp%rowtype;begin open emp_cur(20); loop fetch emp_cur into pemp; exit when emp_cur%notfound; dbms_output.put_line(pemp.ename); end loop; close emp_cur;end; 给部门编号为10 的员工涨工资 12345678910111213declare cursor emp_cur(dno number) is select * from emp where deptno=dno; pemp emp%rowtype;begin open emp_cur(10); loop fetch emp_cur into pemp; exit when emp_cur%notfound; update emp set sal=sal+1000 where empno=pemp.empno; dbms_output.put_line(pemp.ename); end loop; close emp_cur;end; 例外（异常） 系统异常，被0除的zero_divide异常 12345678declare i number :=1;begin i:=i/0;exception when zero_divide then dbms_output.put_line(&apos;不能除0&apos;); end; 系统异常，设置错误的value_error异常 12345678declare i number :=1;begin i:=&apos;hello&apos;;exception when value_error then dbms_output.put_line(&apos;赋值错误&apos;); end; 系统异常，都可以通过others异常捕获 12345678910declare i number :=1;begin i:=1/0;exception when value_error then dbms_output.put_line(&apos;赋值错误&apos;); when others then dbms_output.put_line(&apos;有错误&apos;); end; 自定义异常，查询部门编号为50员工（自定义exception） 1234567891011121314declare cursor emp_cur is select * from emp where deptno =20; pemp emp%rowtype; no_date exception;begin open emp_cur; fetch emp_cur into pemp; if emp_cur%notfound then raise no_date; end if; exception when no_date then dbms_output.put_line(&apos;没有查询到数据！&apos;); end; 存储过程 定义：将提前编译好的一段plsql,存放在数据库端，供其他程序员调用 语法：123456 create [or replace] procedure 过程名称（参数1 in|out 类型） as|is --声明一些变量(declare中的东西) begin end; 声明pro_add_sal存储过程,作用是给指定员工涨100工资,并打印出涨前和涨后工资123456789create or replace procedure pro_add_sal(eno in number)as psal number;begin select sal into psal from emp where empno=eno; dbms_output.put_line(&apos;涨前工资&apos;||psal); update emp set sal = sal + 100 where empno=eno; dbms_output.put_line(&apos;涨后工资&apos;||(psal+100));end; 存储过程中没有错误提示，要想看是否运行正确，就在左侧中看是否有procedure中是否有叉 调用存储过程 123begin; pro_add_sal(7788);end; 创建一个存储过程pro_emplist（输出参数为游标类型） 输入一个部门编号，将此部门下的所有员工信息输出（游标变量为sys_refcursor)） 12345create or replace procedure pro_emplist(dno number,emplist out sys_refcursor)asbegin open emplist for select * from emp where deptno=dno;end; 调用: 123456789101112declare emplist sys_refcursor; pemp emp%rowtype;begin pro_emplist(10,emplist); loop fetch emplist into pemp; exit when emplist%notfound; dbms_output.put_line(pemp.empno || pemp.ename); end loop; close emplist;end; 存储函数 语法：12345678 //参数中in代表从输入参数，out表示输出参数 create or replace function 函数名（参数1 in|out 类型，参数2 in|out 类型） retrun 结果类型 as|is --定义变量 begin return 变量;--(变量的类型一定是跟 return的结果类型保持一致) end; 声明fun_emp_totalsal存储函数,查询指定员工的年薪 声明 1234567create or replace function fun_emp_totalsal(eno number) return numberas psal number;begin select sal*12+nvl(comm,0) into psal from emp where empno=eno; return psal;end; 调用 123456declare totalSal number;begin totalSal:= fun_emp_totalsal(7788); dbms_output.put_line(totalSal);end; 声明pro_emp_totalsal存储过程,查询指定员工的年薪 声明 12345create or replace function pro_emp_totalsal(eno number,totalSal out number)asbegin select sal*12+nvl(comm,0) into totalSal from emp where empno=eno;end; 调用 123456declare total number;begin pro_emp_totalsal(7788,total); dbms_output.put_line(total);end; 声明fun_emp_dname存储函数,根据部门编号查询出部门名称 声明 1234567create or replace function fun_emp_dname(dno number) return dept.dname%typeas pname dept.dname%type;begin select dname into pname from dept where deptno=dno; return pname;end; 调用 123456declare pname dept.dname%type;begin pname :=fun_emp_dname(10); dbms_output.put_line(pname);end; 在select 调用存储函数select empno,ename,fun_emp_dname(deptno) from emp; 存储过程跟存储函数的区别 区别： 语法不一样 存储函数必须有返回值 存储过程虽然没有返回值，但是可以指定输出参数类型 存储函数可以在select 中使用 java程序调用存储过程 导入Oracle10g驱动包 ojdbc14-10.2.0.1.0.jar 通过sql数据库123456789@Test public void test01() throws Exception&#123; cs=conn.prepareCall(&quot;select * from emp&quot;); rs=cs.executeQuery(); while(rs.next())&#123; //两种方式 System.out.println(rs.getObject(1)+&quot;、&quot;+rs.getString(&quot;ename&quot;)); &#125; &#125; junit测试框架中有一个注解@before,意思就是在每次执行Junit的时候先执行这个Before， 当然还有一个After注解，在最后执行 所以可以加一个注解来初始化参数加一个销毁来关闭连接123456789101112131415161718192021222324252627private CallableStatement cs;private Connection conn ;private ResultSet rs;@Before public void init() throws Exception&#123; String driver=&quot;oracle.jdbc.driver.OracleDriver&quot;; String url=&quot;jdbc:oracle:thin:@192.168.241.130:1521:orcl&quot;; String user=&quot;scott&quot;; String password=&quot;tiger&quot;; Class.forName(driver); //获取连接对象 conn = DriverManager.getConnection(url,user,password); &#125;@Afterpublic void destory() throws Exception&#123; if(rs!=null)&#123; rs.close(); &#125; if (cs != null)&#123; cs.close(); &#125; if (conn != null)&#123; conn.close(); &#125;&#125; 调用存储过程，没有结果集 12345678910//call pro_add_sal(eno number) @Test /** * 调用存储过程，没有结果集 */ public void test02() throws Exception&#123; cs=conn.prepareCall(&quot;&#123;call pro_add_sal(?)&#125;&quot;); cs.setInt(1, 7369); cs.executeQuery(); &#125; 调用存储过程，有结果 1234567891011121314//call pro_emp_totalsal(eno number,total out number)@Test /** * 调用有返回值的存储过程 * @throws SQLException */ public void test03() throws SQLException&#123; cs=conn.prepareCall(&quot;&#123;call pro_emp_totalsal(?,?)&#125;&quot;); cs.setInt(1, 7788); // 注册一个输出参数 cs.registerOutParameter(2, OracleTypes.NUMBER); cs.executeQuery(); System.out.println(cs.getObject(2)); &#125; 调用存储过程，有结果值cursor类型 1234567891011121314151617//pro_emplist(dno number,emplist out sys_refcursor)@Test /** * 调用存储过程，有结果值cursor类型 */ public void test04() throws Exception&#123; cs=conn.prepareCall(&quot;&#123;call pro_emplist(?,?)&#125;&quot;); cs.setInt(1, 20); cs.registerOutParameter(2, OracleTypes.CURSOR); //因为是cursor类型的所以需要强转一下CallableStatement为OracleCallableStatement //不强转的话没有取出cursor的方法 cs.executeQuery(); rs=((OracleCallableStatement)cs).getCursor(2); while(rs.next())&#123; System.out.println(rs.getObject(1)+&quot;-----&quot;+rs.getObject(2)); &#125; &#125; 触发器 触发器：验证数据是否合法，满足条件既触发 语法：12345678create or replace trigger 触发器名称after|beforeinsert|update|deleteon 表for each row ---:new :old就是 插入，修改，删除 后的新旧值存在里面 ---: 需要时写这句话,只要有:new :old 就要写这句话beginend; 添加一个员工后打印一句话“一个新员工添加成功” 12345678910create or replace trigger emp_insert_afterafterinserton empbegin dbms_output.put_line(&apos;一个新员工添加成功&apos;);end;insert into emp (empno,ename) values (8888,&apos;陈老师&apos;);select * from emp; 不能在休息时间办理入职 raise_application_error(参数1，参数2);参数1：错误代码 在 -20001~ -20999‘参数2：提示错误信息123456789101112131415create or replace trigger emp_insert_beforebeforeinserton empdeclare dayStr varchar2(50);begin select to_char(sysdate,&apos;day&apos;) into dayStr from dual; if trim(dayStr) = &apos;friday &apos; then raise_application_error(-20001,&apos;休息时间,工资三薪,我需要加薪&apos;); end if;end;insert into emp (ename) values (&apos;阿娇1&apos;);commit; 不能给员工降薪 在使用:old :new 时候就得加上for each row (行级触发器)123456789101112create or replace trigger emp_before_updatebeforeupdateon empfor each rowbegin if :old.sal &gt; :new.sal then raise_application_error(-20002,&apos;不能降薪！！！&apos;); end if;end;update emp set sal = sal -1000; 触发器应用（通过序列在插入数据的时候，将ID用序列赋值） 12345678910111213141516create sequence emp_seq;select emp_seq.nextval from dual;create or replace trigger emp_insert_before_idbeforeinserton empfor each rowbegin select emp_seq.nextval into :new.empno from dual;end;insert into emp (ename) values (&apos;阿娇1&apos;);commit;select * from emp;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[oracle第二阶段]]></title>
      <url>%2F2016%2F10%2F24%2Foracle02%2F</url>
      <content type="text"><![CDATA[Oracle 第二阶段查询子查询 1.查询比雇员7654工资高，同时从事和7788的工作一样的员工select ename,job,sal from emp where sal&gt;(select sal from emp where empno=7654) and job=(select job from emp where empno=7788) 2.查询每个部门最低工资及最低工资的部门名称和雇员名称select d.deptno,dname,empno,ename,sal from (select deptno,min(sal) minsal from emp group by deptno) mindept,emp e,dept d where mindept.deptno=e.deptno and mindept.deptno=d.deptno and mindept.minsal=e.sal 3.找到员工表中薪水大于本部门平均工资的所有员工select ename,sal from (select deptno,avg(sal) avgsal from emp group by deptno) s,emp where s.deptno=emp.deptno and emp.sal&gt;s.avgsal 5.统计每年入职的员工个数select to_char(hiredate,&#39;yyyy&#39;),count(*) from emp group by to_char(hiredate,&#39;yyyy&#39;) 行列转换：本来是这样的：要变成这样： 1234567select sum(e.hcount),sum(decode(e.hdate,&apos;1980&apos;,e.hcount)) &quot;1980&quot;,sum(decode(e.hdate,&apos;1981&apos;,e.hcount)) &quot;1981&quot;,sum(decode(e.hdate,&apos;1982&apos;,e.hcount)) &quot;1982&quot;,sum(decode(e.hdate,&apos;1987&apos;,e.hcount)) &quot;1987&quot;from (select to_char(hiredate,&apos;yyyy&apos;) hdate,count(*) hcount from emp group by to_char(hiredate,&apos;yyyy&apos;)) e 因为转换之后因为,前面有查询总和已经用了一个聚合函数sum用到了group by的元素，所以后边不能跟普通的字段，必须转成聚合函数，所以加一个sum加avg等其他的聚合函数也行 分页查询 0.找到员工表中工资最高的前三名select rownum ,s.* from (select * from emp order by sal ) s where rownum &lt;= 3 有一个虚列叫做rownum，每一个表都有一个虚列，虚表都是按顺序排序从1开始，排序可以让表排序后的表作为一个新表然后再取前几个 1.查询员工表，将员工工资进行降序查询，并进行分页取出第一页，一页三条记录select rownum ,s.* from (select * from emp order by sal ) s where rownum &lt;= 3 查询员工表，将员工工资进行降序查询，并进行分页取出第二页，一页三条记录 rownum是只能查询出小于它的大的不能查询出来，rownum&gt;3,就不行了所以用到了嵌套，让rownum成为一个真实的列 select * from (select * from rownum r,e.* from (select * from emp order by sal desc) e) e1 where e1.r&gt;3 and e1.r&lt;6 所以可以提取一个分页公式 12select * from (select * from rownum r,e.* from (select * from 表 order by sal desc) e) e1 where e1.r&gt;pagesize*(pageno-1) and e1.r&lt;pagesize*(pageno); 集合运算（了解） 1.查询工资大于1200并且job是SALESMAN(intersect)交集select * from emp where sal&gt;1200 intersect select * from emp where job=&#39;SALESMAN&#39; 2.查询工资大于1200或者job是SALESMAN(union)并集select * from emp where sal&gt;1200 union select * from emp where job=&#39;SALESMAN&#39; 3.求工资大约1200和job是SALESMAN的差集(minus)差集select * from emp where sal&gt;1200 minus select * from emp where job=&#39;SALESMAN&#39; DDL(Data Definition Language)语句管理表/create tablespace 表空间名称datafile 数据文件路径size 100mautoextend onnext 10m; / 确定当前用户有dba权限 1.创建itcast001表空间create tablespace itcase001 datafile &#39;c:/itcast.dbf&#39; size 100m autoextend on next 10m 2.创建itcastuser用户create user zc identified by zc default tablespace itcase001 3.为itcastuser用户赋予dba权限grant dba to zc Oracle数据类型 字符类型char:固定长度类型 varchar2:可变长度类型，可保存1333多个汉字(varchar快被淘汰了) 数值类型number(3):999 3位 number(3,2):9.99 3位保留两位小数 日期类型date:mysql中日月年,oracle中精确到时分秒,相当于MySQL中的datetime timestamp:精确到秒的后9位 大数据类型long:大数据字符类型,2G Clob:存放字符类型,4G Blob:存放二进制类型,4G */ DML创建表 0.创建person表，字段为pid，pname create table person( pid number(10), pname varchar2(50) ) Oracle表中的增删改查 Oracle中的事务需要手动commit提交 Oracle是默认不提交事务的，需要手动提交，不提交的话查也能查到 1.为person表新增一条数据insert into person values(1,&#39;张三&#39;); commit; 2.修改person表中的一条数据update person set pname=&#39;李四&#39; where pid=&#39;1&#39;; commit; 3.删除person表中的一条数据delete from person where pid=1;commit; select * from person fro update;这样可以把表的数据的内容查出来，并且可以修改内容，记得提交事务 修改表列的属性 1.给person表增加sex性别列，类型为number(1)alter table person add sex number(1); 2.修改person表列sex类型为char(1)alter table person modify sex char(1); 修改的时候里面不能有值 3.修改person表sex列为genderalter table person rename column sex to gender; 4.删除person表的gender列alter table person drop column gender; 5.删除person表中所有数据delete from person where 1=1; 6.摧毁person表（truncate table 表名） 直接摧毁表结构后重构表，比delete要很快，但是没法按照条件删除truncate table person; 约束 1.创建person表，pid为主键，pname，gender(主键约束primary key) primary key方式create table person( pid number(10) primary key, pname varchar2(50) ) 这样会自动生成一个主键的名称 constraint 主键名 primary key(字段),方式create table person( pid number(10), pname varchar2(50), constraint pk_pid primary key(pid) ) 会生成一个给出的主键名 2.创建person表，pname非空，gender(非空约束not null)`create table person( pid number(10), pname varchar2(50) not null, constraint pk_pid primary key(pid) )` 3.创建person表，pid，pname是唯一，(唯一约束unique)`create table person(pid number(10), pname varchar2(50) unique, constraint pk_pid primary key(pid) )` 4.创建person表，pid，gender—检查约束check(列名 in (值)) gender只能为1或2`create table person(pid number(10), gender number(1) check(gender in (0,1)), constraint pk_pid primary key(pid) )` 外键约束/constraint fk_order_orderid foreign key(外键) references 对应的表(对应的主键) / 1.创建orders表,字段为order_id(主键),total_pricecreate table orders(order_id number(10) primary key, total_price number(5,2) ) 2.创建order_detail表,字段为detail_id(主键),order_id(外键),item_namecreate table order_detail (detail_id number(10) primary key, order_id number(10), item_name varchar2(50) constraint fk_order_id foreign key(order_id) references orders(order_id) )–3.为orders表和order_detail表插入数据 –4.删除orders表和order_detail表中的数据 – 强制删除drop table orders cascade constraint;– 级联删除create table order_detail ( detail_id number(10) primary key, order_id number(10), item_name varchar2(50) constraint fk_order_id foreign key(order_id) references orders(order_id) on delete cascade) Oracle事务（了解） 设置savepoint 回滚点，再次修改数据后用rollback to 回滚点，回滚数据 12345select * from personupdate person set pname=&apos;zhangsan&apos; where pid=&apos;1&apos;;savepoint p1;update person set pname=&apos;lisi&apos; where pid=&apos;1&apos;;rollback to p1; 不可重复读(Oracle默认Read Committed),幻读(MySQL默认Repeatable Read) 脏读（Read Uncommitted） 情景：A事物读取了B事物修改，但未提交的数据 问题：若B回滚了事物，A就读到了错误数据。 不可重复读（Read Uncommitted） 情景：A事物查询数据，B修改了数据，A又查询数据 问题：A事物前后两次数据不一样 幻读（Repeatable Read） 情景：A事物查询数据，B事物插入数据，A又查询数据 问题：A事物感觉出现了幻觉，多了些数据 串行（Serializable）：这种隔离级别将事物放在一个队列中，每个事物开始之后，别的事物被挂起。同一个时间点只能有一个事物能操作数据库对象。这种隔离级别对于数据的完整性是最高的，但是同时大大降低了系统的可并发性。 管理其他数据库对象exists / not exists select … where exists(查询语句)exists：当查询结果不为null，返回true当查询结果为null，返回false 0.例：查询出所有信息select * from emp where exists (select * from emp where ename=&quot;SMITH&quot;)意思是()里面相当于true所以会显示所有的信息 1.查询出有员工的部门select * from dept where exists (select * from emp where dept.deptno=emp.deptno) 在这里里面的那条语句不能再加一个 from dept ,因为加载的时候要加载外边的那个dept，如果里边加上了就是加载的里边的那个 视图 视图：就是一张虚拟表，本身不存放数据，数据来源于原始表创建create [or replace] view 视图名 as sql查询语句； 1.创建视图create or replace view view_emp as select empno,ename,job,hirdate from scott.emp; 2.查询视图select * from view_emp 3.修改视图中7369的名字为’smith’update view_emp set ename=&#39;smith&#39; where empno=7369 4.删除视图drop view view_emp; 5.创建只读视图（关键字 with read only）create or replace view view_emp as select empno,ename,job,hirdate from scott.emp with read only; 视图就是一个虚表不存数据，修改视图中的数据实际上就是修改表中的数据在当前用户下创建视图，就能够更改视图，但是如果在别的用户下对当前用户的表来创建视图就不能修改删除了，如果想修改就需要真正的DBA权限去赋予权限了 创建视图权限，一般网上找都是说的这句，但光有这句话是不行的grant create view to itcastuser; 授予查询权限grant select any table to itcastuser; 授予权限grant select any dictionary to itcastuser; 序列序列：类似于MySql的自动增长 123456create sequence seq_test start with 5 从5开始，第一次也要用nextvalincrement by 2 每次增长两个maxvalue 20 最大值20cycle 循环，到了20会从1开始循环cache 5 缓存生成5个 1.创建序列create sequence emp_seq; 2.如何查询序列（currval,nextval）第一次的时候必须用nextval因为，第一次还没生成，不能取当前值，序列一旦增长就不能回去了select emp_seq.currval from dual 当前的值 select emp_seq.nextval from dual 下一个值 3.删除序列drop sequence emp_seq 4.为person表插入数据，用序列为id赋值insert into person values (emp_seq.nextval,&#39;11&#39;,1) commit; 序列跟表没有关系，就是一个数，因为Oracle中没有自动增长机制，所以可以用它做自动增长 索引 目的是提高检索速度语法：create index 索引名称 on 表名(列名); 原则： 大数据表才创建索引， 为经常用到的列创建索引， 索引的层数不要超过4层，也就是on 表名(列名1,列名2)这里的列名不要超过4个 多列索引：create index person_index on person(pname，gender) 后面可以加，多几个字段但是这样不好，因为创建索引多了就慢了 创建索引create index person_index on person(pname) -删除索引drop index person;` 创建100万条的数据 12345678910select sys_guid() from dual; --随机生成UDIDdeclare myname varchar2(50);begin for i in 1..1000000 loop select sys_guid() into myname from dual; insert into person values(seq_person.nextval,myname,1); end loop; commit;end; 创建数据之后根据pname查询一条数据会有点慢，用了索引就快了 以后面试的时候记住数据库优化有索引这回事 什么时候创建搜索引？ 同义词（了解） 为表创建别名 同义词和视图的区别：不需要dba权限就可以创建同义词 视图可以隐藏列，同义词不可以去掉列只是整张表的复制 作用：缩短对象的名称方便访问 可以取两个别名，改一个就都变了 创建 create public synonym 同义词名 for 目标表名create public synonym sysno_emp for scott.emp; 删除 drop public synonym 同义词名]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[oracle第一阶段]]></title>
      <url>%2F2016%2F10%2F23%2Foracle01%2F</url>
      <content type="text"><![CDATA[OracleOracle 介绍 Oracle 的安装 因为Oracle很娇气，一旦安装失败很难完全卸载干净，所以最好用虚拟机挂载xp镜像 固定虚拟机的ip地址,先自动获取ip然后查看ip记住，在手动固定一下，防止下次启动虚拟机的时候因为网络配置原因导致Oracle不可用 虚拟机上的网络适配器改为 nat ，意思是能上网，要想局域网共享服务就要设置为桥接模式 拷贝安装包，解压缩，安装oracle，确定右边，口令管理中找到scott，解锁scott用户，默认密码是tigger scott 是Oracle是最老的一批开发者，为了纪念他所以保留了这些用户 如果安装的时候没设置也可以在通过sql语句来解锁alter user scott account unlock; alter user scott identified by tiger; Oracle需要修改两个ip地址的文件：C:\oracle\product\10.2.0\db_1\NETWORK\ADMIN 中的listener跟tnsnames中的ip改为虚拟机的ip 关闭虚拟机的防火墙 现在在虚拟机dos窗口中用 sqlplus 用户名/密码的方式来查看是否能进数据库 远程连接数据库本地安装plsql developer在虚拟机本地安装，PLSQL Developer 不用配置即可直接通过用户名密码登陆 远程连接 安装plsql dev 注意安装目录不能有中文跟空格 解压缩拷贝到本地instantclient_12_1，拷贝上面安装后改的配置文件tnsnames.ora到本地 其实instantclient_12_1才是真正的Oracle客户端，在虚拟机上因为本地安装了Oracle所以就不用再次安了，但是在远程中需要它 登陆plsql 破解一下 直接运行 keygen 即可获得对应得破解信息 第一次登陆plsql时，不要输入账号密码，直接进入，在tools ---&gt; preference 中配置 instantclient_12_1 对应的路劲后应用，确定 配置系统环境变量，名字TNS_ADMIN 路径是tnsnames.ora的所在路径 然后再次重启pplsql输入system账户跟密码就可以进去了 如果在安装的时候解锁了scott用户，就可以用输入scott账号跟密码进去，如果没解锁，可以通过sql语句解锁，上边有 如果不行的话，可以在虚拟机中重启listener跟service服务试试 Oracle的sql语句中文乱码问题 查看服务器编码select userenv(&#39;language&#39;)from dual;我实际查到的结果为:AMERICAN_AMERICA.ZHS16GBK 执行语句 select * from V$NLS_PARAMETERS查看第一行中PARAMETER项中为NLS_LANGUAGE对应的VALUE项中是否和第一步得到的值一样，如果不是，则需要配置环境变量 设置环境变量 新建变量名为NLS_LANG,变量值 ：第一步查到的值，我的是AMERICAN_AMERICA.ZHS16GBK 重新启动plsql，插入数据正常 Oracle安装之后的服务 Oracle 的角色 sql语句 注： sql语句中，单引号可能不行，要双引号 要提示按 F6 dual 虚表，没有任何意义，只是为了补全Oracle查询语法 Orcale中要想访问scrott里的表，需要登录scrott用户或者 system用户中查询表用from scrott.emp Oracle的查询内容区分大小写，关键字不区分 转成日期类型的 to_date(‘1981-1-1’,’yyyy-MM-dd’) 转义 &#39;%/_%&#39; escape &#39;/&#39;,用什么转义用escape SQL优化的原则：尽量使用列名 SQL中的null : 包含null的表达式都为null,null永远!=null null值最大 null值：如果集合中含有null，不能使用not in；但可以使用in between and 1: 含有边界 2. 小值在前 大值在后 order by作用于后面所有的列，desc只作用于离他最近的列select * from emp order by deptno ,sal desc 希望：对于某些不成立的记录，任然希望包含在最后的结果中左外连接：当where e.deptno=d.deptno不成立的时候，等号左边的表任然被包含 写法：where e.deptno=d.deptno(+)右外连接：当where e.deptno=d.deptno不成立的时候，等号右边的表任然被包含 写法：where e.deptno(+)=d.deptno 自连接：通过表的别名，将同一张表视为多张表，自连接不适合操作大表 基本查询 1.查询出所有emp中的信息，并用中文进行字段重命名select * from scott.empselect empno &quot;编号&quot;,ename &quot;姓名&quot;,job &quot;工作&quot; from scott.emp 2.查询emp表中员工的job信息，并去除重复信息select distinct(job) from scott.emp 3.查询emp表中员工的全年的工资总和(sal总和)select sum(sal) from scott.emp 4.查询emp表中员工的全年收入总和(sal+comm的总和)select sum(sal)+sum(comm) from scott.emp 5.查询emp表中员工编号，姓名（输出格式如下：编号:xxx，姓名：xxx） Concat拼接方式,可以多层嵌套select concat(concat(&#39;编号:&#39;,empno),concat(&#39;,姓名:&#39;,ename)) from scott.emp Oracle的||方式,就是java里的+号select &#39;编号：&#39;||empno||&#39;，姓名：&#39;||ename from scott.emp 条件查询 1.查询工资大于1500的员工select ename,sal from scott.emp where sal&gt;1500 2.查询工资大于1500并且有奖金的雇员select ename,sal,comm from scott.emp where sal&gt;1500 and comm is not null 3.查询工资大于1500或者有奖金的雇员select ename,sal,comm from scott.emp where sal&gt;1500 or comm is not null 4.查询工资大于1500并且没有奖金的雇员select ename,sal,comm from scott.emp where sal&gt;1500 and comm is null 5.查询员工姓名为smith的员工,注意大小写select empno,ename from scott.emp where ename=&#39;SMITH&#39; 范围查询 1.查询工资大于1500但小于3000的全部雇员 /&gt;=,&lt;=方式select ename from scott.emp where sal&gt;=1500 and sal&lt;=3000 between and方式select ename from scott.emp where sal between 1500 and 3000 2.查询1981-1-1到1981-12-31号入职的雇员（between and）select ename from scott.emp where hiredate between to_date(&#39;1981-01-01&#39;,&#39;yyyy-MM-dd&#39;) and to_date(&#39;1981-12-31&#39;,&#39;yyyy-MM-dd&#39;); 3.查询员工编号是7369,7654,7566的员工 OR方式select empno,ename from scott.emp where empno=&#39;7369&#39; or empno=&#39;7654&#39; or empno=&#39;7566&#39; IN方式select empno,ename from scott.emp where empno in(7369,7654,7566) 4.查询雇员姓名是’SMITH’,’ALLEN’,’WARD’的雇员信息 (IN方式)select empno,ename from scott.emp where ename in(&#39;SMITH&#39;,&#39;ALLEN&#39;,&#39;WARD&#39;) 模糊查询like 1.查询所有雇员姓名中第二个字符有‘M’的雇员select ename from scott.emp where ename like &#39;_M%&#39; 2.查询名字中带有‘M’的雇员select ename from scott.emp where ename like &#39;%M%&#39; 3.查询雇员编号不是7369的雇员信息 &lt;&gt;方式select ename from scott.emp where empno &lt;&gt; 7369 !=方式select ename from scott.emp where empno != 7369 排序 order bynvl(字段名，0) 如果字段为null把null改为0 排序的时候，让null在最后边 desc nulls last 1.查询雇员的工资进行降序排序select ename,sal from scott.emp order by sal desc 2.查询雇员的奖金并做降序排序（关于nulls first/nulls last）select ename,nvl(comm,0) from scott.emp order by nvl(comm,0) desc 3.查询雇员的工资做降序排列并且其中奖金部分是升序排序select ename,sal,nvl(comm,0) from scott.emp order by sal desc,nvl(comm,0) asc 单行函数伪表，虚表：dual 没有任何的实际意义，只是为了补全Oracle查询语法 字符函数 1.将’smith’转换成大写–关键字:upper select upper(&#39;smith&#39;) from dual 2.将’SMITH’转换成小写–关键字:lower select lower(&#39;SMITH&#39;) from dual 3.将’smith’首字母大写–关键字:initcap select initcap(&#39;smith&#39;) from dual 4.将’helloworld’截取字符串成’hello’ 关键字substr,Orcale 默认是从1开始的，但是0也可以 select substr(&#39;helloworld&#39;,0,5) from dual select substr(&#39;helloworld&#39;,1,5) from dual 5.获取’hello’的字符串长度–关键字length select length(&#39;hello&#39;) from dual 6.将’hello’中的l用x进行替换–关键字replace select replace(&#39;hello&#39;,&#39;l&#39;,&#39;x&#39;) from dual 数值函数 1.将15.66进行四舍五入（从-2到2）–关键字round 123456select round(15.66) from dual //16select round(15.66,-2) from dual //0 小数点左边第二位进select round(15.66,-1) from dual //20 小数点左边第一位进select round(15.66,0) from dual //16select round(15.66,1) from dual //15.7 保留一位小数select round(15.66,2) from dual //15.66 保留两位小数 2.将15.66进行截断（从-2到2）–关键字trunc 123456select trunc(15.66) from dual //15从小数点截取select trunc(15.66,-2) from dual //0select trunc(15.66,-1) from dual //10select trunc(15.66,0) from dual //15select trunc(15.66,1) from dual //15.6select trunc(15.66,2) from dual //15.66 3.对15/3进行求余数–关键字mod select mod(15,3) from dual 日期函数 1.查询系统时间–关键字sysdateselect sysdate from dual 2.查询雇员进入公司的周数select ename,trunc((sysdate-hiredate)/7) as &quot;周&quot; from scott.emp 3.查询雇员进入公司的月数–关键字months_betweenselect round(months_between(sysdate,hiredate)) from scott.emp 4.求出三个月后的日期–关键字add_monthsselect add_months(sysdate,3) from dual 转化函数： 将系统日期显示为yyyy-mm-dd hh:mi:ss. 注意分钟是miselect to_char(sysdate,&#39;yyyy-mm-dd hh:mi:ss&#39;) from dual; 去掉补0,就是有的单位数会前面有个0select to_char(sysdate,&#39;fmyyyy-mm-dd hh:mi:ss&#39;) from dual; 显示成24小时制select to_char(sysdate,&#39;yyyy-mm-dd hh24:mi:ss&#39;) from dual; 显示成年月日select to_char(sysdate,&#39;yyyy&#39;)||&#39;年&#39; from dual； 将字符串1981-1-1转换成日期函数select to_date(&#39;1981-1-1&#39;,&#39;yyyy-mm-dd&#39;) from dual; 通用函数 空值的处理函数，有null置为0 select nvl(comm,0) from scott.emp; nvl2(判断值，非空返回值，空返回值) select nvl2(null,&#39;非空&#39;,&#39;空&#39;) from dual; 条件表达式 1.查询员工的job内容并转成中文显示 decode方式 ：在这里，要区分字段的大小写select ename,decode(job,&#39;CLERK&#39;,&#39;柜员&#39;,&#39;SALESMAN&#39;,&#39;销售&#39;，&#39;其他&#39;) from scott.emp //最后那个其他表示没有写出的，要不会转成null case when then end 方式select ename , case job when &#39;CLERK&#39; then &#39;柜员&#39; when &#39;SALESMAN&#39; then &#39;销售&#39; else &#39;其他&#39; end from scott.emp 多行(聚合)函数 查询的时候最好查哪个在count中放哪个字段，查询所有最好用主键 1.查询所有员工记录数–关键字countselect count(*) from scott.emp 2.查询佣金的总数–（如何查询某个字段的总数量）select sum(sal) from scott.emp 3.查询最低工资–关键字minselect min(sal) from scott.emp 4.查询最高工资–关键字maxselect max(sal) from scott.emp 5.查询平均工资–关键字avgselect avg(sal) from scott.emp 6.查询20号部门的员工工资总和select deptno,sum(sal) from scott.emp group by deptno having deptno=20 分组函数 (group by后边有什莫select后边就必须有什么) 1.查询部门编号及人数–分组查询关键字group byselect deptno,count(*) &quot;人数&quot; from scott.emp group by deptno 2.查询每个部门编号及平均工资select deptno,round(avg(sal)) from scott.emp group by deptno 3.查询部门名称，部门编号，平均工资select dname,s.deptno,round(avg(sal)) from scott.emp s, scott.dept d where s.deptno=d.deptno group by s.deptno,dname 4.查询出部门人数大于5人的部门select deptno,count(*) from scott.emp group by deptno having count(*)&gt;5 5.查询部门编号，部门名称，平均工资且平均工资大于2000select s.deptno,dname,round(avg(sal)) from scott.emp s,scott.dept d where s.deptno=d.deptno group by s.deptno,dname having round(avg(sal))&gt;2000 多表关联查询 查询员工编号,员工姓名,员工部门编号,员工部门名称,员工部门地址,中文显示员工工资等级,及领导编号,领导姓名,领导部门编号,领导部门名称,中文显示领导工资等级（可分为以下几个逻辑） 查询员工编号,员工姓名,领导编号,领导姓名select s1.empno,s1.ename,s2.empno,s2.ename from scott.emp s1,scott.emp s2 where s1.mgr=s2.empno 查询员工编号,员工姓名,员工部门编号,员工部门名称,员工部门地址,领导编号,领导姓名,领导部门编号,领导部门名称 123select s1.empno,s1.ename,s1.deptno,d1.dname,d1.loc,s2.empno,s2.ename,s2.deptno,d2.dname,d2.loc from scott.emp s1,scott.emp s2,scott.dept d1,scott.dept d2 where s1.mgr=s2.empno and s1.deptno=d1.deptno and s2.deptno=d2.deptno 查询员工编号,员工姓名,员工部门编号,员工部门名称,员工部门地址,员工工资等级,领导编号,领导姓名,领导部门编号,领导部门名称,领导工资等级 1234select s1.empno,s1.ename,s1.deptno,d1.dname,d1.loc,g1.grade,s2.empno,s2.ename,s2.deptno,d2.dname,d2.loc,g2.grade from scott.emp s1,scott.emp s2,scott.dept d1,scott.dept d2,scott.salgrade g1,scott.salgrade g2 where s1.mgr=s2.empno and s1.deptno=d1.deptno and s2.deptno=d2.deptno and s1.sal between g1.losal and g1.hisal and s2.sal between g2.losal and g2.hisal 询员工编号,员工姓名,员工部门编号,员工部门名称,员工部门地址,中文显示员工工资等级,领导编号,领导姓名,领导部门编号,领导部门名称,中文显示领导工资等级 1234select s1.empno,s1.ename,s1.deptno,d1.dname,d1.loc,decode(g1.grade,1,&apos;一级&apos;,2,&apos;二级&apos;,3,&apos;三级&apos;,4,&apos;四级&apos;),s2.empno,s2.ename,s2.deptno,d2.dname,d2.loc,decode(g2.grade,1,&apos;一级&apos;,2,&apos;二级&apos;,3,&apos;三级&apos;,4,&apos;四级&apos;)from scott.emp s1,scott.emp s2,scott.dept d1,scott.dept d2,scott.salgrade g1,scott.salgrade g2 where s1.mgr=s2.empno and s1.deptno=d1.deptno and s2.deptno=d2.deptno and s1.sal between g1.losal and g1.hisal and s2.sal between g2.losal and g2.hisal 外连接因为内连接有的时候，查不到没有关联的数据，所以用到了外连接 1.查询员工编号，姓名，领导编号，领导姓名，包括没领导的 left join on方式select s1.empno,s1.ename,s2.empno,s2.ename from scott.emp s1 left join scott.emp s2 on s1.mgr=s2.empno Orcl的(+)方式select s1.empno,s1.ename,s2.empno,s2.ename from scott.emp s1,scott.emp s2 where s1.mgr=s2.empno(+) 2.查询出所有部门信息(包括没员工的部门)及部门下的员工信息 123select d.deptno,dname,loc,empno,ename,sal,comm from scott.dept d left join scott.emp s on d.deptno=s.deptnoselect d.deptno,dname,loc,empno,ename,sal,comm from scott.dept d , scott.emp s where d.deptno=s.deptno(+) 3.案例【1.3】查询学员成绩列表，显示学员姓名，考试分数，如果该学员没有考试记录也要列出姓名，不能用join on成绩表：学生表：课程表： (+)方式 1select s.id,s.name &quot;学生姓名&quot;,tc.name &quot;课程名称&quot;, m.score &quot;考试分数&quot; from T_MARK m,T_STUDENT s ,T_COURSE tc where s.id=m.studentid(+) and m.courseid=tc.id(+) 嵌套方式 1select sid,&quot;学生姓名&quot;,tc.name,&quot;考试分数&quot; from (select s.id sid,s.name &quot;学生姓名&quot;,m.courseid mcourseid, m.score &quot;考试分数&quot; from T_STUDENT s ,T_MARK m where s.id=m.studentid(+)) st,T_COURSE tc where st.mcourseid=tc.id(+) order by sid 多表关联查询的时候，如果逻辑不清楚可以考虑画图]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javaMail]]></title>
      <url>%2F2016%2F10%2F07%2FjavaMail%2F</url>
      <content type="text"><![CDATA[javaMailjavaMail SMTP: Simple Message Transfer Protocal 发送协议 默认端口：25 POP:Post Office Protocal 邮局协议。POP3这个版本用的最多，端口：110 发邮件的过程： 使用代码发邮件 引入依赖 在pom.xml中引入依赖 还有与Spring整合的 具体业务,当新员工入职的时候发送邮件 1234567891011121314151617181920212223242526272829303132333435//1. 设置邮件的一些信息Properties props = new Properties();//发送邮件的服务器地址下面是网易的，qq的就是stmp.qq.com 新浪：stmp.sina.comprops.put(&quot;mail.smtp.host&quot;,&quot;smtp.163.com&quot;);props.put(&quot;mail.smtp.auth&quot;,&quot;true&quot;); //身份认证，一般都会开//2. 创建Session对象Session session = Session.getInstance（props）；//3.创建MimeMessage，邮件的消息对象MimeMessage message = new MimeMessage(session);//4.设置发件人Address fromAddr = new InternetAddress(&quot;zc@163.com&quot;);message.setFrom(fromAddr);//5.设置收件人Address toAddr = new InternetAddress(john@163.com);message.setRecipient(RecipientType.TO,toAddr);//6.设置邮件的主题message.setSubject(&quot;项目进展顺序&quot;);//7.设置邮件的正文message.setText(&quot;项目进展顺序，所有兄弟们都非常努力，老板今天可以请吃饭&quot;);message.saveChanges();//保存更新//8.得到火箭Transport transport = session.getTransport(&quot;smtp&quot;);transport.connect(&quot;smtp.163.com&quot;, &quot;zc@163.com&quot;, &quot;密码&quot;);//设置了火箭的发射地址transport.sendMessage(message, message.getAllRecipients());//发送具体内容及接收人transport.close(); 引入到项目中，入职员工后发送邮件 在数据库增加邮件字段 发送邮件的代码可以封装成一个Utils，在Service完成业务 邮件发送的工作，需要用到网络，比较耗时。并且也是一个独立的任务 所以可以开启一个新线程，来发送 1234567891011Thread th = new Thread(new Runnable()&#123; public void run()&#123; try&#123; MailUtil.sendMsg(entity.getUserinfo().getEmail(),&quot;新员工入职信息&quot;,&quot;欢迎&quot;+entity.getUserinfo().getName()+&quot;加入xxx,您的登录名是&quot;+entity.getUsername()+&quot;密码是：&quot;+entity.getPassword()); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125;);//启动线程th.start(); 因为匿名内部类使用外边的变量要加final。所以在外边的entity上加final 这里的异常要捕获，因为有事务，所以在这的异常要捕获，即使失败了自己处理就行，不会影响员工入职 javaMail与Spring整合 引入pom依赖前面已经引了 创建一个配置文件mail.properties 1234mail.host=smtp.163.commail.username=发送人用户名mail.password=密码mail.from=zc@163.com 创建一个applicationContext-mail配置文件，先加载mail.properties&lt;context:property-placeholder location=&quot;classpath:mail.properties&quot; /&gt; 然后 12345678910111213141516171819&lt;!-- 简单消息对象创建 --&gt;&lt;bean id=&quot;mailMessage&quot; class=&quot;org.springframework.mail.SimpleMailMessage&quot;&gt; &lt;property name=&quot;from&quot; value=&quot;$&#123;mail.from&#125;&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 2.创建发送器 --&gt; &lt;bean id=&quot;mailSender&quot; class=&quot;org.springframework.mail.javamail.JavaMailSenderImpl&quot;&gt; &lt;property name=&quot;host&quot; value=&quot;$&#123;mail.host&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;mail.username&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;mail.password&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;&gt;&lt;/property&gt; &lt;property name=&quot;javaMailProperties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;mail.smtp.auth&quot;&gt;true&lt;/prop&gt; &lt;prop key=&quot;mail.debug&quot;&gt;true&lt;/prop&gt; &lt;prop key=&quot;mail.smtp.timeout&quot;&gt;0&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 测试一下12345678910111213@Testpublic void testJavaMail() throws Exception&#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;classpath:spring/applicationContext-mail.xml&quot;); //得到了简单邮件的消息对象 SimpleMailMessage smm = (SimpleMailMessage) ac.getBean(&quot;mailMessage&quot;); smm.setTo(&quot;113@qq.com&quot;); smm.setSubject(&quot;今天晚上约你&quot;); smm.setText(&quot;本人是一个18岁的小姑娘，相约回龙观东大街&quot;); //得到发送器 JavaMailSender mailSender = (JavaMailSender) ac.getBean(&quot;mailSender&quot;); //发送 mailSender.send(smm);&#125; 整合进ssh，在ServiceImpl中把mailMessage跟mailSender注入 1234567891011121314//使用spring与javaMail实现新员工入职时邮件的发送Thread th = new Thread(new Runnable() &#123; public void run() &#123; try &#123; mailMessage.setTo(entity.getUserinfo().getEmail()); mailMessage.setSubject(&quot;新员工入职信息&quot;); mailMessage.setText(&quot;欢迎&quot;+entity.getUserinfo().getName()+&quot;加入传智播客集团，您在公司的账号：&quot;+entity.getUserName()+&quot;,密码：&quot;+SysConstant.DEFAULT_PASS); mailSender.send(mailMessage);//发送邮件 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;);th.start(); SMTP协议（发送邮件的时候控制台中输出）： 334 DXNLtYTE0 http协议中请输入用户名 334 UGFzc3dvcmQ6 http协议中请输入密码 发送复杂的内容发送邮件的时候可能会有图片跟附加文件：当然首先要引入依赖跟配置配置文件 1234567891011121314151617181920212223242526272829@Testpublic void testJavaMail() throws Exception&#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;classpath:spring/applicationContext-mail.xml&quot;); //得到发送器 JavaMailSender mailSender = (JavaMailSender) ac.getBean(&quot;mailSender&quot;); //得到一个MimeMessage对象 MimeMessage message = mailSender.createMimeMessage(); //产生出一个MimeMessageHelper helper MimeMessageHelper helper = new MimeMessageHelper(message, true);//工具类本质是操作message消息 true代表可以带附件，图片 //3.使用helper工具类，设置邮件的发送者，接收者，主题，正文 helper.setFrom(&quot;itheima14@163.com&quot;); helper.setTo(&quot;3462420264@qq.com&quot;); helper.setSubject(&quot;发送图片和附件&quot;); helper.setText(&quot;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;hello!!spring image html mail&lt;/h1&gt;&lt;a href=http://www.baidu.com&gt;baidu&lt;/a&gt;&lt;br/&gt;&lt;img src=&apos;cid:image&apos; /&gt;&lt;/body&gt;&lt;/html&gt;&quot;, true); //指定cid的取值 FileSystemResource imgResource = new FileSystemResource(new File(&quot;E:/图片路劲.png&quot;)); helper.addInline(&quot;image&quot;, imgResource); //带附件 FileSystemResource fileResource = new FileSystemResource(new File(&quot;E:/附加文件路劲.zip&quot;)); helper.addAttachment(&quot;javamail1_4_4.zip&quot;, fileResource); //发送 mailSender.send(message);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[异常处理框架]]></title>
      <url>%2F2016%2F10%2F05%2F%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%A1%86%E6%9E%B6%2F</url>
      <content type="text"><![CDATA[Struts2中的异常处理框架 因为在Action中默认的就把异常给抛了，所以Struts中都会有异常处理机制的 在Maven中的Exception中新建一个Exception处理类继承Exception 123456789public class SysException extends Exception &#123; private String message; public String getMessage() &#123; return message; &#125; public SysException(String message)&#123; this.message = message; &#125;&#125; 把需要的图片扔到web中 在Struts中配置配置文件,配置全局结果视图的时候，会跳到自己写的错误页面上，可以配置多个跳转的页面，创建多个异常，每个异常跳的都不一样实现不同的结果。 123456789101112&lt;!-- 全局结果视图 --&gt;&lt;global-results&gt; //图片的地址 &lt;result name=&quot;error&quot;&gt;/WEB-INF/pages/error.jsp&lt;/result&gt;&lt;/global-results&gt;&lt;!-- 异常处理框架 --&gt;&lt;global-exception-mappings&gt; //抛出在页面上的异常 &lt;exception-mapping result=&quot;error&quot; exception=&quot;com.zc.bp.exception.SysException&quot;&gt;&lt;/exception-mapping&gt; //如果一个一个配比较繁琐，可以用Exception类 &lt;exception-mapping result=&quot;error&quot; exception=&quot;java.lang.Exception&quot;&gt;&lt;/exception-mapping&gt;&lt;/global-exception-mappings&gt; 注意要想用struts中的东西struts-sysadmin中的包要相同所以，他里面的包继承struts的包。 这样在页面就会显示异常提示跟图片了 也可以自定义中文提示，就是在抛异常的时候在try一下，然后自定义抛出一个异常,new 自定义的异常类12345678910111213public String toview() throws Exception &#123; try &#123; //1.调用业务方法，加载部门对象 Role obj = roleService.get(Role.class, model.getId()); //2.将对象放入值栈中 super.push(obj); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new SysException(&quot;你有病 ，要先选中，再查看！&quot;); &#125; //3.跳页面 return &quot;toview&quot;;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[sublime]]></title>
      <url>%2F2016%2F09%2F18%2Fsublime%2F</url>
      <content type="text"><![CDATA[相关插件 Sublime - MarkdownEditing Sublime - MarkdownPreview [Chrome - Markdown Here] 自己实现一个Markdown文件转换器Sublime 插件使用和安装确认是否安装了Package Control通过快捷键：Ctrl + Shift +p 打开命令面板(Command Palate) 装 Package Control 打开Package Control 切换到Installiation 根据相应的Sublime 版本复制相应的代码 然后通过Ctrl +一个反引号 打开Sublime的控制面板，然后将上面的代码粘到Console面板上回车安装(注意需要联网) 基本使用Sublime 所有的插件都托管在Pageage Control网站上 Install:安装包 安装的时候需要联网，可能会被墙 List： 显示所有已安装的本地插件包 Remove： 删除指定的插件包 轻量级编辑器推荐 Sublime Microsoft: Visual Studio Code Electron: HTML +CSS+JavaScript +Node.js 使用Web技术构建跨平台的Desktop App Github： Atom 插件推荐网站：awesome 里边有markdown转换为ppt的插件，还有不少别的插件]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SVN]]></title>
      <url>%2F2016%2F09%2F14%2FSVN%2F</url>
      <content type="text"><![CDATA[SVNSVN的概述SVN 的概述 SVN简称Subversion的简称，是一个开放源码的版本控制系统，相较于RCS、CVS，它采用了分支管理系统，它的设计目标就是取代CVS。互联网上很多版本控制服务已从CVS迁移到Subversion.说的简单一点SVN就是用于多个人共同开发同一项目，共用资源的目的。 SVN的作用 主流的版本控制VSS ：Visual Source Safe 微软的CVSSVN : Apache的Git : SVN的安装SVN的使用的模式： SVN的使用模式： 复制 –&gt; 修改 –&gt; 合并的方案（主要） 锁定 –&gt; 修改 –&gt; 解锁的方案 SVN的体系 安装VisualSVN 注意端口，默认是443，很有可能被虚拟机占用，可以改为 8443(我用的8443),可以在命令行查看端口号 netstat -ano 可以命令行里输入 services.msc 查看服务是否启动。 创建仓库，创建工程SVN的基本的使用安装客户端软件安装 TortoiseSVN SVN的权限管理 在Users上创建用户 右键Create User，输入用户名跟密码 在Groups创建组，直接给用户名创建权限不太方便 右键Create Group，输入用户名跟描述 给组里添加用户 选中组，右键Edit —&gt; Add. 给仓库去设置权限 仓库右键 Properties 设置权限 在仓库中创建一个工程，内容一般放在trunk中，branches里放的是分支。 使用 不同的步骤文件对应的图标会变 创建两个文件夹（A，B），分别作为要测试的仓库 右键 CheckOut 输入用户名密码，完成跟服务器同步 若失败，想重新弄一下，需要 右键 ---&gt; setting --&gt; clear Data 清理一下缓存 在A的一端可以创建一个文件，然后 右键 ---&gt; TortoiseSVN ---&gt; Add 现在只是添加到SVN的管理(文件图标有一个小加号) 提交到SVN的服务器 右键 ---&gt; SVN Commit... (现在跟服务器上的代码是同步的文件图标有一个小对勾) B中要想在同步服务器中的东西，直接 右键 ---&gt;update 即可 在B的一段修改代码，文件会变成小叹号，表示与服务器端的不一样 在A的一端，要先更新，右键 ---&gt;update ，写完了再提交 也可以恢复历史版本， 右键 ---&gt; TortoiseSVN ---&gt; Update to Revision... 点 show log 恢复到指定的版本 解决冲突 当两个人共同操作的时候，一个人已经提交了，另外一个人的就不是最新的版本了，他在提交的时候就不是最新的了，就会出现冲突 解决：出现冲突后，删掉没用的文件，把叹号里的东西没用的都删除，在提交即可 还有一种方法，修改后，右键 —&gt; Resolve…(来标记冲突已经解决) SVN的 Eclipse 的插件安装 低版本的跟MyEclipse：site中的两个文件夹拉出来放到一个叫做SVN文件夹中，然后扔到Eclipse里 现在使用的Eclipse中安装： Help ---&gt; Install new SoftWare ---&gt; add ---&gt; Archive ---&gt; SVN插件的地址 如果没有联网的话，把下边最后一个对勾去掉，否则不会成功 检查是否安装：右上角点开看是否有SCV资源库研究 或 右键项目 Team —&gt; Share Project 有SVN则成功了 使用 发布一个项目 在Eclipse中的SVN模块中，新建一个资源库的位置，路径为SVN服务器上要发布的地址， 项目 右键 —&gt; share Project —&gt; svn —&gt;选择已有的项目 再在项目，右键 —&gt; teap —&gt;提交 下载，检出 在Eclipse中的SVN模块中，新建一个资源库的位置，路径为SVN服务器上要下载的地址。 则在这个路径底下就会有那个项目，在右键 —&gt; 检出为… —&gt; 输入项目名（注意不要重复） 使用 先更新，右键 —&gt; team —&gt; 更新 ， 在改代码 在提交，右键 —&gt; team —&gt; 提交 删除项目 因为项目已经被SVN管理，所以不要直接删除，要右键—&gt;断开连接，再删除 可以选择是否删除隐藏的 .snv 文件 小组协作12345678910其中一个人在自己的计算机上搭建一个 SVN 服务器（使用 VisualSVN搭建）然后给其它小组成员创建账号然后创建项目，给小组成员账号分配权限小组成员通过 TortoiseSVN 客户端 操作远程仓库注意：小组成员在 checkout 远程仓库地址的时候，SVN 服务器管理员要把仓库的地址告诉小组成员https://SVN服务器ip地址/svn/JD/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring第四阶段]]></title>
      <url>%2F2016%2F07%2F13%2FSpring%E7%AC%AC%E5%9B%9B%E9%98%B6%E6%AE%B5%2F</url>
      <content type="text"><![CDATA[Spring案例：CRM的保存案例(SSH完成)SSH 整合方式一：零障碍整合意思就是没有注解用所有的配置文件，最原始的那种写法 SSH基本回顾第一步：创建项目，引入jar包 33个 Struts2 中基本的开发包：struts-blanks中找 13个 struts2中的依赖包(看需求)：sturts/lib/ 例：spring :Struts2整合Spring convention :注解 json :整合AJAX的开发包 Hibernate5 基本： lib/required 里面的所有9个 还需要 日志记录 log4j 跟数据库驱动 connector 有可能用的到数据库的连接池： C3P0 （3个）：5的版本，3的版本的时候只需要一个C3P0即可 Spring 基本： IOC基本 6个，四个核心包，两个日志 AOP基本 4个，两个核心包，两个依赖 事务管理 ：tx JDBC :jdbc跟数据库驱动connector 整合web ：web 整合单元测试 ：test 整合其他框架（Hibernate反正在这）: orm Struts跟Hibernate同时包含了这个，删除一个低版本的 引入配置文件 Struts2 web.xml struts.xml Hibernate5 hibernate.cfg.xml 映射文件 Spring applicationContext.xml log4j.properties web.xml 核心监听器ContextLoaderListener 具体实现 创建包结构 引入相关的页面 修改页面的路径 Struts2 和Spring的整合 Action类由Struts2的自身创建 引入一个Struts2中的lib包中的spring包 在jar包中有一个配置文件：struts-plugins.xml 在struts核心包中的default.properties，有下面这个常量： Struts中的是默认将这个常量注释的，在插件包中将其开启，这个常量的开启会引发下面一系列常量的开启 开启后只需要在action中加一个Service的变量跟set方法，即可直接使用Service，配置文件中只要有名字跟他对上了即可使用 Action类交给Spring管理（建议使用） 在Spring中创建一个Action的实例， 因为Struts配置文件中已经有了action的实例，所以需要把Struts中的class改为spring中实例的id 注意：Actioin是多例的，所以要在Spring中的action实例中加一个scope=prototyte Service的属性需要在Spring中手动注入 建议使用交给Spring，因为Spring中有AOP，可以方便增强 Spring整合Hibernate 编写Dao，配置Dao 创建数据库和实体类，配置文件 因为隔离级别跟绑定当前线程都交给Spring管了，所以在这里就把配置文件中的删掉。 在Spring中引入Hibernate的信息 在Spring的配置文件中构建一个SessionFactory（注意版本5）,并注入configLoaction属性 定义Hibernate模板，并注入到Dao中去然后在Dao中写模板的变量跟set方法即可。 因为写一个Dao就得注入一次，特麻烦，所以可以让Dao继承HibernateDaoSupport,里面有模板的变量跟set方法 还能更简单：HibernateDaoSupport中有getHibernateTemplate的方法，里面的内容是有模板就能用，没有就创建一个模板，所以只需要在Dao中注入SessionFactory,然后再调用getHibernateTemplate方法即可。 在Spring跟Hibernate的整合上修改数据库时，必须使用事务管理，要不然会抛出read-only异常。 添加事务管理 配置事务管理器 123&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate5.HibernateTransactionManager&quot;&gt; &lt;property name=&quot;sesssionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;&lt;/bean&gt; 开启注解事务 1&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; /&gt; 在业务层添加注解 12@Transactionalpublic class CustomerServiceImpl implements CustomerService&#123;&#125; SSH整合方式二：不带Hibernate配置文件web 项目复制之后过去不能直接用，必须修改项目属性中的 Web Project Settings 在Spring中配置连接池 提供属性文件（数据库连接） 引入外部属性文件&lt;context:property-placeholder location=&quot;classspath:jdbc.properties&quot; /&gt; 配置连接池 123456&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.user&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;&lt;/bean&gt; 构建连接池，构建一个SessionFactory 12345678910111213&lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&gt; &lt;!-- 注入连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!-- 设置Hibernate的属性 --&gt; &lt;property name=&quot;hibernateProperties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/prop&gt; &lt;prop key=&quot;hibernate.show_sql&quot;&gt;true&lt;/prop&gt; &lt;prop key=&quot;hibernate.format_sql&quot;&gt;true&lt;/prop&gt; &lt;prop key=&quot;hibernate.hbm2ddl.auto&quot;&gt;updata&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 设置Hibernate的映射文件 12345&lt;property name=&quot;mappingResources&quot;&gt; &lt;list&gt; &lt;value&gt;com/spring/ssh/...&lt;/value&gt; &lt;/list&gt;&lt;/property&gt; 在加载映射文件的时候还有很多种方式： 具体到包中所有的映射文件 : &lt;property name=&quot;mappingDirectoryLocations&quot;&gt; &lt;array&gt; &lt;value&gt;classpath:cn/itcast/domain&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; 使用通配符的概念加载映射文件 :&lt;property name=&quot;mappingLocations&quot;&gt; &lt;array&gt; &lt;value&gt;classpath:cn/itcast/domain/*.hbm.xml&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; Hibernation 模板的使用 save(Object obj) update(Object obj) delete(Object obj) T get(Class clazz,Serializable id); List/ find(String hql); List/ findByCriteria(DetachedCriteria c); 修改跟删除 查询一个 查询多个HQL: QBC: 延迟加载的解决 延迟加载问题：就是想用Load的时候，因为已经在service使用了事务，所以当延迟加载的时候，到Service的时候就把session关闭了，所以当action中用到查询的东西的时候，没有办法去获得数据了，就会报错 解决办法：用 OpenSessionInViewFilter 过滤器，把session的开启跟关闭放在action中。 12345678 &lt;filter&gt; &lt;filter-name&gt;OpenSessionInViewFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.orm.hibernate5.support.OpenSessionInViewFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;OpenSessionInViewFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/filter-mapping&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring第三阶段]]></title>
      <url>%2F2016%2F07%2F08%2FSpring%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5%2F</url>
      <content type="text"><![CDATA[SpringSpring的AOP的注解AOP注解的入门 创建项目，引入jar包 创建接口跟实现类 将类的创建交给Spring 123&lt;!-- 配置目标类--&gt; &lt;bean id=&quot;customerDao&quot; class=&quot;com.itheima.aop.demo1.CustomerDaoImpl&quot;&gt; &lt;/bean&gt; 编写切面类 开启AOP的注解 &lt;aop:aspectj-autoproxy /&gt; 切面类的注解开发 @Aspect 在方法上加注解 前置增强 @Before(value=&quot;execution(* com.spring...)&quot;) 后置增强,可以添加返回值 @AfterReturning(value=&quot;execution(* com.spring...)&quot;,returning=&quot;obj&quot;) 环绕增 @Around(value=&quot;execution(* com.spring...)&quot;) 异常捕获，可以获得异常信息 @AfterThrowing(value=&quot;execution(* com.spring...)&quot;,throwing=&quot;ex&quot;) 最终增强 @After(value=&quot;execution(* com.spring...)&quot;) 可以把切入点注解提取出来，在最后加一个没有内容的方法，然后上面注解加这个，然后，上面的每一个方法上需要切入哪，只需要在value中加一个 类名.方法名 即可。 12@Pointcut(value=&quot;execution(* com.spring...)&quot;)private void pointCut01()&#123;&#125; Spring的JDBCSpring 的JDBC的模板Spring是EE开发的一站式框架，一站式框架就有每层的解决方案（包括持久层）。 Spring的JDBC模板的入门spring里面了很多对于持久层的解决方案。(JDBC,hibernate均有) 创建项目，引入Spring的需要的jar包，还有Spring核心包中的两个包jdbc,tx 还有连接数据库的包 connection，Spring的版本还需要引入AOP的包 使用JDBC的模板 1234567891011//创建连接池DriverManagerDataSource dataSource = new DriverManagerDataSource();//设置连接数据库的相关的参数dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);dataSource.setUrl(&quot;jdbc:mysql:///数据库&quot;);dataSource.setUsername(&quot; &quot;);dataSource.setPassword(&quot; &quot;);JdbcTemplate jdbctemplate = new JdbcTemplate();JdbcTemplate.setDataSource(dataSource);jdbctemplate.update(&quot;sql语句&quot;,null,&quot;name&quot;,&quot;password&quot;); 这种方法是不好的，因为每次使用的时候还需要创建连接池，所以把连接池交给Spring管理 把连接池交给Spring管理 创建xml配置文件，引入beans的约束 配置内置连接池 123456&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;&quot; /&gt;&lt;/bean&gt; 把JDBC的模板交给Spring管理 1234&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;jdbcTemplate的路劲&quot; &gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;&lt;/bean&gt;//这里的name必须为dataSource,因为用的是JDBC的模板 测试类： 用JUnit跟Springde整合1234567891011@RunWith(SpringJUnit4ClassRunner.class)@contextConfiguration(&quot;classpath:applicationContext.xml&quot;)public class JdbcTemplateDemo2&#123; @Resource(name=&quot;jdbcTemplate&quot;) private JdbcTemplate jdbcTemplate; @Test public void demo01()&#123; jdbcTemplate.update(&quot;insert into account values (?,?)&quot;，&quot;张三&quot;，100d),; &#125;&#125; 引入外界连接池dpcp连接池 导包：依赖包中apache的commons中的dpcp跟pool，用之前的也行，跟这个一样 配置DBCP连接池 1234567//配置DBCP的连接池&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql,jdbc.Driver&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///数据库&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;&quot; /&gt;&lt;/bean&gt; 测试跟默认的一样 c3p0的连接池 导包,依赖包中c3p0的包 配置连接池,注意：配置属性跟之前的不一样 123456&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql,jdbc.Driver&quot; /&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql:///数据库&quot; /&gt; &lt;property name=&quot;user&quot; value=&quot;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;&quot; /&gt;&lt;/bean&gt; 提取属性文件(连接数据库的信息) 即使用配置文件，如果需要把项目交给别人也要改配置文件，所以提取出一个属性文件，改的时候只改属性文件即可 定义属性文件jdbc.properties 在Spring中配置文件引入属性文件： 通过&lt;bean&gt;引入123&lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;location&quot; value=&quot;classpath:jdbc.prorerties&quot;&gt;&lt;/bean&gt; 在配置配置文件: 但不经常用这个，经常用context标签引入12345678&lt;context:property-placeholder location=&quot;classpath:jdbc.prorerties&quot;&gt;&lt;!-- 配置C3P0连接池 --&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot; /&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.user&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;&lt;/bean&gt; JDBC模板进行CURD操作增删改 增删改的方法是通用的： update(sql语句，参数); 查询 单个数 : T queryForObject(String sql,Class/&lt;T/&gt; requiredType,Object… args) 某个对象 ：T queryForObject(String sql,RowMapper/&lt;T/&gt; rowMapper ,Object… args); List集合 ：List/&lt;T/&gt; query(String sql,RowMapper/&lt;T/&gt; rowMapper,Object… args); 查询属性 12//查询id为1的账号的名称String name=jdbcTemplate.queryForObject(sql语句，String.class,Object 参数); 统计个数 1Long count=jdbcTemplate.queryForObject(sql语句，Long.class,Object 参数); 查询某个对象 RowMapper类似于DBUtils中的 ResultSetHandler 12345678910111213Account account=jdbcTemplate.queryForObject(sql语句，new MyRowMapper(),参数);//可以创建一个内部类来实现RowMapper&lt;T&gt;class MyRowMapper implements RowMapper&lt;User&gt;&#123; @override public Account mapRow(ResultSet rs,int rowNum)&#123; Account account = new Account(); account.setId(rs.getInt(&quot;id&quot;)); account.setName(rs.getString(&quot;name&quot;)); account.setMoney(rs.getDouble(&quot;money&quot;)); return account; &#125;&#125; 查询多个对象 12List&lt;Account&gt; account = query(String sql,new MyRowMapper(),Object... args);//当然也需要创建一个RowMapper&lt;T&gt;接口的实现类，跟上边用一个就行 Spring的事务Spring的事务管理事务的回顾 事务的概念： 逻辑上一组操作，组成这组操作的各个逻辑单元，要么一起成功，要么一起失败 事务的特性： 原子性 一致性 隔离性 持久性 如果不考虑隔离性引发安全问题 读问题 脏读 不可重复读 虚读 写问题 丢失更新 解决读问题 设置事务隔离级别 read uncommitted read committed repeatable read serializable Spring的事务管理的API PlatformTransactionManager：平台事务管理器（Spring中真正管理事务的对象） DataSourceTransactionManager ：使用JDBC操作进行事务管理时候使用 HibernateTransactionManager ：使用Hibernate框架进行事务管理时候使用 TransactionDefinition ：事务的定义信息 事务的隔离级别 事务的传播行为 事务是否只读 事务超时信息 TransactionStatus ：事务的状态对象 是否已经完成 是否有保存点 三个对象的关系： Spring通过TransactionDefinition对事务进行定义，使用PlatformTransactionManager根据定义信息进行事务的管理，在事务管理过程中产生一些状态，将状态存入到TransactionStatus中。 事务的传播行为的作用和含义 事务传播行为的作用 事务的传播行为：解决复杂的事务的操作，业务层之间代码的相互调用 propagation 事务传播行为的取值：记标红的那个即可，主要是第一个根据上两幅图做出的解释： Spring的事务管理的方式 编程式事务管理： 手动编写代码实现事务管理 声明式事务管理： 通过配置实现事务管理 xml的配置方式 注解方式 Spring的事务管理实现：搭建事务管理的基本环境用转账的案例，先写出JDBC模板： 编写Dao 12345678910111213141516171819public class AccountDaoImpl implements AccountDao &#123; private JdbcTemplate jdbcTemplate; public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; &#125; @Override public void outMoney(String from, Double money) &#123; jdbcTemplate.update(&quot;update account set money = money - ? where name = ?&quot;, money,from); &#125; @Override public void inMoney(String to, Double money) &#123; jdbcTemplate.update(&quot;update account set money = money + ? where name = ?&quot;, money,to); &#125;&#125; 配置Dao 12345678910111213141516171819&lt;!-- 引入外部属性文件：方式二：通过context标签引入 --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!-- 配置C3P0连接池 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.user&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/bean&gt; &lt;!-- 将JDBC的模板交给Spring管理 --&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置DAO --&gt; &lt;bean id=&quot;accountDao&quot; class=&quot;com.itheima.tx.demo1.AccountDaoImpl&quot;&gt; &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;/&gt; &lt;/bean&gt; 编写Service 1234567891011121314151617181920public class AccountServiceImpl implements AccountService &#123; private AccountDao accountDao; public void setAccountDao(AccountDao accountDao) &#123; this.accountDao = accountDao; &#125; @Override /** * from：转出账号 * to：转入账号 * money：转账金额 */ public void transfer(String from, String to, Double money) &#123; accountDao.outMoney(from, money); accountDao.inMoney(to, money); &#125;&#125; 配置Service 1234&lt;!-- 配置Service --&gt; &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.tx.demo1.AccountServiceImpl&quot;&gt; &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;/&gt; &lt;/bean&gt; 编写测试类 1234567891011@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext2.xml&quot;)public class TransactionDemo1 &#123; @Resource(name=&quot;accountService&quot;) private AccountService accountService; @Test public void demo1()&#123; accountService.transfer(&quot;郝强勇&quot;, &quot;郝如花&quot;, 1000d); &#125;&#125; 编程式事务管理 配置事务管理器: 注：事务管理器的名称必须是transactionManager 1234&lt;!-- 配置事务管理器：Spring真正管理事务的类 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; 配置事务管理模板 123//配置事务管理的模板&lt;bean id=&quot;transactionTemplate&quot; class=&quot;org.springframework.transaction.support.TransactionTemplate&quot;&gt; &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot; /&gt;&lt;/bean&gt; 在业务层注入事务管理的模板 123456&lt;!-- 配置Service --&gt; &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.tx.demo1.AccountServiceImpl&quot;&gt; &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;/&gt; &lt;!-- 事务管理模板的注入 --&gt; &lt;property name=&quot;transactionTemplate&quot; ref=&quot;transactionTemplate&quot;/&gt; &lt;/bean&gt; 改写业务层 123456789101112131415161718192021222324252627282930313233public class AccountServiceImpl implements AccountService &#123; private AccountDao accountDao; public void setAccountDao(AccountDao accountDao) &#123; this.accountDao = accountDao; &#125; // 提供事务管理模板注入: private TransactionTemplate transactionTemplate; public void setTransactionTemplate(TransactionTemplate transactionTemplate) &#123; this.transactionTemplate = transactionTemplate; &#125; @Override /** * from：转出账号 * to：转入账号 * money：转账金额 */ public void transfer(final String from, final String to, final Double money) &#123; transactionTemplate.execute(new TransactionCallbackWithoutResult() &#123; @Override protected void doInTransactionWithoutResult(TransactionStatus status) &#123; accountDao.outMoney(from, money); int d = 1/ 0; accountDao.inMoney(to, money); &#125; &#125;); &#125;&#125; 声明式事务管理(底层用的就是AOP)XML方式 引入Aop的jar包 恢复一下转账的环境 配置事务管理器 1234&lt;!-- 配置事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; 配置事务的增强（规范） 123456789101112131415&lt;!-- 配置事务的增强（规范） --&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;!-- &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;/&gt; --&gt; &lt;tx:method name=&quot;transfer&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt;//propagaion :传播行为isolation :隔离级别read-only :是否为只读rollback-for :发生哪些异常事务会回滚，默认情况下，任何异常都会回滚no-rollback-for :发生哪些异常事务不会回滚 AOP的配置 12345 &lt;!-- AOP的配置--&gt; &lt;aop:config&gt; &lt;aop:pointcut expression=&quot;execution(* com.itheima.tx.demo2.AccountServiceImpl.transfer(..))&quot; id=&quot;pointcut1&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pointcut1&quot;/&gt; &lt;/aop:config&gt; 注解方式 恢复开发环境 配置事务管理器 开启注解事务 1&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; /&gt; 在要加注解的类上加一个@Transactional 要想加属性后边加一个(),按提示写]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring第二阶段]]></title>
      <url>%2F2016%2F07%2F05%2FSpring%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%2F</url>
      <content type="text"><![CDATA[SpringSpring的Bean的管理注解开发xml：结构清晰注解：开发方便(属性注入) Spring的IOC注解基础 引包(Spring-aop的包)，Spring4.x版本需要引，低的版本不用引了，都内置了 引入约束，在spring-framework-4.2.4.RELEASE\docs\spring-framework-reference\html\xsd-configuration.html 中找到context的约束。 要想设置离线提示信息，则要在window中的属性设置一下，约束文件设置context的约束文件 开启组件扫描 &lt;context:component-scan base-package=&quot;包路劲注意不要到类&quot;&gt;&lt;/component&gt; 加注解：在类上加 @Component(&quot;userDao&quot;) 要想用属性，可以在实体类中添加一个私有的属性注解直接加在属性上就行@Value(&quot; &quot;) ，如果有set方法则需要加在set方法上。 Spring的IOC的注解详情 定义Bean的注解： @Component:修饰类，相当于&lt;bean id=&quot;&quot;&gt; Spring 中提供了三个衍生注解： @Controller : 修饰web层类的 @Service : 修饰业务层类的 @Repository : 修饰DAO层类的 属性注入的注解： @Value ：注入普通类型的值 @Autowired ：对象类型的属性注入，但是默认是按类型注入的，不是按名称注入 要想按名称去注入，可以使用@Qulifer(value=””)的注解与@Autowired一起使用 还有一个Resource ：相当于@Qulifer(value=””)的注解与@Autowired一起使用的效果，此注解不是Spring包中的 Bean的作用范围的注解: @Scope(“ “) ：控制Bean的作用范围，默认是单例的，里面的属性跟xml里的一样。 Bean的生命周期的注解：(在要运行的方法上) PostConstruct：初始化注解 PreDestory：销毁注解 Spring的AOP什么是AOP AOP最初是AOP联盟开发出来的，Spring用的人家的。 AOP(Aspect Oriented Programming) ：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 AOP：面向切面编程，是OOP(面向对象编程)扩展和延伸，解决OOP中一些问题而出现。传统方式使用是纵向继承体系，AOP采用叫做横向抽取机制取代传统方式纵向继承机制对程序扩展和延伸 为什莫学习AOP 可以不修改源代码，对程序进行扩展。 主流应用：权限校验，日志记录，事务管理，性能检测。 AOP的底层实现原理（代理机制）Spring底层实现AOP的原理： JDK动态代理 ：对实现了接口的类才可以产生代理 1234567891011121314151617181920212223public class JdkProxy &#123; private UserDao userDao; public JdkProxy(UserDao userDao) &#123; this.userDao = userDao; &#125; public UserDao createProxy()&#123; UserDao proxy = (UserDao)Proxy.newProxyInstance(userDao.getClass().getClassLoader(), userDao.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object obj, Method method, Object[] args) throws Throwable &#123; if(method.getName().equals(&quot;save&quot;))&#123; System.out.println(&quot;权限校验===========&quot;); return method.invoke(userDao, args); &#125; return method.invoke(userDao, args); &#125; &#125;); return proxy; &#125;&#125; Cglib动态代理：对没有实现接口的类产生代理。底层字节码增强，产生子类对象。使用的时候直接把Spring的包引进来就行，因为，他里边已经集合了Cglib的包 1234567891011121314151617181920212223242526272829303132//这里边实现MethodInterceptor的意思是实现回掉函数，下边的intercept就相当于JDK代理中的invoke方法。所以增强方法中的setCallback中传入一个this即可public class CglibProxy implements MethodInterceptor&#123; private ProductDao productDao; public CglibProxy(ProductDao productDao)&#123; this.productDao = productDao; &#125; public ProductDao createProxy()&#123; // 创建Cglib的产生代理核心类： Enhancer enhancer = new Enhancer(); // 设置父类: enhancer.setSuperclass(productDao.getClass()); // 设置回调：类似InvocationHandler enhancer.setCallback(this); // 产生代理： ProductDao proxy = (ProductDao) enhancer.create(); return proxy; &#125; @Override public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; if(method.getName().equals(&quot;save&quot;))&#123; System.out.println(&quot;权限校验=========&quot;); return methodProxy.invokeSuper(proxy, args); &#125; return methodProxy.invokeSuper(proxy, args); &#125;&#125; SpringAOP中的相关的术语 JoinPoint：连接点，可以被拦截(增强)到的点。 Pointcut：切入点，真实被拦截到的点。 Advice： 通知/增强，增强的代码的实现。 权限校验代码/日志记录 的这种代码称为是通知，增强 Introduction：引介，增强的一种。类层面的增强。（一般不用） Target：目标，被增强的类（UserDao） Weaving：织入，将Advice应用到Target的过程。 Proxy：被增强织入以后产生的代理类 Aspect：切面，切面指的是多个切入点和多个通知的组合。 SpringAOP的入门 引入jar包 spring-aop-4.2.4.RESEASE.jar 还有依赖包中aop的联盟的包com.springsource.org.aopalliance 因为Spring用的AOP中aspectj的技术，所以还得引一个他们的依赖包：com.springsource.org.aspectj.weaver 还有一个Spring整合aspectj的包（在lib中）：sprin g-aspects 编写接口跟实现类 创建一个Spring的配置文件，约束引入AOP的部分 12345 &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; 将类配置到Spring中 1234 &lt;bean id=&quot;customerDao&quot; class=&quot;com.aop.demo3.CustomerDaoImpl&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;myAspectXml&quot; class=&quot;&quot; /&gt; 编写一个切类面 12345public class MyAspectXml&#123; public void checkPrivilege()&#123; syso(&quot;权限校验------&quot;); &#125;&#125; 配置切面类 12345678910 //配置Spring的AOP &lt;!-- 配置Spring的AOP --&gt; &lt;aop:config&gt; &lt;!-- 切入点: --&gt; &lt;aop:pointcut expression=&quot;execution(* com.itheima.aop.demo3.CustomerDaoImpl.save(..))&quot; id=&quot;pointcut1&quot;/&gt; &lt;!-- 配置切面 --&gt; &lt;aop:aspect ref=&quot;myAspectXml&quot;&gt; &lt;aop:before method=&quot;checkPrivilege&quot; pointcut-ref=&quot;pointcut1&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; Spring的AOP的切入点的表达式写法 语法：很灵活，随便写 [访问修饰符] 方法的返回值 类名.方法名(参数) 举例: * 表示任意类，任意返回值，任意方法 1234 public void com.aop.demo.CustomerDaoImpl.save(..); //save()跟save(..)效果是一样的 * *.*.demo.*DaoImpl.save(..); * com.aop.demo.CustomerDao+.save(..); // +表示它的实现类 * com.aop.demo..*DaoImpl.save(..); //表示任意包下的 Spring的AOP的通知的类型 前置通知（before） ： 在方法执行之前进行增强，可以获得切入点的信息 获得切入点的信息，传一个joinPoint对象进去123public void before(JoinPoint joinPoint)&#123; syso(前置通知=====joinPoint);&#125; 后置通知(after-returning) ：在方法执行之后进行增强，获取方法的返回值。 获得返回值：在配置文件标签上加一个resulting=&quot;result名字随便起&quot;然后再在增强的类中加一个123public void before(Object result)&#123; syso(后置通知=====result);&#125; 环绕通知(around) ：在方法执行之前跟执行之后进行增强，阻止目标方法的执行 //要想执行原有的目标方法要加一个ProceedingJoinPoint,因为增强的方法不知道是否有返回值所以一般会返回一个Object 123456public Object around(ProceedingJoinPoint joinPoint)&#123; syso(&quot;通知前&quot;); Object obj = joinPoint.proceed(); syso(&quot;通知后&quot;); return obj;&#125; 异常抛出通知(afterThrowing):在方法执行出现异常的时候进行增强，获取异常的信息。异常抛出之后后面的就不执行了，因为是运行时异常 可以获得异常的信息：在标签上加一个属性throwing=&quot;result任意起名&quot;123public void around(Throwable e)&#123; syso(&quot;异常抛出通知---&quot;+e.getMessage());&#125; 最终通知(after)：类似try，catch中的finally。无论方法是否成功都会执行. 引介通知(不关注) 如果一个类实现了接口，则Spring用JDK代理，如果不加接口就默认用Cglib动态代理实现。当然都不能加final，都要产生子类的 Spring与Junit的整合 引入test包spring-test(lib包中)，当然环境下有JUnit 然后再在测试类上加两个注解 12@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) //全名 下边想用哪个类直接注入即可用 12@Resource(name=&quot;customerDao&quot;)private CustomerDao customerDao; 然后下边的Test单元测试中直接用customerDao即可，不用再加载配置文件那么麻烦 注：这里是只有是Spring跟JUnit整合的时候才能用，因为他里面已经做了一些操作，要想在别的地方使用注解的话，就必须要导包加扫描了 扩展XML和注解整合开发 xml：管理类 注解：属性注入 把service跟Dao都在配置文件中实例化了 不要开扫描否则会出错因为扫描会扫描类上的注解文件，但是类上面没有只有属性上有，所以开启&lt;context:annotation-config /&gt;即可， 支持@Resource，@Value,@Autowared等属性上的注解 12@Resource(name=&quot;UserDao&quot;)private UserDao userDao;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring第一阶段]]></title>
      <url>%2F2016%2F07%2F03%2FSpring%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%2F</url>
      <content type="text"><![CDATA[Spring学习路线 Spring 的第一天：Spring 的IOC的入门，Spring整合web项目 Spring的第二天：IOC的注解开发，Spring的AOP的xml开发 Spring的第三天：Spring的Aop的注解开发，Spring的事务管理 ssh 的整合 Spring的概述什么是Spring Spring是一个开源框架，Spring是于2003年兴起的一个轻量级的Java开发框架，由Rod Johnson创建，简单来说，Spring是一个分层的javaEE/EEfull-stack（一站式） 轻量级开源框架 Spring是SE/EE的一站式框架：Spring有EE开发中每一层解决的方案。 EE的三层结构： WEB层：Spring MVC 业务层：Spring的Bean管理，声明式事务 持久层：Spring的JDBC的模板，Spring的ORM模块 Spring的优点： Spring的版本Spring3.X Spring4.X Spring的IOC的入门IOC(Inversion of Control)IOC:控制反转，将对象的创建权反转给Spring。 解决程序的耦合性 Spring的入门 第一步：下载Spring的开发包 官网： spring 下载spring-framework-4.2.4.RELEASE-dist.zip 解压：Spring的开发包 docs libs schema 第二：导包:只需要导红色圈里的那几个就行，还有log4j的一个包，跟一个日志的接口包commons-logging 第三：编写接口跟实现类 123456789public interface UserDao &#123; public void sayHello();&#125;public class UserDaoImpl implements UserDao &#123; @Override public void sayHello() &#123; System.out.println(&quot;Hello Spring Demo1...&quot;); &#125;&#125; 第四：创建一个Spring的核心配置文件： 在src下创建 applicationContext.xml 名字可以变 引入约束 123456789101112//约束在spring-framework-4.2.4.RELEASE\docs\spring-framework-reference\html\xsd-configuration.html&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;.............................&lt;/beans&gt; 编写Spring配置文件 1&lt;bean id=&quot;userDao&quot; class=&quot;路径&quot;&gt;&lt;/bean&gt; 第五：编写测试类//Spring的方式：IOC的底层实现：工厂+反射+配置文件 123456public void demo2()&#123; ApplicationContext addli= new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserDao userDao=(UserDao) appli.getBean(&quot;userDao&quot;);; userDao.sayHello();&#125; DI DI:依赖注入。需要有IOC的环境 IOC和DI的区别： IOC：控制反转：将对象的创建权交给Spring DI:Spring在创建过程中，将类依赖的属性注入进来 123456//现在要配置的类中创建属性,并提供set方法//然后再在配置文件中配置&lt;bean id=&quot;UserDao&quot; class=&quot;UserDao路劲&quot;&gt; //注入属性 &lt;property name=&quot;name&quot; value=&quot;李四&quot;/&gt;&lt;/bean&gt; Spring的工厂类的概述BeanFactory BeanFactory是Spring 早期的工厂类，现在已经不用了 BeanFactory在调用getBean()的时候才会创建类的实例。 ApplicationContext ApplicationContext是Spring目前使用的工厂类 ApplicationContext支持比BeanFactory更加强大的功能(国际化) ApplicationContext在加载Spring的配置文件的时候，就会创建类的实例 在ApplicationContext下有两个实例： ClassPathXmlApplicationContext：加载类路劲下的配置文件 FileSystemXmlAppliocationContext ：加载本地硬盘上的配置文件 Spring的常见的配置&lt;bean id=&quot;&quot; class=&quot;&quot; scope=&quot;&quot; init-method=&quot;方法名&quot; destory-method=&quot;方法名&quot; /&gt; 后边的两个可以省略 Id和name的配置 id:用到了唯一的约束，都不要使用相同名称的值。Id中不能使用特殊字符 name:没有使用唯一的约束，都不要使用相同名称的值。name中可以使用特殊字符。 id跟name中如果有相同的值，运行时会报错。 在Struts1框架中，Action交给Spring管理&lt;bean name=&quot;/login&quot; class=&quot;xxx&quot;&gt; 因为有/所以只能用name。 scope的配置：Bean作用范围 singleton :默认值，单例的，在一个方法中不管创建多少次，都是同一个对象。 prototype ：多例的。 request ：在Web项目中使用，创建一个类，保存到request域中。 session ：在web项目中使用，创建一个类，保存到session中。 globalsession：在web项目中使用，而且Prolet环境，就是例如登陆了百度，就能访问百度云啊贴吧啊什么的。 bean的生命周期的配置(可以省略)初始化方法跟销毁方法都是要在UserDao类中定义的。 init-method=”方法名” ：Bean被创建的时候要去执行的方法 destory-method=”方法名” ：Bean被销毁的时候要去执行的方法 Bean 的创建必须是单例的，而且必须是关闭工厂ClassPathXmlApplicationContext对象.close() 配置不联网提示 windows属性 —&gt; xml catalog —&gt; 约束中的最后一个地址复制过来到key,上面选择本地中的spring-framework-4.2.4.RELEASE\schema\beans\4.2的那个，中间选择key type为Schema location Spring的Bean管理的xml的方式Spring的Bean的创建Spring中提供了三种Bean的实例化的方式： 无参构造的方式 12345678//bean类public class bean&#123; public bean()&#123; syso(&quot;无参构造被调用&quot;); &#125;&#125;//配置文件&lt;bean id=&quot;bean&quot; class=&quot;bean的地址&quot;&gt; 静态工厂实例化的方式 1234567891011121314//bean类public class bean&#123;&#125;//静态工厂类public class beanFactory&#123; public static Bean createBean()&#123; syso(&quot;静态工厂执行了&quot;); return new Bean(); &#125;&#125;//配置文件&lt;bean id=&quot;bean&quot; class=&quot;beanFactory的地址&quot; factory-method=&quot;createBean&quot;&gt; 实例工厂实例化的方式 123456789101112131415//bean类public class bean&#123;&#125;//实例工厂类public class beanFactory&#123; public Bean createBean()&#123; syso(&quot;实例工厂执行了&quot;); return new Bean(); &#125;&#125;//配置文件&lt;bean id=&quot;beanFactory&quot; class=&quot;beanFactory的地址&quot; /&gt;&lt;bean id=&quot;bean&quot; factory-bean=&quot;beanFactory&quot; factory-method=&quot;createBean&quot; /&gt; Bean的属性注入Bean的属性注入 构造方法的方式 set方法的属性注入 接口注入的方式 12345678910public interface Injection&#123; public void setUsername(String username);&#125;class User implements Injection&#123; private String username; public void setUsername(String username)&#123; this.username=username; &#125;&#125; Spring的Bean的属性注入Spring 中只支持前两种: 构造函数： 1234567//配置文件,当然前提是有这个实体类跟有参构造函数&lt;bean id=&quot;car&quot; class=&quot;car的路劲&quot; &gt; &lt;constructor-arg name=&quot;&quot; value=&quot;&quot; /&gt; &lt;constructor-arg name=&quot;&quot; value=&quot;&quot; /&gt;&lt;/bean&gt;//构造注入中的&lt;constructor-args name=&quot;&quot;&gt;name也可以换为index，从0开始表示第一个构造方法中的值是什么 set方法 12345//配置文件,当然前提是有这个实体类跟set方法&lt;bean id=&quot;car2&quot; class=&quot;com.itheima.spring.demo4.Car2&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;宝马/&gt; &lt;property name=&quot;price&quot; value=&quot;800000&quot;/&gt;&lt;/bean&gt; set中如果有对象的话 1234&lt;bean id=&quot;people&quot; class=&quot;people的路劲&quot; &gt; &lt;constructor-arg name=&quot;正常的属性名&quot; value=&quot;正常的属性值&quot; /&gt; &lt;constructor-arg name=&quot;正常的属性名&quot; ref=&quot;前面配置文件的id这里用car&quot; /&gt;&lt;/bean&gt; Spring2.5版本之后提供p名称空间的属性注入 引入p名称空间：xmlns:p=&quot;http://www.springframework.org/schema/p&quot; 完成属性注入： 格式： 普通属性 p:属性名=“属性值” 对象类型的属性 p:属性名-ref=“其他属性的id或name” 12345//普通&lt;bean id=&quot;car&quot; class=&quot;car路劲&quot; p:name=&quot;&quot; p:price=&quot;&quot; /&gt;//对象类型的&lt;bean id=&quot;people&quot; class=&quot;people的路劲&quot; p:name=&quot;&quot; p:car-ref=&quot;car&quot; /&gt; Spring3.X版本之后提供的 spEL 的属性注入： spEL：Spring Expression Language /#{} 1234567891011//普通类型&lt;bean id=&quot;car&quot; class=&quot;&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;#&#123;&apos;奔驰&apos;&#125;&quot;&gt; &lt;property name=&quot;price&quot; value=&quot;#&#123;123&#125;&quot;&gt;&lt;/bean&gt;//对象类型&lt;bean id=&quot;employee&quot; class=&quot;&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;#&#123;&apos;强强&apos;&#125;&quot;&gt; &lt;property name=&quot;car&quot; value=&quot;#&#123;car&#125;&quot;&gt;&lt;/bean&gt; 还能用另外一个类的属性或方法名来赋值，先创建这个类，要用属性的话，可以直接写get方法，不用定义成员变量的。 要想用哪个类中的方法，就得先实例化这个类 然后再 #{实例化类名.属性/方法} 就可以了 //定义要使用的类12345678910public class CarInfo &#123; //public String name; public String getName() &#123; return &quot;奔驰&quot;; &#125; public Double calculatePrice()&#123; return Math.PI * 100000; &#125;&#125; 复杂类型的属性注入list map propertise 等复杂的属性类型 list/数组 12345678910//如果list的是对象最里边可以用&lt;ref/&gt;&lt;bean id=&quot;&quot; class=&quot;&quot; &gt; &lt;property name=&quot;lists&quot;&gt; &lt;list&gt; &lt;value&gt;值&lt;/value&gt; &lt;value&gt;值&lt;/value&gt; &lt;value&gt;值&lt;/value&gt; &lt;list&gt; &lt;/property&gt;&lt;/bean&gt; map 12345678//如果map里边是对象&lt;entry key-ref=&quot;&quot; value-ref=&quot;&quot;/&gt;&lt;bean id=&quot;&quot; class=&quot;&quot; &gt; &lt;property name=&quot;maps&quot;&gt; &lt;map&gt; &lt;entry key=&quot;&quot; value=&quot;&quot; /&gt; &lt;map&gt; &lt;/property&gt;&lt;/bean&gt; map还有一种方式 需要生成set方法，并在map标签中添加 &lt;entry&gt; &lt;key&gt; &lt;value&gt;test1&lt;/value&gt; &lt;/key&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;/entry&gt; propertise,键值对的形式 1234567&lt;bean id=&quot;&quot; class=&quot;&quot; &gt; &lt;property name=&quot;props&quot;&gt; &lt;props&gt; &lt;props key=&quot;&quot;&gt;值&lt;/props&gt; &lt;props&gt; &lt;/property&gt;&lt;/bean&gt; Spring的分模块开发就是可能有两个配置文件，分别配置不同的类 可以在加载配置文件时加载两个配置文件，用 ， 隔开 也可以只加载一个配置文件，然后在其中引入另外一个配置文件 &lt;import resource=&quot;applicationContext2.xml&quot;&gt; 如果引入的配置文件中的id有跟原配置文件的id相同的值，则会覆盖原来的。 案例中出现的问题将Dao配置到Spring 可以在配置service方法的时候把，Dao当作一个属性来配置，先把customerDao实例化，然后再引入到service配置文件中： 123456&lt;bean id=&quot;customerService&quot; class=&quot;com.itheima.crm.service.impl.CustomerServiceImpl&quot;&gt; &lt;property name=&quot;customerDao&quot; ref=&quot;customerDao&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;customerDao&quot; class=&quot;com.itheima.crm.dao.impl.CustomerDaoImpl&quot;&gt;&lt;/bean&gt; 配置监听器，使每次获取的都是同一个工厂类 为了避免每次用的时候，都创建一个工厂类，用监听器，在服务器启动的时候就让创建了工厂了，并存在ServletContext中，以后直接用就行 先引一个Spring的jar包：spring-web-4.2.4.RELEASE.jar 包中已经配好了监听器，直接配置就行： 在web下配置监听器 123456789 &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;//让上面那个监听器去加载下边的这个配置文件&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt; 获得工厂： 123456789//保存客户的方法:savepublic String save()&#123; //调用业务层，使用包中封装好的工具类获得servletContext中的工厂类 WebApplicationContext applicationContext = WebApplicationContextUtils.getWebApplicationContext(ServletActionContext.getServletContext_()); CustomerService customerService = (CustomerService) applicationContext.getBean(&quot;customerService&quot;); customerService.save(customer); return NONE;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Struts第四阶段]]></title>
      <url>%2F2016%2F06%2F25%2FStruts04%2F</url>
      <content type="text"><![CDATA[Struts2拦截器的概述什么是拦截器 拦截器是Struts2中的核心。其实就是一个类对Action的访问进行拦截。 拦截器与过滤器的区别： 过滤器过滤的是从客户端向服务器发送的请求。过滤器是可以过滤Html, JSP… 拦截器拦截的是从客户端向Action发送的请求。拦截器只能拦截Action，拦截器更细粒度的实施拦截。拦截到Action中具体的方法。 Struts2的执行流程： 请求访问Action，请求首先到达核心过滤器，过滤器会调用Dispather中的ServiceAction的方法 在这个方法内部，Struts2框架创建一个Action代理对象，执行代理对象中的execute方法，在execute内部方法调用Actioninvocatin中的invoke方法。 在invoke方法内部，递归调用拦截器的拦截的方法，如果没有下一个拦截器，执行目标Actioin，根据Action返回Result进行页面跳转，由Response做出响应。 自定义拦截器 实现Interceptor接口或者继承AbstractInterceptor类 配置拦截器 编写： 1234567891011121314public class InterceptorDemo1 extends AbstractInterceptor&#123; @Override public String intercept(ActionInvocation invocation) throws Exception &#123; System.out.println(&quot;InterceptorDemo1执行了...&quot;); String s = invocation.invoke(); System.out.println(&quot;InterceptorDemo1执行结束了...&quot;); return s; &#125;&#125; 配置拦截器 配置的时候会有顺序，默认的在前面，就先执行默认的，自己定义的在前面就先执行自己的 123456789//在&lt;package&gt;标签中配置&lt;interceptors&gt; &lt;interceptor name=&quot;名字&quot; class=&quot;拦截器路劲&quot; &gt;&lt;/interceptor&gt;&lt;/interceptors&gt;//**因为自定义之后默认的拦截器就不引用了，所以得引用一下默认的拦截器**&lt;interceptor-ref name=&quot;defaultStack&quot;&gt;//然后再&lt;action&gt; 标签中引用一下&lt;interceptor-ref name=&quot;拦截器名字&quot; /&gt; 2.还可以定义一个拦截器栈，在一块引用 123456789101112&lt;interceptors&gt; &lt;interceptor name=&quot;interceptor01&quot; class=&quot;路劲&quot; /&gt; &lt;interceptor name=&quot;interceptor02&quot; class=&quot;路劲&quot; /&gt; &lt;interceptor-stack name=&quot;myStack&quot;&gt; &lt;interceptor-ref name=&quot;defaultStack&quot;/&gt; &lt;interceptor-ref name=&quot;interceptor01&quot;/&gt; &lt;interceptor-ref name=&quot;interceptor02&quot;/&gt; &lt;/interceptor-stack&gt;&lt;/interceptors&gt;//引用的时候只需要引用拦截器栈就可以了&lt;interceptor-ref name=&quot;myStack&quot;/&gt; 案例：登陆页面错误信息回显错误信息：转发到登陆页面，否则actionerror用不了这里用到了actionerror 把错误信息存到值栈中 this.addactionError(&quot;错误信息&quot;); 在jsp中回显错误信息 &lt;s:actionerror/&gt; 登陆权限 编写拦截器 注：拦截一个方法用的是MethodFilterInterceptor 123456789101112131415public class PrivilegeInterceptor extends MethodFilterInterceptor&#123; @override protected String doIntercept(ActionInvocation invocation)&#123; //获得已存在的用户信息 User existUser = (User) ServletActionContext.getRequest().getSession().getAttribute(&quot;existUser&quot;); if(exiteUser!=null)&#123; return invocation.invoke(); &#125;else&#123; ActionSupport actionSupport=(ActionSupport)invocation.getAction(); actionSupport.addActionError(&quot;您还没有登陆！您还没有访问权限！&quot;); return actionSupport.LOGIN; &#125; &#125;&#125; 配置拦截器 12345678910//配置拦截器&lt;interceptors&gt; &lt;interceptor name=&quot;PrivilegeInterceptor&quot; class=&quot;。。。 &quot;/&gt;&lt;interceptors&gt;//在`action`中引用拦截器&lt;interceptor-ref name=&quot;PrivilegeInterceptor&quot;&gt; //因为在登陆的页面就不需要拦截了，所以可以加一个`param`来避免要拦截的页面 &lt;param name=&quot;excludeMethods&quot;&gt;登陆时的方法名&lt;/param&gt;&lt;/interceptor-ref&gt; 还得配一个全局的login，就拦截的信息转到login，dtd规定全局配置必须在拦截器下边 还有万一拦截之后发生错误，转到登陆页面，在登陆成功会发生嵌套效果，避免这种效果的方法是，在登陆的form标签上加一个target=&quot;_parent&quot; struts2的标签库通用的标签库Generi Tags 帮助文档中的Tag reference 传参数：&lt;s:param name=&quot;&quot; value=&quot;&quot;/&gt; 在遍历List集合的时候，放var里取出来时，可以加#,也可以不加，因为，他会在context中也放一个 123&lt;s:iterator value=&quot;&#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;&#125;&quot; var=&quot;i&quot;&gt; &lt;s:property value=&quot;i&quot;/&gt;---&lt;s:property value=&quot;#i&quot;/&gt;&lt;/s:iterator&gt; 遍历一些数，把其中3的倍数变红，每次加10 123456789&lt;h2&gt;遍历&lt;/h2&gt;&lt;s:iterator begin=&quot;10&quot; end=&quot;300&quot; step=&quot;10&quot; var=&quot;i&quot; status=&quot;sta&quot;&gt; &lt;s:if test=&quot;#sta.count % 3 == 0&quot;&gt; &lt;font color=&quot;red&quot;&gt;&lt;s:property value=&quot;i&quot;/&gt;&lt;/font&gt; &lt;/s:if&gt; &lt;s:else&gt; &lt;s:property value=&quot;i&quot;/&gt; &lt;/s:else&gt;&lt;/s:iterator&gt; UI标签库 UI Tags 优势：点文字可以获得焦点，文本框会加一些基本的样式，例如换行啊。。。 会提供一套默认的样式样式 xhtml 可以不用，在表单上加一个theme=&quot;simple&quot;,或者在常量上改变，这样所有的就都不能用了 UI标签的数据回显：优点： 将查询到的数据显示到指定文本框 数据校验或类型转换出错情况下 数据除了密码都会回显，并且会显示错误信息，密码也要回显添加一个showpassword=true 是在root区存着的。 Struts2的注解开发 引包 struts-convention-plugin 写好action之后加123456789@ParentPackage(&quot;struts-default&quot;)@Namespace(&quot;/&quot;)public class HelloAction extends ActionSupport&#123; @Action(value=&quot;访问路劲相当于action中的name&quot;，results=&quot;返回值&quot;) public String execute()&#123; syso(); return ...; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[xml]]></title>
      <url>%2F2016%2F06%2F18%2Fxml%2F</url>
      <content type="text"><![CDATA[XML和反射技术XML技术什么是XML，作用是什么可扩展标记语言（Extensible Markup Language ），XML是一种数据格式，类似 HTML，是使用标签进行内容描述的技术，与HTML不 同的是，XML的标签和属性 都是根据业务需求自定义的。 XML在企业开发中主要有两种应用场景： XML可以作为数据交换的载体，也就是说使用XML格式进行数据的传输目前有一门数据交换的语言慢慢替代xml —- json XML可以作为配置文件的载体，例如后续我们学习的servlet、struts2、hibernate 的配置都是通过XML进行配置的（常使用的） 如何去写一个XML（重点） XML的编写要比HTML简单，根据实际的业务场景自行编写有意义的标签和属性， 例如创建一个以.xml为后缀名的文件，编写描述一个网上商城的商品信息的xml 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;store&gt; &lt;product category=&quot;手机数码&quot;&gt; &lt;pid&gt;100&lt;/pid&gt; &lt;pname&gt;华为手机&lt;/pname&gt; &lt;price&gt;3000&lt;/price&gt; &lt;/product&gt; &lt;product category=&quot;电脑办公&quot;&gt; &lt;pid&gt;200&lt;/pid&gt; &lt;pname&gt;三星笔记本&lt;/pname&gt; &lt;price&gt;5000&lt;/price&gt; &lt;/product&gt; &lt;product category=&quot;大型家电&quot;&gt; &lt;pid&gt;300&lt;/pid&gt; &lt;pname&gt;海尔洗衣机&lt;/pname&gt; &lt;price&gt;4000&lt;/price&gt; &lt;/product&gt;&lt;/store&gt; xml编写时也要符合一定的规则： xml文件的后缀名是.xml xml有且只有一个根标签 xml的标签是尖括号包裹关键字成对出现的，有开始标签有结束标签，关键字是自 定义的，xml也可以有空标签/自关闭标签 xml允许有属性，属性也是根据需要自定义的，属性格式：属性=“属性值”，多 个属性之间使用空格隔开 xml是区分大小写的 —– html不区分大小写 xml的组成： 文档声明：&lt;?xml version=”1.0” encoding=”UTF-8”?&gt; 根标签，例如： 其他标签，例如： 属性，例如：category=”电脑办公” 文本，例如：三星笔记本 注释，例如： CDATA区：CDATA区可以保证数据的原文输出例如：&lt;![CDATA[原文显示的内容]]&gt; 如何去约束一个XML（了解） 提到约束一个XML，必须要理解为什么对XML要进行约束？ 因为XML的标签都是自定义的，xml在作为框架配置时不能很好的规范开发者书写， 所以要使用约束告知开发者怎样去配置一个xml XML的约束有两种： DTD约束 Schema约束 DTD约束 例如：我们要约束上述编写的store.xml,相应 的DTD约束如下 123456&lt;!ELEMENT store (product+)&gt;&lt;!ELEMENT product (pid,pname,price)&gt;&lt;!ELEMENT pid (#PCDATA)&gt;&lt;!ELEMENT pname (#PCDATA)&gt;&lt;!ELEMENT price (#PCDATA)&gt;&lt;!ATTLIST product category CDATA #REQUIRED&gt; dtd的语法摘要： 使用ELEMENT描述元素 括号() 代表标签体的内容 子标签—标签名称 子标签有多少个？ 通过符号描述： 123+：代表一个或多个 至少有一个*：代表0个或的多个 有没有都行?：代表0个或一个 子标签的顺序： 使用逗号, 或 | 任意选择一个 文本—-#PCDATA 使用ATTLIST描述某个元素身上的属性属于哪个标签 属性名称 属性的类型 该属性的是否必须 该属性的是否必须：+ `#REQUIRED` 代表概述户型必须 + `#IMPLIED` 代表属性随意 写也行不写也行 引入约束 在xml中引入本地的DTD文件：&lt;!DOCTYPE store SYSTEM &quot;store.dtd&quot;&gt; 其中：SYSTEM代表本地dtd文件 在xml中引入互联网上的DTD文件： &lt;!DOCTYPE store PUBLIC &quot;//UNKNOWN/&quot; &quot;unknown.dtd&quot;&gt; 其中：PUBLIC代表互联网上的DTD + //UNKNOWN/：此位置代表为引入的DTD取一个名称，随意取 + unknown.dtd：此位置代表引入的DTD的路径，一般是互联网路径 Schema约束例如：我们要约束上述编写的store.xml,相应 的Schema约束如下 Schema中分为简单元素和复杂元素 简单元素：标签仅仅包含文本标签体的元素 复杂元素：标签包括子标签或属性的元素 Schema约束是怎样引入到XML中的？ 例如： web工程的核心配置文件web.xml spring的核心配置文件applicationContext.xml 如何去解析一个XML（了解） XML的解析就是将有用的信息从XML文档中解析出来，例如上述的store.xml，怎 样通过API将store.xml中的属性值和文本解析出来。 常用的解析方式 DOM解析：将文档整体加载到内存形成一个DOM树在解析，支持文档的增删改查 和文档的回写。 SAX解析：读取一行解析一行，只支持文档的查询，也不支持文档的回写。 PULL解析：类似SAX解析，Android的常用解析技术。 常用的解析技术 JAXP：SUN公司的官方解析技术，支持DOM解析和SAX解析 JSOUP：一种解析HTML的特定解析的开发包 JDOM：开源组织的DOM方式的解析技术 DOM4J：JDOM的分离版，开源，Hibernate底层的XML解析技术 DOM4J解析技术 DOM4J是第三方开源的解析技术，首先要下载dom4j.jar 将其中的jar包导入工程 解析XML的步骤： 在dom4j的lib目录下有一个jaxen-1.1-beta-6.jar，导入这个jar包可以进行XPath的解析。 XML的实际应用场景（理解） 实际开发中，我们一般会使用各种各样的框架的进行企业开发，而这些框架一般都会 将某些公共的功能写好了，我们需要做的只需要按照框架提供的约束进行框架的配置 就可以了，当我们使用XML配置好框架后，在运行时，框架底层会解析我们配置XML 文档获取有用的信息，从而根据我们的需求实现某些功能。 所以，实际开发中我们很少会自己编写XML约束和解析XML]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Struts第三阶段]]></title>
      <url>%2F2016%2F06%2F17%2FStruts03%2F</url>
      <content type="text"><![CDATA[Struts2OGNL的概述 OGNL(Object Graph Navigation Language):对象图导航语言是一个独立的表达式语言，Struts2感觉OGNL很强大，将OGNL引入到自身 OGNL比EL强大很多倍的表达式的语言。（EL获取的数据来源与四个作用域，EL提供11个Web对象） 作用： OGNL的要素context（OgnlContext），root(CompoundRoot)，表达式 OGNL在java中的使用(了解）1234567891011121314151617181920212223242526272829303132333435363738394041424344//获取对象的方法@Testpublic void demo01()&#123; //获得数据 OgnlContext context=new OgnlContext(); Object obj = Ognl.getValue(&quot;&apos;helloworld&apos;.length()&quot;,context,context.getRoot()); System.out.println(obj);&#125;//获取静态对象的方法@Testpublic void demo02()&#123; //获得数据 OgnlContext context=new OgnlContext(); Object obj = Ognl.getValue(&quot;@java.lang.Math@random()&quot;,context,context.getRoot()); System.out.println(obj); //打印一个1以内的小数&#125;//获取root中的数据@Testpublic void demo03()&#123; Product product = new Product(); product.setName(&quot;john&quot;); //获得数据 OgnlContext context=new OgnlContext(); context.setRoot(product); Object obj = Ognl.getValue(&quot;name&quot;,context,context.getRoot()); System.out.println(obj);&#125;//OGNL获取context的数据//context中存入的List集合，其他的普通的值//获取context数据需加#@Testpublic void demo03()&#123; //获得context OgnlContext context=new OgnlContext(); context.put(&quot;key&quot;,&quot;阿斯顿&quot;); Object obj =Ognl.getValue(&quot;#key&quot;,context,context.getRoot()); System.out.println(obj);&#125; 值栈什么是值栈 ValueStack：相当于Struts2的数据的中转站，ValueStack贯穿了整个action的生命周期。 Action是多例的，一次请求服务器请求就会创建一个Action，同时会为这个Action创建一个ValueStack对象。Struts2通过OGNL表达式获取值栈的数据。 ValueStack是Struck2的一个接口，OGNLValueStack是该接口的实现类。 值栈的内部结构 值栈分为root区跟context区，root(CompoundRoot)区是一个list集合，context(OgnlContext)是一个map 操作值栈一般是操作root context中存入了root，还有session等多个域 查看值栈的内部结构： debug看结构,在action中运行下面获取ValueStackValueStack valueStack=ActionContext.getContext().getValueStack(); 让其跳转到一个页面，页面上加一个&lt;s:debug/&gt;,运行后点开 ActionContext与值栈的关系 ActionContext：代表Action的上下文对象 通过源码查看：Struts的核心过滤器执行的过程中，创建ActionContext对象，在创建ActionContext对象的同时创建一个ValueStack，并且将ValueStack存入到ActionContext中。所以通过ActionContext对象，获得值栈。其实在ValueStack的内部有一个ActionContext的引用。 ActionContext中有ValueStack的引用，ValueStack中也有ActionStack的引用。 ActionContext之所以之能访问Servlet的API其实也是依赖了值栈的。 2.4如何获得值栈其实在request中也存放了ValueStack： 核心过滤器—&gt;执行action—&gt;serviceAction—&gt;proxy代理类中。 获取值栈：通过ActionContext获取 1ValueStack valueStack=ActionContext.getContext().getValueStack(); 通过request域对象 1ValueStack valueStack02=(ValueStack)ServletActionContext.getRequest().getAttribute(ServletActionContext.STRUTS_VALUESTACK_KEY); 两种获取值栈的方法是一样的，因为同一个action类只能加载一个值栈 如何操作值栈对象(操作root区)存入值栈一. 直接操作值栈对象, 在值栈中封装数据 123456//void set(String name,Object value); ----将数据封装到map集合中在存入，一般操作字符串valueStack.set(&quot;name&quot;,&quot;value&quot;);//void push(Object obj); -----直接将对象压入值栈中，一般操作对象valueStack.push(User); 二. 直接在Action对象中提供成员属性 当Action的实例被创建了，默认的情况下(没有手动操作值栈，没有实现模型驱动)，Action对象在栈顶的位置，Action的属性也会在栈顶位置，提供一个属性，对该属性提供一个get方法就可以了。 12345678910111213public class valueStackAction extends ActionSupport&#123; private String name; public String getName()&#123; return name; &#125; public String execute()&#123; name=&quot;张三&quot;; return SUCCESS; &#125;&#125; 获取值栈（root） 在jsp中需要先引标签库，&lt;%@ taglib uri=&quot;/struts-tags&quot; prefix=&quot;s&quot; %&gt; 使用OGNL表达式 1234567//s:property标签中value的属性放的是OGNL的表达式//调用对象的方法&lt;s:property value=&quot;&apos;HelloWorld&apos;.length()&quot;/&gt;//调用静态对象的方法//在struts中默认关掉了静态访问的方法，需要开开，现在struts.xml配置常量&lt;s:property value=&quot;@java.lang.Math@random&quot;/&gt; 取出存入的值 1234567//通过set存入的字符串值&lt;s:property value=&quot;name&quot;/&gt;//通过set存入的list集合,list集合中存放的对象中有name属性&lt;s:property value=&quot;list[0].name&quot;/&gt;//通过push存入对象&lt;s:property value=&quot;对象的属性&quot;/&gt; 操作context区域的区域在action存就是通过ActionContext对象,来操作API 在jsp取12345&lt;s:property value=&quot;#session.name&quot;/&gt;&lt;s:property value=&quot;#request.name&quot;/&gt;&lt;s:property value=&quot;#appliaction.name&quot;/&gt; &lt;s:property value=&quot;#attr.name&quot;/&gt; 表示取域最小中的值，没有的话找大一级的pageContext /&lt; request /&lt; session /&lt; application &lt;s:property value=&quot;#parameters.name&quot;/&gt;表示取传过来的属性值，没有就为空 EL也可以获取值栈的数据EL也能获取到值栈的数据，因为过滤器中，会增强request，查看值栈中是否有数据，有的话存到request域中。 OGNL中的特殊字符的使用#号 获取context部分的数据 构建map集合 单选按钮(其实也使用的map集合) 或 %号 强制解析OGNL表达式数据回显的时候，取出域中的值 强制不解析OGNL表达式 $符 在配置文件中获取值栈中的数据(通过OGNL获取)。 文件下载的时候： 123&lt;result type=&quot;stream&quot;&gt; &lt;param name=&quot;Content-Disposition&quot;&gt;attachement;filename=$&#123;fileName&#125;&lt;/param&gt;&lt;/result&gt; 国际化： 1234message_zh_CN.propertiesname=您好：$&#123;#request.name&#125;message_en_US.propertiesname=Hello:$&#123;#request.name&#125; OGNL遍历前提是list是一个Customer类型的集合： 123&lt;s:iterator value=&quot;list&quot;&gt; &lt;s:property value=&quot;custName&quot;/&gt;&lt;/s:iterator&gt; s标签不能嵌套s标签，html标签中能]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Struts第二阶段]]></title>
      <url>%2F2016%2F06%2F13%2FStruts02%2F</url>
      <content type="text"><![CDATA[struts2Struts2访问Servlet的API完全解耦和的方式实现Servlet的API的访问 获取ActionContextActionContext actionContex=ActionContext.getContext(); 接受参数：解耦和的方式通过ActionContext中的方法实现： 123456789101112Map&lt;String,Object&gt; getParamters(); //Object是一个字符串类型的数组Map&lt;String,Object&gt; getSession();Map&lt;String,Object&gt; getApplication();void setSession(Map&lt;String,Object&gt; session);void setApplication(Map&lt;String,Object&gt; application);//向request中存数据actionContext.put(String name,Object object);//向session中存数据actionContext.getSession.put(String name,Object object);//向application中存数据(ServletContext对象)actionContext.getApplication().put(String name,Object object); post提交不用管中文action会管了,get提交需要设置 通过实现特定的接口来实现Servlet的API的访问 让action类去实现ServletRequestAware接口，然后在成员位置定义一个HttpServletRequest变量，下边重写一个setServletRequest方法，让成员的request等于方法中的，可以当作正常的request用。 123456789101112131415161718192021222324252627282930313233public class RequestDemo2Action extends ActionSupport implements ServletRequestAware,ServletContextAware&#123; private HttpServletRequest request ; private ServletContext application; @Override public String execute() throws Exception &#123; // 接收参数:需要使用request对象。 Map&lt;String, String[]&gt; parameterMap = request.getParameterMap(); for (String key : parameterMap.keySet()) &#123; String[] value = parameterMap.get(key); System.out.println(key+&quot; &quot;+Arrays.toString(value)); &#125; // 向request域中存值: request.setAttribute(&quot;reqName&quot;, &quot;r郝天一&quot;); // 向session域中存值： request.getSession().setAttribute(&quot;sessName&quot;, &quot;s郝思聪&quot;); // 向application域中存值： application.setAttribute(&quot;appName&quot;, &quot;a郝冠希&quot;); return SUCCESS; &#125; @Override public void setServletRequest(HttpServletRequest request) &#123; this.request = request; &#125; @Override public void setServletContext(ServletContext application) &#123; this.application = application; &#125;&#125; 如果想用ServletContext对象，则在实现一个ServletContextAwre接口，方式跟上边的一样。 通过ServletActionContext的静态方法实现Servlet的API的访问 struts核心包中的api 12345//获取request对象HttpServletRequest request = ServletActionContext.getRequest();Map(String,String[]) paramterMap=request.getParameterMap();//获取ServletContext参数ServletContext application=ServletActionContext.getServletContext(); Struts2的数据的封装Struts2的多例 因为action是多例的，意思就是每次刷新页面都会重新执行action类多例的话就可以使用成员变量，创建Service的时候，就可以放成全局。 属性驱动 Struts既有控制层，又有模型层。 提供属性的set方法完成数据的封装 在action类中，定义要接受的属性的成员变量，只提供set方法，即可获取属性值 这种方式应用的不多，因为还需要手动装到对象中。 在页面中提供表达式（OGNL）的方式完成数据封装(直接封装到实体对象中) 在页面中这样写name,前面的user必须跟action中成员方式的对象名一致。 在action类中的成员位置加一个实体类对象，并提供get跟set方法。 123456789101112131415 public class User2Action extends ActionSupport&#123; private User user; // 需要提供get和set方法: public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; @Override public String execute() throws Exception &#123; System.out.println(user); return NONE; &#125;&#125; 注： 在第二种方法中，必须有get set方法 因为属性驱动是在拦截器中执行的，他需要把action中的对象实例化，所以要get到，如果不给提供get方法，则，每次封装的时候都会自动创建一个新的实例对象，这样会导致使用这个对象时只会有第一个封装进来的值 拦截器在strut-default.xml中 模型驱动采用模型驱动的方式来实现(推荐)： 页面即用普通页面。 让action来实现一个 ModelDriver/ 接口,里面必须手动构建对象。T是要封装的那个实体的类型 OGNL表达式的方式和模型驱动都有使用的。模型驱动通常会使用的方式。有一个缺点，就是只能封装到一个对象中，如果想封装到多个对象，就需要用到OGNL Struts2中复杂类型数据的封装封装到List集合中页面： 12345678910&lt;h1&gt;批量插入商品&lt;/h1&gt;&lt;form action=&quot;$&#123; pageContext.request.contextPath &#125;/product1Action.action&quot; method=&quot;post&quot;&gt; 商品名称:&lt;input type=&quot;text&quot; name=&quot;list[0].name&quot;&gt;&lt;br/&gt; 商品价格:&lt;input type=&quot;text&quot; name=&quot;list[0].price&quot;&gt;&lt;br/&gt; 商品名称:&lt;input type=&quot;text&quot; name=&quot;list[1].name&quot;&gt;&lt;br/&gt; 商品价格:&lt;input type=&quot;text&quot; name=&quot;list[1].price&quot;&gt;&lt;br/&gt; 商品名称:&lt;input type=&quot;text&quot; name=&quot;list[2].name&quot;&gt;&lt;br/&gt; 商品价格:&lt;input type=&quot;text&quot; name=&quot;list[2].price&quot;&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;批量导入&quot;&gt;&lt;/form&gt; Action： 123456789101112131415161718192021222324/** * Struts2复杂数据类型的封装：封装到List集合中 * @author jt * */public class Product1Action extends ActionSupport&#123; private List&lt;Product&gt; list; public List&lt;Product&gt; getList() &#123; return list; &#125; public void setList(List&lt;Product&gt; list) &#123; this.list = list; &#125; @Override public String execute() throws Exception &#123; for (Product product : list) &#123; System.out.println(product); &#125; return NONE; &#125;&#125; 封装到Map集合页面: 12345678910&lt;h1&gt;批量插入商品:封装到Map集合&lt;/h1&gt;&lt;form action=&quot;$&#123; pageContext.request.contextPath &#125;/product2Action.action&quot; method=&quot;post&quot;&gt; 商品名称:&lt;input type=&quot;text&quot; name=&quot;map[&apos;one&apos;].name&quot;&gt;&lt;br/&gt; 商品价格:&lt;input type=&quot;text&quot; name=&quot;map[&apos;one&apos;].price&quot;&gt;&lt;br/&gt; 商品名称:&lt;input type=&quot;text&quot; name=&quot;map[&apos;two&apos;].name&quot;&gt;&lt;br/&gt; 商品价格:&lt;input type=&quot;text&quot; name=&quot;map[&apos;two&apos;].price&quot;&gt;&lt;br/&gt; 商品名称:&lt;input type=&quot;text&quot; name=&quot;map[&apos;three&apos;].name&quot;&gt;&lt;br/&gt; 商品价格:&lt;input type=&quot;text&quot; name=&quot;map[&apos;three&apos;].price&quot;&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;批量导入&quot;&gt;&lt;/form&gt; Action: 12345678910111213141516171819202122232425/** * Struts2的复杂数据的封装：Map集合的封装 * @author jt * */public class Product2Action extends ActionSupport&#123; private Map&lt;String,Product&gt; map; public Map&lt;String, Product&gt; getMap() &#123; return map; &#125; public void setMap(Map&lt;String, Product&gt; map) &#123; this.map = map; &#125; @Override public String execute() throws Exception &#123; for (String key : map.keySet()) &#123; Product product = map.get(key); System.out.println(key+&quot; &quot;+product); &#125; return NONE; &#125;&#125; Struts中结果页面的配置结果页面的分类： 全局结果页面 可以对所有的action都有效 局部结果页面 在 /&lt; action /&gt; 内部配置 /&lt; result /&gt; ,只会对当前的Action有效。 如果有全局页面跟局部页面同时存在的时候，首先要看局部页面。 全局结果页面的配置12345&lt;package&gt; &lt;global-results&gt; &lt;result name=&quot;success&quot;&gt;地址。。。&lt;/result&gt; &lt;/global-results&gt;&lt;/package&gt; 局部结果页面的配置12345&lt;package&gt; &lt;action&gt; &lt;result name=&quot;success&quot;&gt;地址。。。&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; Struts2结果页面类型的配置 /&lt; result /&gt; 标签上还有一个属性： name ：逻辑视图名称。 type ：页面跳转的类型 dispather ：默认值，转发，转发到jsp页面 chain ：转发到一个Action redirect ：重定向。重定向到jsp redirectAction ：重定向到一个Action，重定向的时候如果不是在一个命名空间中，可以自己加上属性，（在result下面加param标签） stream ：文件下载的时候 struts2中内置数据类型的转换 会把传过来的特殊数据类型转换为实体中需要的类型，integer，date都能封装。 都是在拦截器执行的。 当转换失败时，会到Workflow拦截器，然后查看是否有这个错误，如果有会运行一个input视图中有错误信息，跳转到input的页面中。 例如Integer中添了一个字母。 可以在配置文件中，设置一个input的跳转页面，当有错误时，会跳转到这个页面 这个页面中可以加一个标签，显示错误信息 1234 &lt;%@ taglib uri=&quot;/struts-tags&quot; prefix=&quot;s&quot; %&gt; //可以加两个标签，是哪个错误会显示哪个错误 &lt;s:actionerror/&gt; &lt;s:fielderror/&gt; 注： 有的时候elipse会编译前一段时间的代码，修改之后不会及时编译最新的，可以把tomcat中的webapps项目中的class文件删除，然后再在elispe中，project/build all手动编译一下。 struts2中的带的log4j是2.2版本的，hibernate中是1.几版本的，所以不能把hibernate中的配置文件中copy过来直接用，可以在struts2提供的项目模板中找一个，2.2版本的配置文件是 .xml 的]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Struts第一阶段]]></title>
      <url>%2F2016%2F06%2F10%2FStruts01%2F</url>
      <content type="text"><![CDATA[strust2入门与介绍什么是Struts2是基于MVC设计模式的WEB层框架 WEB层框架Struts1，WebWork，Struts2，SpringMVC Struts2的内核是基于WebWork的 前端控制器模式 Struts2的入门 解压之后： apps ：Struts2 里面提供的一些测试的应用 docs ：Struts2 里面的帮助文档 lib ：Struts2的提供的开发的jar包 src ：Struts2提供的源码 导包，导最少的包，找到blank项目下的jar包，导这些即可 写一个jsp页面，跳转的目标的路径是xxx.action. &lt;h3&gt; &lt;a href=&quot;${pageContext.request.contextPath}/hello.action&quot;&gt;访问Struts2框架&lt;/a&gt;&lt;/h3&gt; 配置Struts2的核心过滤器，前端控制器(完成部分功能)，会默认执行拦截器（过滤器路径在struts2-core/包后边是filter/StrutsPrepareAndExecuteFilter.class），然后会跳到配置文件中 写action类里面有一个execute方法，方法的格式是固定的：必须是public ，返回值是String，方法名execute，方法中没有参数 配置action类的配置文件 struts2默认的配置文件是struts.xml，写在src下。 配置文件写法：copy约束，struts标签，里边有package package标签属性：name extends namespace package里边有action：name class类action的全路径 修改struts2配置文件：加一个result标签1234567&lt;struts&gt; &lt;package name=&quot;demo01&quot; extends=&quot;struts-default&quot; namespace=&quot;/&quot;&gt; &lt;action name=&quot;jsp中的xxx&quot; class=&quot;类action的全路径&quot;&gt; &lt;result name=&quot;success(action传过来的字符串)&quot;&gt;要跳转的路径&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; struts2的执行流程当一个页面发送一个请求的时候，首先经过核心过滤器(StrutsPrepareAndExecuteFilter),在这个过滤器中其实会执行一组拦截器(这组拦截器就完成了部分的功能)，执行完这组拦截器之后，执行目标Action，返回一个结果视图，根据返回结果跳转不同界面。 struts2常见的配置struts2的配置文件的加载顺序：（了解）过滤器StrutsPrepareAndExecuteFilter会在服务器启动时初始化。在过滤器中会执行dispatcher = init.initDispatcher(config);,然后在执行dispatcher.init();,再然后会执行下面的配置文件 123456init_DefaultProperties(); // [1] -----default.properties 核心包里第一个包下边呢init_TraditionalXmlConfigurations(); // [2] -----struts-default.xml,struts-plugin.xml,struts.xmlinit_LegacyStrutsProperties(); // [3] -----struts.propertiesinit_CustomConfigurationProviders(); // [5] -----客户自定义提供类init_FilterInitParameters() ; // [6] -----加载web.xml中过滤器中的参数init_AliasStandardObjects() ; // [7] -----加载自定义类 这几个值规定了加载配配置文件的顺序: default.properties struts-default.xml struts-plugin.xml struts.xml struts.properties web.xml 主要用的后三个，顺序是由上到下 struts2的主要配置文件：struts2中Action的配置(struts.xml) 包的配置(package) Struts2为了更好的管理Action，将Action分包进行管理的。 /&lt; package /&gt;包中的顺序 name :包名，一个配置文件中不要出现重复的包名 extends：继承别的包，通常继承struts-default namespace：名称空间，跟下边的/中的name属性共同决定访问路劲 namespace=””; 最后在找这个，在/之后 namespace=”/“; 没有指定的名称的执行这个，一般就会写这个 namespace=”/aaa”; 首先找带名称空间的，这个是最大化 abstract：是否可以被别的包继承，true表示可以应用于其他包的继承 Action的配置 /&lt; action /&gt; 的配置 name：与名称空间共同决定访问路劲 class：Action类的全路径 method：Action中要执行的方法的名称，默认值execute Structs2中常量的位置Struct中常量有三个配置的位置: struts.xml（推荐）&lt;constant name=&quot;struts.action.extension&quot; value=&quot;action&quot;&gt; struts.propertiesstruts.actioin.extension=action web.xml 12345 // &lt;filter&gt;中加一个 &lt;init-param&gt; &lt;param-name&gt;struts.actioin.extension&lt;/param-name&gt; &lt;param-value&gt;action&lt;/param-value&gt; &lt;/init-param&gt; 这里的struts.actioin.extension常量，表示访问的时候，路径的后缀名要加什么，默认是action, ,表示action跟空 改配置文件不用重启服务器 &lt;constant name=&quot;struts.devMode&quot; value=&quot;true&quot; /&gt; Struts2分模块开发的配置在struts2.xml 配置文件中用&lt;include file=&quot;要包含的子配置文件&quot;/&gt; Action的编写Action本身是一个POJO的类POJO(plain ordinary java object)的类,简单的java类：没有继承任何类。 Action实现一个Action的接口在action的接口中，提供了个常量（逻辑视图名称） SUCCESS ：成功 NONE ：不跳转 ERROR ：跳转到错误的页面 INPUT ：表单校验 LOGIN ：跳转到登陆页面 Action继承一个ActionSupport的类ActionSupport实现Action的接口，还有好多扩展的方法在父类里面的execute里，直接返回的SUCCESS。 以后写的时候最好使用这种方法。 Action的访问现在已经可以访问到Action，但是一次请求对应了一个Action的，需要一个模块的多次请求添加到一个Action中。 可以在struts.xml中配配置1234567891011121314151617181920212223242526272829303132333435363738//页面&lt;h1&gt;客户管理&lt;/h1&gt;&lt;h3&gt;&lt;a href=&quot;$&#123; pageContext.request.contextPath &#125;/addCustomer.action&quot;&gt;添加客户&lt;/a&gt;&lt;/h3&gt;&lt;h3&gt;&lt;a href=&quot;$&#123; pageContext.request.contextPath &#125;/findCustomer.action&quot;&gt;查询客户&lt;/a&gt;&lt;/h3&gt;&lt;h3&gt;&lt;a href=&quot;$&#123; pageContext.request.contextPath &#125;/updateCustomer.action&quot;&gt;修改客户&lt;/a&gt;&lt;/h3&gt;&lt;h3&gt;&lt;a href=&quot;$&#123; pageContext.request.contextPath &#125;/deleteCustomer.action&quot;&gt;删除客户&lt;/a&gt;&lt;/h3&gt;//编写actionpublic class CustomerAction extends ActionSupport&#123; public String add()&#123; System.out.println(&quot;保存客户...&quot;); return NONE; &#125; public String find()&#123; System.out.println(&quot;查询客户...&quot;); return NONE; &#125; public String update()&#123; System.out.println(&quot;修改客户...&quot;); return NONE; &#125; public String delete()&#123; System.out.println(&quot;删除客户...&quot;); return NONE; &#125;&#125;//配置action&lt;!-- 配置package包 --&gt; &lt;package name=&quot;demo3&quot; extends=&quot;struts-default&quot; namespace=&quot;/&quot;&gt; &lt;!-- 配置action --&gt; &lt;action name=&quot;addCustomer&quot; class=&quot;com.itheima.struts2.action3.CustomerAction&quot; method=&quot;add&quot;/&gt; &lt;action name=&quot;findCustomer&quot; class=&quot;com.itheima.struts2.action3.CustomerAction&quot; method=&quot;find&quot;/&gt; &lt;action name=&quot;updateCustomer&quot; class=&quot;com.itheima.struts2.action3.CustomerAction&quot; method=&quot;update&quot;/&gt; &lt;action name=&quot;deleteCustomer&quot; class=&quot;com.itheima.struts2.action3.CustomerAction&quot; method=&quot;delete&quot;/&gt; &lt;/package&gt; 通配符的方式//第一个*代表的数就是传过来的那个参数的后部分，正好是method里的东西 12345678910111213141516171819202122232425262728293031//页面&lt;h1&gt;商品管理&lt;/h1&gt;&lt;h3&gt;&lt;a href=&quot;$&#123; pageContext.request.contextPath &#125;/product_add.action&quot;&gt;添加客户&lt;/a&gt;&lt;/h3&gt;&lt;h3&gt;&lt;a href=&quot;$&#123; pageContext.request.contextPath &#125;/product_find.action&quot;&gt;查询客户&lt;/a&gt;&lt;/h3&gt;&lt;h3&gt;&lt;a href=&quot;$&#123; pageContext.request.contextPath &#125;/product_update.action&quot;&gt;修改客户&lt;/a&gt;&lt;/h3&gt;&lt;h3&gt;&lt;a href=&quot;$&#123; pageContext.request.contextPath &#125;/product_delete.action&quot;&gt;删除客户&lt;/a&gt;&lt;/h3&gt;//编写Actionpublic class ProductAction extends ActionSupport&#123; public String add()&#123; System.out.println(&quot;保存商品...&quot;); return NONE; &#125; public String find()&#123; System.out.println(&quot;查询商品...&quot;); return NONE; &#125; public String update()&#123; System.out.println(&quot;修改商品...&quot;); return NONE; &#125; public String delete()&#123; System.out.println(&quot;删除商品...&quot;); return NONE; &#125;&#125;//配置Action: &lt;!-- 通配符的方式的配置 --&gt; &lt;action name=&quot;product_*&quot; class=&quot;com.itheima.struts2.action3.ProductAction&quot; method=&quot;&#123;1&#125;&quot;/&gt; 更通配的写法： 动态方法访问在struts2中默认是关闭的，需要开启，在default.porperties中，需要在配置文件中修改称true &lt;constant name=&quot;struts.enable.DynamicMethodInvocation&quot; value=&quot;true&quot;&gt; 12345678910//页面&lt;h1&gt;订单管理&lt;/h1&gt;&lt;h3&gt;&lt;a href=&quot;$&#123; pageContext.request.contextPath &#125;/order!add.action&quot;&gt;添加订单&lt;/a&gt;&lt;/h3&gt;&lt;h3&gt;&lt;a href=&quot;$&#123; pageContext.request.contextPath &#125;/order!find.action&quot;&gt;查询订单&lt;/a&gt;&lt;/h3&gt;&lt;h3&gt;&lt;a href=&quot;$&#123; pageContext.request.contextPath &#125;/order!update.action&quot;&gt;修改订单&lt;/a&gt;&lt;/h3&gt;&lt;h3&gt;&lt;a href=&quot;$&#123; pageContext.request.contextPath &#125;/order!delete.action&quot;&gt;删除订单&lt;/a&gt;&lt;/h3&gt;//配置。不用写method&lt;!-- 动态方法的访问 --&gt;&lt;action name=&quot;order&quot; class=&quot;com.itheima.struts2.action3.OrderAction&quot;/&gt; 跳转之后，如果result里边是success可以省略。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git]]></title>
      <url>%2F2016%2F05%2F26%2Fgit%2F</url>
      <content type="text"><![CDATA[github分布式管理控制 将远程仓库中克隆到本地 客户端将添加、修改、删除等操作的文件先添加到一个暂存区 将暂存区中的所有文件提交到版本库中 将本地版本库推送到远端仓库 github Github 是为开发者提供Git仓库的托管服务。是一个让开发者与朋友、同事及陌生人共享代码的完美平台。 http://www.github.com github的作用 帮你托管仓库 社交化编程（程序员的新浪微博） Git在一个项目的跟目录下可以添加一个README.md文件，在github项目中会在首页的下边显示他的内容，默认为开始界面 git基本命令 git clone 仓库名称 //从远程仓库拿到项目 git init 仓库名称 只要执行了该命令，git会帮你自动创建一个目录，然后在该目录下生成一个’.git’ git status 查看当前工作树的状态 git add 文件名 将操作的文件添加到暂存区，待提交 git add –all 把所有修改的文件存到暂存区 git commit -m “提交日志” –author=”你的用户名 &lt;邮箱&gt;” 上面这条命令表示将暂存区中的文件提交到本地仓库 使用 git commit, 最好告诉版本仓库，你这提交的作者是谁，还有邮箱，方便联系 git log 查看提交日志 配置用户名跟邮箱 git config –global user.name “用户名” git config –global user.email “邮箱” 将本地文件提交到远程仓库 git push 从远程仓库拉取最新东西 git pull github Pages部署静态网站 创建一个仓库，用户名必须是 用户名.github.io 以后访问的时候登陆这个域名即可 把项目clone到本地，然后把项目考进去，然后提交到本地仓库 push 到远程仓库即可 会把项目中的index.html设置为首页，直接访问用户名.github.io 就能看到项目的首页。 使用 hexo 快速搭建个人博客到Github 安装 note 环境 在你的终端执行：npm install hexo-cli -g 使用hexo init 目录名称 生成一个博客系统 切换到刚才生成的博客目录 然后执行 hexo server 启动一个本地服务器 修改博客 如果想新增博客，可以先退出服务器，然后进入博客的目录 hexo new 文件名称 会在source中的_posts中生成一个markdown笔记， 修改配置在 _config.yml 部署 HEXO 第一在 github 上新建一个空仓库(也就是你的域名仓库) 第二，修改 _config.yml 中的 deloy 选项为如下： 123deloy: type:git repo:刚才创建的仓库地址 第三：在终端执行npm install hexo -deployer -git --save安装一个自动提交插件 第四：在你的博客目录的根目录下执行 hexo deploy 这样的话Hexo就会自动帮你提交到这个仓库。 以后只需要通过 hexo new 文章名称 创建一篇博客，写完之后，直接通过 hexo deploy --generate 发布到github上。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hibernate第四阶段]]></title>
      <url>%2F2016%2F05%2F17%2FHibernate04%2F</url>
      <content type="text"><![CDATA[Hibernate1.Hibernate的检索方式Hibernate提供对于对象的查询的方式 1.1Hibernate中五种查询方式1.1.1OID检索：根据主键查询+ session 中的get 和load方法 1.1.2对象导航检索：通过一个对象获得到其关联对象。LinkMan linkMan = session.get(LinkMan.class,1L);Customer customer=Linkman.getCustomer(); 1.1.3HQL 检索：通过编写一个HQL语句检索1.1.3.1HQL的基本的查询，别名查询，排序查询 在创建实体类的时候，生成toString的时候，不要把两个实体都生成，要不会互相打印，形成死循环，可以去掉一个set集合 查询全部//里面不能使用select * . 123456789Query query = session.createQuery(&quot;from Customer c&quot;); //给Customer取得别名List&lt;Customer&gt; lists=query.list();//也可以这么写List&lt;Customer&gt; list=session.createQuery(&quot;select c from Customer c&quot;).list();//HQL还支持多肽查询,查询所有Object下的持久化类Query query=session.createQuery(&quot;from java.util.Object&quot;);List&lt;Object&gt; lists=query.list(); 排序查询 12//默认asc，可以加desc降序List&lt;Customer&gt; list=session.createQuery(&quot;from Customer order by cust_id&quot;).list(); 1.1.3.2HQL的条件查询 按位置绑定参数 123456Query query = session.createQuery(&quot;from Customer where cust_name=? and cust_id=?&quot;);query.setParameter(0,&quot;...&quot;);query.setParameter(1,&quot;...&quot;);List&lt;Customer&gt; lists=query.list();//如果确定一条结果可以用Customer customer=(Customer) query.uniqueResult(); 按名称绑定参数 123456Query query = session.createQuery(&quot;from Customer where cust_name=:name and cust_id=:id&quot;);query.setParameter(&quot;name&quot;,&quot;...&quot;);query.setParameter(&quot;id&quot;,&quot;...&quot;);List&lt;Customer&gt; lists=query.list();//如果确定一条结果可以用Customer customer=(Customer) query.uniqueResult(); 1.1.3.3HQL的分页查询1234Query query = session.createQuery(&quot;from LinkMan&quot;);query.setFirstResult(0);query.setMAxResults(10);List&lt;LinkMan&gt; lists=query.list(); 1.1.3.4HQL的投影查询 查询所有的名字 12Query query = session.createQuery(&quot;select cust_name from Customer&quot;);List&lt;String&gt; names=query.list(); 查询所有客户的id和名称 12345Query query = session.createQuery(&quot;select cust_id,cust_name from Customer&quot;);List&lt;Object[]&gt; lists=query.list();for(Object[] objects : list)&#123; System.out.println(Arrays.toString(objects));&#125; 构造查询,现在实体类中写出相应的构造方法//不要忘了加无参构造 12Query query = session.createQuery(&quot;select new Customer(cyst_id,cust_name) from Customer&quot;);List&lt;Customer&gt; lists=query.list(); 1.1.3.5HQL的分组统计查询 统计个数 12Query query = session.createQuery(&quot;select count(*) from Customer&quot;);Long count=query.uniqueResult(); 按名称分组统计 12345Query query = session.createQuery(&quot;select cust_name,count(*) from Customer group by cust_name&quot;);List&lt;Object[]&gt; lists=query.list();for(Object[] objects : list)&#123; System.out.println(Arrays.toString(objects));&#125; 按姓氏的名称统计个数 123456Query query = session.createQuery(&quot;select cust_name,count(*) from Customer where cust_name like ? group by cust_name&quot;);query.setParameter(0,&quot;郝%&quot;);List&lt;Object[]&gt; lists=query.list();for(Object[] objects : list)&#123; System.out.println(Arrays.toString(objects));&#125; 1.1.4QBC 检索：通过Criteria对象进行检索1.1.4.1基本查询12Criteria criteria=session.createCriteria(Customer.class);List&lt;Customer&gt; list=criteria.list(); 1.1.4.2排序查询123Criteria criteria=session.createCriteria(Customer.class);criteria.addOrder(Order.asc(&quot;cust_id&quot;)); //倒序换为desc即可List&lt;Customer&gt; list=criteria.list(); 1.1.4.3条件查询1Criteria criteria=session.createCriteria(Customer.class); crteria.add(Restrictions.下边的值()); 1234567891011 == eq &gt; gt great than &gt;= ge great equal &lt; lt less than &lt;= le less equal &lt;&gt; ne not equallike 模糊查询like模糊查询还有一种方式//MatchMode.START指的是前面的字在哪个位置crteria.add(Restrictions.like(&quot;cust_name&quot;,&quot;郝&quot;，MatchMode.START)); //crteria.add(Restrictions.。。 可以写多个，相当于and 1.1.4.4分页查询12345Criteria criteria=session.createCriteria(Customer.class);crteria.add(Restrictions.like(&quot;cust_name&quot;,&quot;郝&quot;));crteria.setFirstResult(2);crteria.setMaxResult(2);List&lt;Customer&gt; lists=criteria.list(); 1.1.4.5统计查询setProjection 是单独值，用来设置聚集函数 123Criteria criteria=session.createCriteria(Customer.class);crteria.setProjection(Projections.rowCount());Object result=criteria.uniqueResult(); 1.1.4.6离线查询 DetachedCriteria这个对象可以前期脱离session来使用，后期再绑定session。所以可以在web层中封装好一个DetachedCriteria对象，然后传到dao中，在调用getExecutableCriteria(session); 获取一个Criteria对象使用 1.1.5SQL检索 ：通过输入SQL语句进行检索1.2 多表查询1.2.1 SQL中连接查询1.2.2 HQL中的连接查询sql连接 交叉连接 内连接 隐式内连接，显式内连接 迫切内连接fetch可以通知Hibernate，把结果封装成一个customer对象，包括集合 但是有一个问题：封装对象的时候会有重复的对象，所以要去重 外连接 左外连接 右外连接 迫切外连接跟内连接一样加一个 fetch 2.Hibernate的抓取策略2.1Hibernate延迟加载机制 延迟加载(懒加载 lazy):指的是，当执行到这行操作的时候，不会马上与数据库进行交互，等到真正使用该对象的属性的时候，才会发送sql语句进行查询。 2.1.1类级别的延迟加载类级别的延迟加载：查询某个类(对象)的时候，这个对象是否采用延迟。主要体现在使用load方法查询某个对象的时候，这个对象是否采用了延迟加载(默认使用延迟加载) 使类级别的延迟加载失效，跟get的效果一样： 在实体类中加final 在配置文件中的class标签上设置lazy属性为false 2.1.2 关联级别的延迟加载关联级别的延迟加载：查询某个类以后，查询这个类的关联的对象的时候，关联对象是否采用延迟，默认为true是延迟加载。 使关联级别的延迟加载失效： 在实体类中加final 在配置文件中的set标签上设置lazy属性为false lazy上还有一个值 extra，只是在关联级别有，及其懒惰，要什么只查什么。 2.2Hibernate的抓取策略(关联关系上配置fetch属性)抓取策略：用来查询到一个对象之后抓取其关联对象。 2.2.1set上的fetch和lazy：fetch控制的SQL语句的格式：lazy控制关联对象是否一致被查询 set集合上配置fetch属性： select 默认值，普通的select查询语句 join 会发送一条迫切连接，将关联的信息一起查询出来，所以此时lazy会失效 subselect 子查询 ，用 in set集合上配置lazy属性： true 默认值，延迟加载 false 不使用延迟加载 extra 及其懒惰 一般情况下就用默认的，但是如果经常一查多的一方，可以fetch用join 2.2.2 many-to-one 上的fetch和lazy： many-to-one集合上配置fetch属性： select 默认值，普通的select查询语句 join 会发送一条迫切连接，将关联的信息一起查询出来，所以此时lazy会失效 many-to-one集合上配置lazy属性： proxy 默认值，具体的取值取决于一的一方的类的fetch的值 false 不使用延迟加载 no-proxy 一般情况下就用默认的 2.3批量抓取 本来是先查所有，在一个一个查查三个 发四条语句 在set上加一个batch-size=&quot;3&quot;; 一下查三个，共发2条语句 在many-to-one上没有batch-size，需要时要在一的一方的class上配]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hibernate第三阶段]]></title>
      <url>%2F2016%2F05%2F15%2FHibernate03%2F</url>
      <content type="text"><![CDATA[Hibernate1.Hibernate 的一对多的映射1.1表关系的分析与创建一对一：创建唯一外键约束，或唯一主键约束一对多：在多的一方创建外键多对多：创建中间表 1.2Hibernate 一对多的关系的映射 基本环境搭建 建持久类 在一的一方 放一个多的一方的set集合 在多的一方 放入一的一方的对象 建立两个关系映射文件 在多的一方：配&lt;many-to-one name=&quot;&quot; class=&quot;&quot; column=&quot;&quot;/&gt; name：关联的一的一方的对象的属性名称 class：关联的一的一方的全路径 column：关联的是表中的外键的名称 在一的一方：配&lt;set name=&quot;&quot; &gt; &lt;key column=&quot;&quot;/&gt; &lt;one-to-many class=&quot;&quot;&gt; &lt;/set&gt; name:关联的多的一方的set集合的属性名称 column：关联的是多的一方的外键的名称 class:关联的多的一方的全路径 在核心配置文件，引入两个映射配置文件 多的： 1234&lt;many-to-one name=&quot;customer&quot; cascade=&quot;save-update&quot; column=&quot;lkm_cust_id&quot; class=&quot;com.hibernate.domain.Customer&quot; &gt;&lt;/many-to-one&gt; 一的： 12345&lt;set name=&quot;linkmans&quot; inverse=&quot;true&quot; cascade=&quot;save-update&quot;&gt; &lt;key column=&quot;lkm_cust_id&quot;&gt;&lt;/key&gt; &lt;one-to-many class=&quot;com.hibernate.domain.Linkman&quot;/&gt; &lt;/set&gt; 1.3编写一对多的测试代码1.3.1保存 如果只保存一个，就会出现瞬时对象异常（TransientObjectException）：持久态对象关联了一个瞬时态对象异常 解决这个问题就用到了一对多的级联： 级联保存：保存一边的时候，同时将另一边的对象或集合保存 只保存一的一方的时候：在&lt;set&gt;中配置一个cascade=&quot;save-update&quot;属性 只保存多的一方的时候：在&lt;many-to-one&gt;中配置一个cascade=&quot;save-update&quot;属性 1.3.2删除级联删除要先查询在删除，要不没法用。 删除一方的时候：如果单纯的只删除一的一方，会把多的一方的外键置为null 删除一的一方级联删除：在 &lt;set&gt; 中配置一个cascade=&quot;delete&quot;属性,会把本身跟通过外键关联它的数据都删除。 删除多的一方的时候：单纯的删，就只删除多的一方 删除多的一方级联删除：在&lt;many-to-one&gt;中配置一个cascade=&quot;delete&quot;属性,会把本身跟通过外键的数据都删除。 1.4双向维护关系产生多余的SQL 会产生两次更改外键的update语句，多余的sql。 为了避免这种问题，就通常要一的一方放弃外键的维护权，在映射配置文件里面的&lt;set&gt;标签上加一个inverse=&quot;true&quot;(默认是false) 事实上只能在一的一方加inverse inverse跟cascade的区别 cascade:代表的是级联操作，操作一个对象的时候，另一个对象是否跟着一块inverse:外键的维护，能不能操作外键 例：在customer映射文件中配置了inverse跟cascade则在建表的时候，两个表都会生成，但是linkMan中外键为null 2.Hibernate 的多对多的映射 两个持久化类中，都是用的set集合来关联的 在映射配置文件中配置 123456789101112131415161718//配置关联关系// set:标签//name:对方集合的属性名称//table:中间表的名称&lt;set name=&quot;students&quot; table=&quot;stu_cour&quot;&gt;//key:标签// column：当前对象在中间表外键名称。&lt;key column=&quot;cno&quot;/&gt;//many-to-many:标签// class:另一方类的全路径//column:另外一个类在中间表外键的名称&lt;many-to-many class=&quot;com.itheima.hibernate.domain.Student&quot; column=&quot;sno&quot;/&gt;&lt;/set&gt; 加载到核心配置文件中库 2.1保存 如果保存的时候，是双向保存，所以保存的时候，都会在中间表中插入相同的主键，会发生冲突，所以要在一方设置放弃外键约束 inverse（通常是被动放弃） 或者设置成级联保存，不要双向保存也可以 只保存一边是不行的：记得做级联操作。 2.2级联删除 主要就是操作关系的集合]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hibernate第二阶段]]></title>
      <url>%2F2016%2F05%2F12%2FHibernate02%2F</url>
      <content type="text"><![CDATA[Hibernate1.Hibernate 持久化类的编写1.1什么是持久化类持久化类：指的就是一个java类与数据库表建立了映射关系以后，这个类就称为是持久化类持久化类=java类+映射文件 1.2持久化类的编写规则 对持久化类提供无参数的构造方法：hibernate需要反射来创建持久化类的实例。（new instance 就能创建了） 对持久化类的属性私有化，对私有属性提供共有的get/set方法： 在持久化类中提供一个oid与表中的主键映射 编写的时候，属性最好使用包装类 持久化类尽量不要使用fianl修饰（延迟加载时，需要产生代理对象，这个代理对象使用javassist技术实现，就是产生一个子类对象，所以不能用final） 2.Hibernate的主键生成策略2.1区分自然主键和代理主键 自然主键：自然主键指定是建表的时候使用对象中本身属性作为表的主键。创建一个人员表，人会有身份证号，身份证号是唯一不可重复的，现在使用了身份证作为主键的话，属于自然主键。 代理主键：代理主键指的是没有使用对象中的自身的属性作为表的主键，使用与对象不相关的属性作为表的主键。创建一个人员表，人会有身份证号，没有使用身份证号，在建表的时候使用id字段作为表的主键。 建表的时候建议使用代理主键，自然主键有可能会参与到业务逻辑中。有可能出现重复或者有的时候可能需要修改，这个时候主键不能修改的，所以说自然主键不能使用了。 2.2Hibernate主键生成策略主键不应该由用户自己输入，应该有程序生成。Hibernate框架提供了很多主键生成的方式。 increment： 自动增长，使用的是Hibernate中提供的自动增长的机制。适用于short,int,long. Hibernated底层使用查询一下表中的主键的最大值，select max(cust_id) from customer;然后将这个值+1作为下一条记录的主键。会有并发访问问题。 identity： 自动增长，使用的是数据库的自动增长机制。适用于short,int,long,适用于有自动增长机制的数据库（MySQL，SQLServer），Oracle没有自动增长，不能使用identity。 sequence： 序列，使用的是序列的方式完成数据库的主键的生成。(Oracle，DB2这种数据库可以使用序列)。适用于short,int,long native : 本地策略，根据底层数据库不同,自动选择使用identity还是sequence适用于short,int，long uuid : 适用于字符串类型的主键，产生随机字符串作为表的主键。 assigned : Hibernate不管理主键，用户手动设置主键的值。 3.hibernate持久化类的三种状态hibernate为了更好的管理持久化类，将持久类分为三种状态： 瞬时态(Transient)：没有唯一标识OID，没有被session管理。 持久态(Persister)：有唯一标识OID，被session管理。 脱管态(Detached)：有唯一标识OID，没有被session管理。 3.1 持久态对象特殊能力：自动更新数据库： 3.2持久化类的三种状态转化 瞬时态： 获得：Customer customer=new Customer(); 状态转化： 瞬时—&gt;持久：save,saveOrUpdate 瞬时—&gt;脱管：customer.setCust_id(1); 持久态： 获得：get/load/find/iterate(都是查询) 状态转换： 持久—&gt;瞬时：delete 持久—&gt;脱管：close/clear(清空所有对象)/evict(清空一个对象) 脱管态： 获得：Customer customer=new Customer();customer.setCust_id(1); 状态转换： 脱管—&gt;持久：update/saveOrUpdate 脱管—&gt;瞬时：customer.setCust_id(null); 4.Hibernate的一级缓存4.1什么是缓存缓存是内存中的一块空间，提升性能存在。将数据源数据存入到内存中，再次获取的时候从缓存中获取，不需要进行查询的操作。 4.2什么是一级缓存Hibernate的性能相对来说是比较差的，里面提供了很多性能优化手段，其中缓存就是优化的一部分。 Hibernate共分为两个级别的缓存： 一级缓存：称为session级别的缓存。自带的，不可卸载的。 二级缓存：称为sessionFactory级别的缓存。需要配置的缓存的插件。 一级缓存是由Session中的一系列java集合组成，生命周期贯穿了整个session周期，可以说是一个session级别的缓存。 而且缓存的是对象的地址：（第二遍的时候根本就没查询） 4.3一级缓存的快照区session有缓存区(sess/persistenceContext/entitiesByKey/table/?/value)跟快照区(sess/persistenceContext/entityEntryContext/head/entity/loadedState)缓存即使变化，快照区一旦生成就不变化，直到事务结束之后。 当提交事务的时候，比对一级缓存区和快照区的数据是否一致。如果一致，不修改数据库，如果不一致，就会更新数据库。 4.4一级缓存的管理的方法 close clear：清空所有一级缓存 evict：清空单个缓存对象 5.Hibernate事务的管理5.1事务的回顾 什么是事务：指的是逻辑上的一组操作，组成这组操作的各个单元要么一起成功要么一起失败 特性： 原子性：事务是不可分割的 一致性：事务执行的前后，数据完整性保持一致。 隔离性：一个事务的执行不应该受到其他事务的干扰 持久性：一旦事务结束，持久到数据库中 问题： 读问题： 脏读：一个事务读到另一个事务未提交的事务。 不可重复读：一个事务读到另一个事务已提交的update的数据 虚读/幻读：一个事务读到另一个事务已提交的insert的数据 写问题： 丢失更新(事务提交)就是在多个更新操作同时运行时，数据库可能丢失前面更新的数据。 丢失更新(事务回滚) 解决读问题： 设置事务的隔离级别： 未提交读(read uncommitted):以上情况都有可能发生。 已提交读(read committed)：避免脏读，但是不可重复读和虚度都有可能发生。 可重复读(repeatable read):避免脏读和不可重复读，但是虚度有可能发生。 串行化的(serializable)：解决所有问题 解决写问题 悲观锁： 在get方法中添加排它锁Customer customer=session.get(Customer.class,1L,LockMode.UPGRADE); 这样在同时运行多个更新操作时，一个运行完了才能运行下一个。 乐观锁： 在实体上加一个版本号：Integer version， 在映射文件中配置标签version，名字写上实体中的版本号名字 每次执行操作修改操作的时候，版本号就会自动加一， 如果同时开启两个更新操作，版本号不一致会会报错 5.2hibernate的事务管理 设置事务的隔离级别： 1—Read uncommitted isolation 2—Read committed isolation 4—Repeatable read isolation 8—Serializable isolation 与线程绑定的session的使用：设置了这个属性后就可以用： session.getCurrentSession(); //表示从当前线程上获取session而且用这种当时获取的session，不用session.close(),因为线程结束之后会自动关闭。手动关闭会报错。 5.3hibernate事务的其他的api Query ：HQL查询HQL(Hibernate Query Language)：Hibernate查询语言，语法与SQL类似，面向对象的查询方式。 123456789101112131415//查询所有Query query=session.createQuery(&quot;from Customer(理论上是全路劲名的)&quot;);List&lt;Customer&gt; lists=query.list();//模糊查询Query query=session.createQuery(&quot;from Customer where cust_name like ?&quot;);//可以是setInteger，也可以是setParameter：表示任意类型query.setParameter(0,&quot;xx%&quot;);List&lt;Customer&gt; lists=query.list();//分页查询Query query=session.createQuery(&quot;from Customer&quot;);query.setFirstResult(0);query.setMaxResults(2);List&lt;Customer&gt; lists=query.list(); Criteria ： QBC查询QBC(Query By Criteria)：条件查询，更加面向对象的方式 1234567891011121314//查询全部Criteria criteria=session.createCriteria(Customer.class);List&lt;Customer&gt; lists=criteria.list();//条件查询Criteria criteria=session.createCriteria(Customer.class);criteria.add(Restrictions.。。。);List&lt;Customer&gt; lists=criteria.list();//分页查询Criteria criteria=session.createCriteria(Customer.class);criteria.setFirstResult(0);criteria.setMaxResults(2);List&lt;Customer&gt; lists=criteria.list(); SQLQuery ： SQL查询 1234567891011//原始SQLQuery sqlQuery = session.createSQLQuery(&quot;select * from cst_customer&quot;);List&lt;Object[]&gt; list=sqlQuery.list();for(Object[] objects : lists) &#123; System.out.println(Arrays.toString(objects));&#125;//进化SQLQuery sqlQuery = session.createSQLQuery(&quot;select * from cst_customer&quot;);sqlQuery.addEntry(Customer.class);List&lt;customer&gt; list=sqlQuery.list();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hibernate第一阶段]]></title>
      <url>%2F2016%2F05%2F10%2FHibernate01%2F</url>
      <content type="text"><![CDATA[Hibernate1.Hibernate的学习路线2.Hibernate的概述框架：就是一个=软件的半成品，完成部分功能 2.1什么是Hibernate是持久层的ORM框架 2.2什么是ORMHibernate是一个优秀的ORM实现框架 ORM(Object-Relational Mapping):对象关系映射 开发语言是java是面向对象 数据库是Mysql 是关系型数据库让java跟数据库中的表之间产生关系，直接操作对象就可以操作数据库 传统方式的不足 表中的字段获得类中的属性发生变化，DAO中的代码都要跟着发生变化（修改程序源代码） 2.3为什莫学习Hibernate： 3.Hibernate的入门3.1下载Hibernate的开发包解压之后： documentation：Hibernate的开发文档跟规范，还有一些测试的项目 lib：Hibernate的开发包，required是必须的，别的是可选的 product：一些相关的项目的源代码模板 3.2创建项目，引入jar包，日志文件引入required必须包，还有他要用到的数据库驱动包connection还需要log4j的jar包 slf4j 简单日志门面，是一个接口，log4j是整合日志的一个规范 可以把日志文件的配置文件引入log4j.properties打开配置文件，可以在最后边更改，从而设置日志信息打印在哪，默认是在控制台，可以加一个file打印在文件中，路径上面可以更改。 3.3创建表跟实体类3.4创建映射文件(ORM框架) 映射文件通常是一个XML文件，而且这个文件是可以任意命名。通常情况下名称：类名.hbm.xml创建约束：Hibernate 的核心包core下第一个后边位置，找到3.0 mapping的约束里面的123&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt; ，copy过去 建立类和表的映射123456789101112&lt;hibernate-mapping&gt; &lt;class name=&quot;实体类路劲&quot; table=&quot;表名&quot;&gt; &lt;id name=&quot;实体主键属性名&quot; column=&quot;表主键名&quot;&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; //普通属性与表中字段建立映射 &lt;property name=&quot;实体名&quot; column=&quot;属性名&quot; /&gt; //两个名字是一样的 &lt;property name=&quot;&quot; column=&quot;&quot; /&gt; &lt;property name=&quot;&quot; column=&quot;&quot; /&gt; 。。。 &lt;/class&gt;&lt;/hibernate-mapping&gt; 3.5创建核心配置文件连接哪个数据库 src下创建一个固定名称的xml hibernate.cfg.xml创建约束：project下etc下的hibernate.cfg.xml里面的约束copy过去，或者找Hibernate 的核心包core下第一个后边位置，找到3.0 configuration的约束dtd里面的约束两个是一样的 参数：project下etc下的hibernate.properties是模板，找到参数写123456789101112131415161718192021222324&lt;hibernate-configuration&gt; &lt;session-factory&gt; //连接数据库的基本参数 &lt;property name=&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;hibernate.connection.url&quot;&gt;jdbc:mysql///表名&lt;/property&gt; &lt;property name=&quot;hibernate.connection.username&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;hibernate.connection.password&quot;&gt;123&lt;/property&gt; // 配置hibernate的属性： //hibernate的方言：(也是在上面那个文件中找，mysql是这莫写) &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; //可以配置一些其他的属性 //打印出sql语句 &lt;property name=&quot;hibernate.show_sql&quot;&gt;true&lt;/property&gt; //格式化一下 &lt;property name=&quot;hibernate.format_sql&quot;&gt;true&lt;/property&gt; //hbm2ddl.auto:对应数据库的ddl操作：create,create-drop,update,validate &lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/property&gt; //加载映射文件 &lt;mapping resource=&quot;com/itheima/domain/...xml（**映射文件的路劲**中间是/并且以src下面的第一个包开头前面不加/）&quot; /&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 3.6使用Hibernate123456789101112131415//加载配置文件Configuration con=new Configuration().configure();//创建一个SessionFactory：类似连接池SessionFactory sess=con.buildSessionFactory();//创建一个Session：相当于ConnectionSession session=sess.openSession();//开启事务：Transaction tran=session.beginTransaction();//操作：Customer customer=new Customer();customer.setCust_name(&quot;要田间的属性名&quot;);//提交事务：transaction.commit();//释放资源：session.close(); 4.Hibernate 常见的配置4.1配置文件的配置映射文件：将对象与表建立映射关系。类名.hbm.xml 配置没有网的时候，编写配置文件的提示信息： 先复制，约束下边的路劲在window属性中找到xml catalog点 add 在找本地的dtd约束，引入，改为url，粘贴刚才复制的。 4.1.1class标签：建立类与表的映射 name：实体类的全路劲 table：数据库的表名（如果类名与表明相同，则table可以省略） catalog:写数据库名（可以不写） 4.1.2id标签： 用来表中的主键与类中属性建立映射 name ：类中的属性名 column：表中的字段名（如果属性名跟字段名一致则可以省略） type (从这个以下可以省略)：数据的类型(hibernate类型，java类型，数据库类型) 也可以这么写： 4.1.3property标签：表中的字段与类中的属性的映射跟id大同小异 length ：代表表中的长度（因为hibernate可以帮助你建表，默认设置为255） 4.2核心配置文件不能联网的时候配置一下，就可以提醒了 如果没有写在src底下，在加载的时候记得传一个路劲过去。 4.2.1分类 hibernate.properties 格式：key=value键值对的形式，但是不能加载映射文件。（手动写） 加载：Configuration con=new Configuration(); hibernate.cfg.xml 格式：格式化的格式 加载：Configuration con=new Configuration().configure(); 4.2.2内容 配置基本配置参数 其他参数 加载映射文件&lt;mapping resource=&quot;com/itheima.domain/...xml&quot; /&gt; hbm2ddl.auto参数（hibernate mapping to ddl）:对应数据库的ddl操作：（一般会使用update，validata，别的一般用作测试） create： 如果数据库有表，先删掉，重新创建一个新的表 create-drop：如果数据库有表，先删掉，重新创建，使用完毕，会删除该表（没有表也会创建使用完再删除） update：如果有表使用原来的表，没有则创建新表，并且可以更新，插入的时候没有字段创建一个新的字段 validate：如果没表则报错，有表使用原来的表，并对表进行校验（实体对象的属性跟表的字段不一样时会报错） 5.Hibernate的常用API5.1Configuration：配置对象5.1.2加载核心配置文件因为核心配置文件有两种书写方式。 hibernate.properties 格式：key=value键值对的形式，但是不能加载映射文件。（手动写） 加载：Configuration con=new Configuration(); hibernate.cfg.xml 格式：格式化的格式 加载：Configuration con=new Configuration().configure(); 5.1.3 加载映射配置文件如果不用配置文件来加载映射文件可以手动加载映射文件：(两种方法)Configuration.addResource(路劲...);//这种方法有一个条件，就是实体类跟配置文件在同一个包中Configuration.addClass(实体类名.class); 5.2 SessionFactory SessionFactory 对象内部维护了连接池和二级缓存（不讲）。是一个线程安全重量级的对象，所以说一般情况下，一个项目只对应一个SessionFactory。 所以一般把他单独抽出来。 5.2.1抽取一个工厂的工具类1234567891011private static final Configuration cfg;private static final SessionFactory sf;static&#123; cfg=new Configuration().config(); sf=cfg.buildSessionFactory();&#125;public static Session getSession()&#123; return sf.openSession();&#125; 5.2.2配置连接池Hibernate中自带了连接池，但是可以自己配置c3p0 引入c3p0相关的jar包，包括hibernate跟其整合的包，在lib中option中的c3p0中 配置核心配置文件：在session-factory中 1234567891011&lt;!-- 配置C3P0连接池 --&gt; &lt;property name=&quot;connection.provider_class&quot;&gt;org.hibernate.connection.C3P0ConnectionProvider&lt;/property&gt; &lt;!--在连接池中可用的数据库连接的最少数目 --&gt; &lt;property name=&quot;c3p0.min_size&quot;&gt;5&lt;/property&gt; &lt;!--在连接池中所有数据库连接的最大数目 --&gt; &lt;property name=&quot;c3p0.max_size&quot;&gt;20&lt;/property&gt; &lt;!--设定数据库连接的过期时间,以秒为单位, 如果连接池中的某个数据库连接处于空闲状态的时间超过了timeout时间,就会从连接池中清除 --&gt; &lt;property name=&quot;c3p0.timeout&quot;&gt;120&lt;/property&gt; &lt;!--每3000秒检查所有连接池中的空闲连接 以秒为单位--&gt; &lt;property name=&quot;c3p0.idle_test_period&quot;&gt;3000&lt;/property&gt; 5.3session（完成基本的CRUD的操作）Session session=sessionFactory.openSession(); 相当于JDBC中的connection，生命周期是以事务的开始跟结束为界限 不是线程安全的，所以最好定义成局部变量 是数据库核心对象 5.3.1savesave方法中： 先查询在，修改对象里面的东西，save跟update的效果是一样的 新建一个对象，然后设置id跟其他的值后save，只要主键生成策略不是assigned，那么则不用手动设置id，设置了也没用 5.3.2查询get/load get: 查询一个：get(实体类的class,数据库id); //这里的id在实体里用的long型，所以加L Customer customer=sess.get(Customer.class, 1l); load 查询一个：load(实体类的class,数据库id); Customer customer=sess.load(Customer.class, 1l); 重要 **get跟load的区别：** 加载时间 get方法：当程序执行到这行的时候，马上发送一条sql语句，返回Customer的对象 load方法：当程序执行到这行的时候，没有马上发送sql语句(使用的是Hibernate中延迟加载的策略lazy，真正使用该对象的时候才会加载)（使用的时候才执行，不用根本不加载，只用id也不行，因为人家已经知道了） 返回值 load返回的实体类的代理对象 get返回实体类本身 查询找不到的对象 load抛出ObjectNotFoundException get 返回一个null，或报空指针 5.3.3 update修改 先创建对象在修改 先查询在修改 5.3.4 delete删除 直接创建对象 然后删除 先查询在删除(推荐，为以后的级联删除方便) 5.3.5 saveOrUpdate 保存或更新没有id即保存，有id即更新 5.3.6 查询全部HQL：Hibernate Query LanguageQuery query=session.createQuery(&quot;from Customer&quot;); List&lt;Customer&gt; lists=query.list(); 5.4 Transaction 事务操作beginTranscction（）； //开启事务commit（）； //提交事务 注：hibernate5中有一个特性，就是会自动提交，前提是必须使用内置的连接池，但是为了低版本跟防止多事务提交出现错误，一般都要手动提交]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Redis]]></title>
      <url>%2F2016%2F03%2F18%2FRedis%2F</url>
      <content type="text"><![CDATA[RedisNoSQL什么是NoSQLNoSQL(NoSQL=Not Only SQL) 意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。 为什么需要NoSQL High performance 对数据库高并发读写的需求 Huge Storage 对海量数据的高效率存储和访问的需求 High Scalability&amp;&amp;High Availability 高并发 主流NoSQL产品 键值（Key-Value）存储数据库 相关产品：Toko Canbinet/Tyrant、Redis、Voldemort、Berkeley DB 典型应用：内容缓存，主要用于处理大量的高访问负载 数据模型：一系列键值对 优势：快速查询 劣势：存储的数据库缺少结构化 列存储数据库 文档存储数据库 图形存储数据库 NoSQL特点 易扩展 大数据量，高性能 灵活的数据模型 高可用 Redis什么事RedisRedis是C语言开发的一个开源的高效能键值对数据库。 目前为止Redis 支持的键值的数据类型如下： 字符串类型 散列类型 列表类型 集合类型 有序集合类型 Resis的安装yum是一个很强大的命令，安装c语言环境必须在有网的情况下 redis在Linux上的安装 redis编译的c环境，yum install gcc-c++ 将redis-2.6.16.tar.gz上传到Linux系统中 解压到/usr/local下 tar -xvf redis-2.6.16.tar.gz -C /usr/local 进入redis-2.6.16目录 使用make命令编译redis 在redis-2.6.16目录中 使用make PREFIX=/usr/local/redis install命令安装redis到/usr/local/redis中 拷贝redis-2.6.16中的redis.conf到安装目录redis中 启动redis 在bin下执行命令redis-server redis.conf 如需远程连接redis，需配置redis端口6379在linux防火墙中开发 12/sbin/iptables -I INPUT -p tcp --dport 6379 -j ACCEPT/etc/rc.d/init.d/iptables save 启动后看到如上欢迎页面，但此窗口不能关闭，窗口关闭就认为redis也关闭了(类Tomcat通过bin下的startup.bat的方式) 解决方案：可以通过修改配置文件 配置redis后台启动，即服务器启动了但不会占据控制台窗口 将redis.conf文件中的**daemonize**从no修改成yes表示后台启动 使用命令查看6379端口是否启动ps -ef | grep redis 正常关闭数据库向客户端发送shutdown，即：./redis-cli shutdown ,或关闭窗口也可以 | 使用java去操作Redis步骤： 12345//下载Redis的驱动包---就是一个jar包 该jar封装是java操作redis的api Jedis jedis=new Jedis(host,port); //post:redis所在的主机 // 端口号 jedis.set(&quot;age&quot;,&quot;28&quot;); 使用连接池： 12345678910//设置池子的配置对象，可以设置一些参数JedisPoolConfig config=new JedisPoolConfig();config.setMaxTotal(20);config.setMaxIdle(10);//创建一个池子JedisPool pool =new JedisPool(config ， host ， post);//从池子中获取资源Jedis jedis=pool.getResource();//操作jedis.set(key,value); 可以封装成一个工具类 123456789101112131415161718private static JedisPoolConfig config=null;private static JedisPool pool=null;static&#123; config =new JedispoolConfig; config.setMaxTotal(20); config.setMaxIdle(10); pool=new JedisPool(config ， host ， post);&#125;public static Jedis getJedis()&#123; Jedis jedis=pool.getResource(); return jedis;&#125;//关闭public static void close(Jedis jedis)&#123; if(jedis!=null)(&#123; jedis.close(); &#125;&#125; Redis的常用命令redis是一种高级的key-value的存储系统 其中的key是字符串类型，尽可能满足如下几点： key不要太长，最好不要操作1024个字节，这不仅会消耗内存还会降低查找效率 key不要太短，如果太短会降低key的可读性 在项目中，key最好有一个统一的命名规范（根据企业的需求） 我们对Redis的学习，主要是对数据的存储，下面将来学习各种Redis的数据类型的存储操作： 存储字符串string字符串类型是Redis中最为基础的数据存储类型，它在Redis中是二进制安全的，这便意味着该类型可以接受任何格式的数据，如JPEG图像数据或Json对象描述信息等。在Redis中字符串类型的Value最多可以容纳的数据长度是512M 基本 set key value：设定key持有指定的字符串value，如果该key存在则进行覆盖操作。总是返回”OK” get key：获取key的value。如果与该key关联的value不是String类型，redis将返回错误信息，因为get命令只能用于获取String value；如果该key不存在，返回null。 getset key value：先获取该key的值，然后在设置该key的值。 扩展 incr key：将指定的key的value原子性的递增1.如果该key不存在，其初始值为0，在incr之后其值为1。如果value的值不能转成整型，如hello，该操作将执行失败并返回相应的错误信息。 decr key：将指定的key的value原子性的递减1.如果该key不存在，其初始值为0，在incr之后其值为-1。如果value的值不能转成整型，如hello，该操作将执行失败并返回相应的错误信息。 incrby key increment：将指定的key的value原子性增加increment，如果该key不存在，器初始值为0，在incrby之后，该值为increment。如果该值不能转成整型，如hello则失败并返回错误信息 decrby key decrement：将指定的key的value原子性减少decrement，如果该key不存在，器初始值为0，在decrby之后，该值为decrement。如果该值不能转成整型，如hello则失败并返回错误信息 append key value：如果该key存在，则在原有的value后追加该值；如果该 key 不存在，则重新创建一个key/value 存储lists类型在Redis中，List类型是按照插入顺序排序的字符串链表。和数据结构中的普通链表一样，我们可以在其头部(left)和尾部(right)添加新的元素。 在插入时，如果该键并不存在，Redis将为该键创建一个新的链表。与此相反，如果链表中所有的元素均被移除，那么该键也将会被从数据库中删除。List中可以包含的最大元素数量是 4294967295。 从元素插入和删除的效率视角来看，如果我们是在链表的两头插入或删除元素，这将会是非常高效的操作，即使链表中已经存储了百万条记录，该操作也可以在常量时间内完成。然而需要说明的是，如果元素插入或删除操作是作用于链表中间，那将会是非常低效的。 lpush key value1 value2...：在指定的key所关联的list的头部插入所有的 values，如果该key不存在，该命令在插入的之前创建一个与该key关联的空链表，之后再向该链表的头部插入数据。插入成功，返回元素的个数。 rpush key value1、value2…：在该list的尾部添加元素 lrange key start end：获取链表中从start到end的元素的值，start、end可为负数，若为-1则表示链表尾部的元素，-2则表示倒数第二个，依次类推… lpushx key value：仅当参数中指定的key存在时（如果与key管理的list中没有值时，则该key是不存在的）在指定的key所关联的list的头部插入value。 rpushx key value：在该list的尾部添加元素 lpop key：返回并弹出指定的key关联的链表中的第一个元素，即头部元素。 rpop key：从尾部弹出元素。 rpoplpush resource destination：将链表中的尾部元素弹出并添加到头部 llen key：返回指定的key关联的链表中的元素的数量。 lset key index value：设置链表中的index的脚标的元素值，0代表链表的头元素，-1代表链表的尾元素。 lrem key count value：删除count个值为value的元素，如果count大于0，从头向尾遍历并删除count个值为value的元素，如果count小于0，则从尾向头遍历并删除。如果count等于0，则删除链表中所有等于value的元素。 linsert key before|after pivot value：在pivot元素前或者后插入value这个元素。 存储sets类型在Redis中，我们可以将Set类型看作为没有排序的字符集合，和List类型一样，我们也可以在该类型的数据值上执行添加、删除或判断某一元素是否存在等操作。需要说明的是，这些操作的时间是常量时间。Set可包含的最大元素数是4294967295。和List类型不同的是，Set集合中不允许出现重复的元素。和List类型相比，Set类型在功能上还存在着一个非常重要的特性，即在服务器端完成多个Sets之间的聚合计算操作，如unions、intersections和differences。由于这些操作均在服务端完成，因此效率极高，而且也节省了大量的网络IO开销 基本 sadd key value1、value2…：向set中添加数据，如果该key的值已有则不会重复添加 smembers key：获取set中所有的成员 scard key：获取set中成员的数量 sismember key member：判断参数中指定的成员是否在该set中， 1表示存在， 0表示不存在或者该key本身就不存在 srem key member1、member2…：删除set中指定的成员 扩展 srandmember key：随机返回set中的一个成员 sdiff sdiff key1 key2：返回key1与key2中相差的成员，而且与key的顺序有关。即返回差集。 sdiffstore destination key1 key2：将key1、key2相差的成员存储在destination上 交并集操作 sinter key[key1,key2…]：返回交集。 sinterstore destination key1 key2：将返回的交集存储在destination上 sunion key1、key2：返回并集。 sunionstore destination key1 key2：将返回的并集存储在destination上 存储sortedsetSorted-Sets和Sets类型极为相似，它们都是字符串的集合，都不允许重复的成员出现在一个Set中。它们之间的主要差别是Sorted-Sets中的每一个成员都会有一个分数(score)与之关联，Redis正是通过分数来为集合中的成员进行从小到大的排序。然而需要额外指出的是，尽管Sorted-Sets中的成员必须是唯一的，但是分数(score)却是可以重复的。 在Sorted-Set中添加、删除或更新一个成员都是非常快速的操作，其时间复杂度为 集合中成员数量的对数。由于Sorted-Sets中的成员在集合中的位置是有序的，因此， 即便是访问位于集合中部的成员也仍然是非常高效的。事实上，Redis所具有的这一 特征在很多其它类型的数据库中是很难实现的，换句话说，在该点上要想达到和Redis 同样的高效，在其它数据库中进行建模是非常困难的。例如：游戏排名、微博热点话题等使用场景。 基本 zadd key score member score2 member2 …：将所有成员以及该成员的 分数存放到sorted-set中 zcard key：获取集合中的成员数量 zcount key min max：获取分数在[min,max]之间的成员的数量 zincrby key increment member：设置指定成员的增加的分数。 zrange key start end [withscores]：获取集合中脚标为start-end的成员，[withscores]参数表明返回的成员包含其分数。 zrangebyscore key min max [withscores] [limit offset count]：返回分数在[min,max]的成员并按照分数从低到高排序。[withscores]：显示分数；[limit offset count]：offset，表明从脚标为offset的元素开始并返回count个成员。 zrank key member：返回成员在集合中的位置。 zrem key member[member…]：移除集合中指定的成员，可以指定多个成员。 zscore key member：返回指定成员的分数 存储hashRedis中的Hashes类型可以看成具有String Key和String Value的map容器。所以该类型非常适合于存储值对象的信息。如Username、Password和Age等。如果 Hash中包含很少的字段，那么该类型的数据也将仅占用很少的磁盘空间。每一个Hash 可以存储4294967295个键值对。 hset key field value：为指定的key设定field/value对（键值对）。 hgetall key：获取key中的所有filed-vaule hget key field：返回指定的key中的field的值 hmset key fields：设置key中的多个filed/value hmget key fileds：获取key中的多个filed的值 hexists key field：判断指定的key中的filed是否存在 hlen key：获取key所包含的field的数量 hincrby key field increment：设置key中filed的值增加increment，如：age增加20 没有减少的命令，要想减少就用加上负数 keys的通用操作 keys pattern:获取所有与pattern匹配的key， 表示任意一个或多个 ？表示任意一个字符 del key1 key2:删除指定的key exits:判断该key是否存在 1 表示存在 0表示不存在 rename key newkey:为当前的key重命名 expire key:设置过期时间，单位：秒 ttl key:获取所剩的超时时间，如果没有设置超时，返回-1，如果返回-2表示超时不存在 type key:获取指定的key的类型，以字符串形式输出 string, list,set,hash,zset 如果不存在返回true Redis特性多数据库一个redis实例最多可以提供16个数据库，下标0到15，客户端默认连接第0号数据库，也可以通过select选择哪个数据库 select 1： 选择1号数据库 move newkey 1 :将当前的数据库移植到1号数据库 服务器命令 ping 测试链接是否存活 echo 在命令行打印一些内容 select 选择数据库 quit 退出连接 dbsize 返回key数目 info 获取服务器的信息和统计 flushdb 删除当前选择数据库中的所有key flushall 删除所有数据库中的key 消息订阅与发布 subscribe channel:订阅频道 psubscribe channel* :批量订阅频道 *表示为任意数量跟值 publish channel content:在指定的频道发布消息 channel表示频道，content表示消息 事务 MULTI：开启事务，其执行后的命令都会存入命令队列中，直到EXEC EXEC: 提交事务 DISCARD: 回滚 注：redis的事务跟关系型事务的不同之处是，不管有没有报错都会全部执行完毕，所以我觉得说是批处理更好一些 持久化1.RDB(默认支持无序配置) 该机制是指在指定的时间间隔内将内存中的数据集快照写入磁盘 优势：性能最大化，是将整个redis存到一个文件中，作为备份方便劣势：可用性低，容易丢失数据，文件过大可能导致停机 保存位置：配置文件中的 dbfilename dump.rdb 2.AFO 启动AOF持久化：配置文件中改appendonly no成yes 优势：安全性高，包含一个格式清晰的日志文件，方便数据重建劣势：AOF文件一般大于RDB，效率低 改变策略： redis在服务器中的访问过程：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[reflect]]></title>
      <url>%2F2016%2F03%2F08%2Freflect%2F</url>
      <content type="text"><![CDATA[反射技术什么是反射技术，作用是什么java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方 法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信 息以及动态 调用对象的方法的功能称为java语言的反射机制。 反射技术的API 通过反射获得类的字节码对象 获得运行时的java的字节码对象Class的方式有三种： 通过对象获得：obj.getClass(); 通过类名获得：className.class 通过类的全限定名获得：Class.forName(类的全限定名); 获得字节码对象Class之后，可以通过某人无参的构造方法创建对象newInstance() Class对象有一个获得加载该字节码文件的类加载器的方法ClassLoader loader = Class字节码对象.getClassLoader(); 通过反射获得构造方法 获得构造方法Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) 获得构造器后，可以通过构造器创建对象：T newInstance(Object... initargs) 通过反射获得字段 获得字段Field getField(String name) 获得字段内容Object get(Object obj) 设置字段内容set(Object obj, Object value) 通过反射获得方法 获得方法Method getMethod(String name, Class&lt;?&gt;... parameterTypes) 执行该方法method.invoke(Object obj, Object... args) 反射的实际应用场景 Spring框架是层与层直接解耦的“神器”，例如：我们不必在Service中使用new Dao 的方式创建Dao对象，那样具体的Dao实现就与Service层耦合死了，我们可以通过 工厂+反射+XML配置的方式降低层与层之间的耦合性 Service层代码： dao层代码： 使用工厂+反射+配置文件方式进行解耦 在src下编写配置文件bean.xml 创建bean工厂用来创建实体对象 修改service的代码 总结：我们可以所以切换bean.xml中的class实现类的地址而无需修改java代码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux]]></title>
      <url>%2F2016%2F03%2F07%2FLinux%2F</url>
      <content type="text"><![CDATA[Linux基础Linux的概述Linux是由Linus Torvalds（林纳斯·托瓦兹）起初开发的，由于源代码的开放性，现在已经衍生出了千上百种不同的Linux系统。 Android底层就是运行在Linux上的 Linux的分类linux根据市场需求不同，基本分为两个方向： 图行化界面版：注重用户体验，类似window操作系统，但目前成熟度不够 服务器版：没有好看的界面，是以在控制台窗口中输入命令操作系统的，类似于DOS，是我们架设服务器的最佳选择 Linux根据原生程度，又分为两种 内核版本：在Linus领导下的内核小组开发维护的系统内核的版本号 发行版本：一些组织或公司在内核版基础上进行二次开发而重新发行的版本 Linux发行版本不同，又可分为： ubuntu:注重用户界面 CentOS:免费，企业用的特别多 redhat 中标麒麟，红旗 （国产） 虚拟机的安装虚拟机分类 VMware（威睿）公司的虚拟机软件，功能强大，收费 VitrualBox虚拟机软件，Orale公司的虚拟机软件，免费商品 Linux的安装Linux的目录结构图 常用命令 基本命令 cd cd usr 切换到该目录下的usr cd ../ 换到上一目录 cd / 切换到跟目录 cd ` 切换到用户主目录 cd - 切换到上一个目录 查找 ls 展示目录列表 可以加参数 -l 表示列表详细信息 ls -l 可以简写成ll 加 -a 表示隐藏文件 也可以加 -la find 目录 参数 文件名称 搜索 find /root -name &#39;text*&#39; 搜目录下的文件名开头是text的文件(递归查找即找所有的文件) 增删改 mkdir 文件夹名 创建文件夹 mv aaa bbb 把aaa重命名为bbb mv全名是move mv可以对一切数据类型的文件重命名（文件，压缩包…） mv 目录名称 目录新的位置 剪切 mv可以对一切数据类型的文件剪切（文件，压缩包…） cp -r 文件名称 新的目标目录 复制，-r 表示递归 rm -rf 要删除的目录名 删除，-r 表示递归 -f 表示强迫(没有提示) 查看文件 touch 文件 创建文件 cat 文件名 查看文件内容,但是只能显示一页 more 文件名 可以查看文件，显示第一页，然后按空格显示下一页，回车显示下一行，按q退出 less 文件 可以查看文件，显示第一页，按pgup显示上一页，pgdn显示下一页 tail -num 可以查看文件的后num行 tail -f 可以动态查看文件 修改文件的内容(改) 为文件添加或修改内容 vim 是vi的升级版 vim 文件名 进到文件中编辑，此刻是命令模式（不能编辑），按 i 或 a 或 o进入编辑模式，编辑完之后，在点esc退出到命令模式，点 : 变成底行模式 底行模式下，wq 保存并退出， q! 退出不保存 解压跟压缩 打包并压缩文件 tar -zcvf 打包后的文件名 要打包的文件 Linux压缩文件一般是这种形式：xxx.tar.gz z：调用gzip压缩命令进行压缩 c：打包文件 v：显示运行过程 f：指定文件名 解压 tar -xvf 要解压的文件 tar -xvf 要解压的文件 -C 目录 把压缩包解压到指定的位置 权限 ll 查看列表之后的第一列表示权限 文件的类型： d：代表目录 -：代表文件 l：代表链接（可以认为是window中的快捷方式） 后面的9位分为3组，每3位置一组，分别代表属主的权限，与当前用户同组的用户的权限，其他用户的权限 r：代表权限是可读，r也可以用数字4表示 w：代表权限是可写，w也可以用数字2表示 x：代表权限是可执行，x也可以用数字1表示 修改文件/目录的权限的命令：chmod例如：chmod u=rwx,g=rw,o=r aaa.txt 还可以用数字表示：因为三个权限不同组合的数字肯定是不一样的 其他 pwd 查看当前所在的工作目录 ps -ef 查看当前进程 （第二列是端口号） kill 结束某一个进程 搜索命令： grep 要搜索的关键字 要搜索的文件 --color //加color表示要关键字高亮 管道命令： | 将前一个命令的结果作为下一个命令的输入 ifconfig 查看端口 netstat-an8.reboot重启 halt关机 注意： 按tab键可以自动补全要输入的文件名，前提是文件夹中有你想输入的 linux中没有扩展名，扩展名只是为了阅读方便 Ctrl + c 表示强制退出 ./代表当前文件夹下的所有内容 Linux安全性的一个体现在他的端口不是随意更改的一般为22 当某个命令不会用的时候，用 –help 显示提示信息 前面加 . 表示隐藏文件 远程连接工具的使用关于远程工具乱码的解决： 使用远程工具进行连接时，如果linux有中文文件或目录，显示时会出现乱码，原因是linux编码是UTF-8，而远程工具默认是当前系统本地编码即GBK。所以解决方案是统一两者编码就OK了，但是该SSH Secure工具不能设置编码，所以通过修改linux的系统编码的方式进行统一编码。 - 配置文件中改，进入配置文件夹**etc** - 进入cd sysconfig/ - 其中有一个 `i18n` 进入 vim i18n 再改GBK Linux的软件的安装rpm与软件相关的命令，相当于window下的软件助手 JDK的安装 查看当前Linux系统是否已经安装java输入rpm -qa | grep java 卸载两个openJDK输入rpm -e --nodeps 要卸载的软件 上传jdk到linux 解压jdk到/usr/local下 tar –xvf jdk-7u71-linux-i586.tar.gz –C /usr/local 配置jdk环境变量，打开/etc/profile配置文件，将下面配置拷贝进去 12345set java environmentJAVA_HOME=/usr/local/jdk1.7.0_71CLASSPATH=.:$JAVA_HOME/lib.tools.jarPATH=$JAVA_HOME/bin:$PATHexport JAVA_HOME CLASSPATH PATH 重新加载/etc/profile配置文件 source /etc/profile Mysql的安装1.查看CentOS自带的mysql 输入 rpm -qa | grep mysql 2.将自带的mysql卸载 3.上传Mysql到linux4.解压Mysql到/usr/local/下的mysql目录(mysql目录需要手动创建)内 cd /usr/local mkdir mysql tar -xvf MySQL-5.6.22-1.el6.i686.rpm- bundle.tar -C /usr/local/mysql会解压成几个.rpm文件，相当于window的.exe文件5.在/usr/local/mysql下安装mysql安装服务器端：rpm -ivh MySQL-server-5.6.22-1.el6.i686.rpm安装客户端：rpm -ivh MySQL-client-5.6.22-1.el6.i686.rpm6.启动mysqlservice mysql start7.将mysql加到系统服务中并设置开机启动加入到系统服务：chkconfig --add mysql自动启动：chkconfig mysql on8.登录mysqlmysql安装好后会生成一个临时随机密码，存储位置在/root/.mysql_secretmsyql –u root -p9.修改mysql的密码set password = password(&#39;root&#39;);10.开启mysql的远程登录默认情况下mysql为安全起见，不支持远程登录mysql，所以需要设置开启 远程登录mysql的权限登录mysql后输入如下命令：12grant all privileges on *.* to &apos;root&apos; @&apos;%&apos; identified by &apos;root&apos;;flush privileges; 11.开放Linux的对外访问的端口3306(重点) 12/sbin/iptables -I INPUT -p tcp --dport 3306 -j ACCEPT/etc/rc.d/init.d/iptables save ---将修改永久保存到防火墙中 Tomcat的安装 上传Tomcat到linux上 解压Tomcat到/usr/local下 开放Linux的对外访问的端口8080 12/sbin/iptables -I INPUT -p tcp --dport 8080 -j ACCEPT/etc/rc.d/init.d/iptables save 4.启动关闭Tomcat进入tomcat的bin下启动：./startup.sh进入tomcat的bin下关闭：./shutdown.sh Linux常用命令1.移动文件：mv [源文件] [目标文件]2.删除文件或目录：rm –d删除目录 –f强制删除 –r递归删除 [文件或目录名]3.修改文件或目录群组：chgrp –r递归 [群组] [文件或目录]4.修改文件或目录权限：chmod -r递归 [权限范围] [文件或目录]5.修改文件或目录拥有者：chown -r递归 [权限范围] [文件或目录]6.复制文件或目录：cp –f强制 –r递归 [源文件] [目标文件]7.切换目录：cd [目的目录]8.显示目录下文件：ls –a所有 –l详细格式列表 –r递归9.创建目录：mkdir –p如果上级目录没有建立则一并创建 [目录名称]10.显示当前绝对路径：pwd11.删除目录：rmdir –p删除后如果上级目录为空一并删除 [目录名称]12.变更用户身份：su [账户]13.以其它身份执行命令：sudo –u [账户] [指令]14.添加用户：adduser –g [群组] –e[权限] –u[账号]15.删除用户：userdel –f删除用户登录目录以及目录中的文件 [用户账户]16.Ubuntu初始化root: sudo passwd17.重启：reboot18.更改ip等网络设置：setup19.服务更改生效命令：service network restart20.关机：halt 查询tomcat的端口123456//先找出pidps -aux | grep tomcat//在根据pid找到端口netstat -naop | grep 15566//根据端口找到相应的信息netstat -nltp | grep 2181]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Eclipse配置集锦]]></title>
      <url>%2F2016%2F03%2F07%2FEclipse%E9%85%8D%E7%BD%AE%E9%9B%86%E9%94%A6%2F</url>
      <content type="text"><![CDATA[MyEclipse 2013 新工作空间设置设置编辑字体和大小 默认的样子很难看，特别中文字将很小 修改为：Courier New字体，字体大小9、10都行，根据自己喜欢。 设置JSP编码utf-8 设置项目编码utf-8 JRE环境 1.7 点击“add”按钮，新增自己安装的。不要使用默认的。 选择安装好的jdk。（之前已经安装好的jdk） 配置编译的JDK版本 配置完Installed JREs，进一步设置编译的版本 配置TOMCAT 7.0 选择之前安装好的tomcat7 修改D:\javaenv\apache-tomcat-7.0.26\conf\server.xml 增加80端口，访问方便，URL无需写端口 如果项目启动就报堆溢出错误 说明初始的JVM内存过少，修改配置 设置注释 设置Files为空，否则类里会空着几行 设置Types为 123456/** * @Description: * @Author: 陈子枢 * @Company: http://java.itcast.cn * @CreateDate: $&#123;date&#125; */ 创建maven工程后，改变配置 一般导入别人的工程，有时由于开发环境机器环境的差异会报错；做好的方法是：先在本地创建工程，将工程的文件拷贝到工程中。 修改其工程关联的JRE版本 修改编译版本 工程属性，中选择 MyEclipse2013 Maven支持 注意：早期myeclipse版本对maven支持不好，例如：8.x（8.5/8.6）版本创建maven工程爱出错；10.x（10.0/10.7）版本运行maven下的测试类报错。部署文件异常，配置文件、jar包可能突然无法发布到tomcat/webapps下，导致加载异常。 解决版本：版本升级或者使用web工程实现。Maven依赖后，发布工程时，jar直接就发布到webapps工程下的WEB-INF/lib中。 配置Maven插件 和eclipse不同，MyEclipse无需安装3个插件，它自带的有，只需启动即可。 自行下载安装apache-maven。自带的有BUG。 如果settings.xml文件变更，这里更新下。如果仓库文件覆盖之类，需要重新构建索引。 注意配置完，要执行一遍maven命令，例如: dos下mvn clear、mvn install因为maven命令也是jar，在第一次运行时会先自动下载。 maven下载依赖的jar包时同时下载源文件 默认是未选中，不会自动下载 maven仓库配置 默认仓库位置为C:\Users\ProBook\.m2 从D:\javaenv\apache-maven-3.0.5\conf复制settings.xml文件即可 将此目录默认为仓库目录，也就是说当maven下载jar时，会保存在此目录中，这不是一个好的方式，C盘重新安装系统时，有可能就误删除了仓库；可以改变仓库位置，但settings.xml无法改变。 修改maven仓库位置 例如修改D:\javaenv\mvnrepository这个目录 调整步骤： 修改C:\Users\ProBook\.m2\ settings.xml文件的46行配置，修改路径 `d:/javaenv/mvnrepository`` 配置MyEclipse的Maven设定 选择Update Settings后，如果之前使用了maven，会时间很长，先会更新依赖，再自动更新索引。状态栏上会有提示信息。 Myeclipse maven repository管理视图 可以重新构建本地仓库，远程仓库等的索引，一般不用。 如何获得坐标？ 方式一 ,有了索引，就可以在本地Add Deployment时，进行搜索，并查看坐标 可以输入strusts2，回车，查询core的jar包 选则后，自动插入其坐标（注意它是从哪里来？必须本地仓库中有，必须构建过索引） 方式二，搜索网站http://search.maven.org 可以在这个网站搜索 http://mvnrepository.com 坐标的scope 默认runtime，即maven会自动发布到WEB-INF/lib下，单有些jar是中间件环境中含有的，单在我们的开发测试环境没有的。这时scope设置为provided常见的包括下面两个jar包，tomcat中含有123456789101112&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 运行maven命令Maven build… 自己设置maven命令Maven build记住上次输入的maven命令 tomcat maven plugin12345678910111213141516171819&lt;!-- 早期tomcat maven plugin 使用 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;tomcat-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt; &lt;/plugin&gt;&lt;!-- tomcat plugin 后来分为tomcat6 和 tomcat7 两个插件 --&gt;&lt;!-- http://mojo.codehaus.org/tomcat-maven-plugin/index.html --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat6-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;/plugin&gt; ##常见错误 Maven创建Web时错误：Could not resolve archetype org.apache.maven.archetypes:maven-archetype-webap Maven配置中添加新的Catalog配置： http://repo1.maven.org/maven2/archetype-catalog.xml描述随便填写 MyEclipse 2013常用配置安装成功后，先别运行。先进行破解。破解前先要安装jdk。破解包要运行jar文件。 加大MyEclipse的内存大小 发布多个项目，或者项目比较庞大，部署时会直接报堆溢出 解决办法：修改 123C:\Users\ProBook\AppData\Local\MyEclipse Professional\ myeclipse.ini-Xmx1024m-XX:MaxPermSize=512m 或者创建快捷链接，修改快捷的启动参数 1D:\eclipse320\eclipse.exe -name Dabcd -nl en -vmargs -Xms128M -Xmx512M -XX:+UseParallelGC -XX:PermSize=64M -XX:MaxPermSize=128M -XX:MaxNewSize=32M -XX:NewSize=32M JVM初始分配的内存由-Xms指定，默认是物理内存的1/64；JVM最大分配的内存由-Xmx指定，默认是物理内存的1/4。默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制；空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制。因此服务器一般设置-Xms、-Xmx相等以避免在每次GC（垃圾收集器）后调整堆的大小。 优化MyEclipse，加速启动关闭无用的中间件 以MyEclipse EASIE开头的都是服务器，其中本人只保留如下： Tomcat 6或者7（必备） Weblogic 11 JSP Debug 其他功能插件看个人所需，如果不使用可以全部取消勾选。去除未使用的中间件 去掉校验检查 去掉所有的勾，不要校验。需要校验可以单独对一个文件进行校验。文件右键菜单。特别再导入一个工程时，或者clean工程时，如果有校验，将非常慢。 如何更改jsp默认的打开方式 修改xml的默认打开方式默认是可视化的，加载速度慢，对于编程高手，非常熟悉xml结构，直接修改文字 自定义工具栏，去掉无用工具按钮注意高版本无法自己定义，2013，2014工具栏空白处点鼠标右键 文件保存按钮，单个、批量保存 发布web工程，启动、停止web工程 文件夹浏览。选中工程目录，点击按钮可以直接打开一个目录窗口 打开类搜索窗口 项目报错，但看不到项目中哪个文件报错怎么办？ 菜单/Windw/Show View/Other…/General/Problems 查看当前项目 项目报Project configuration is not up-to-date with pom.xml错误如何解决？项目上点鼠标右键，弹出菜单，选择下面项执行即可 设置目录为原文件目录 在navigator视图下，新建目录config，存放配置文件这样发布后，会多一个config目录，我们要让类直接在classpath下方法，那就必须配置一下。注意在Navigator下，就不能直接设置。此时需要打开PackageExplorer视图。点击目录右键。 这样就完成了配置 新建Maven工程 注意这里spring eclipse可以跳过骨架，但myeclipse2013不行。它会创建完不是web工程，无法直接发布到tomcat下。 pom文件如何添加依赖http://search.maven.org 可以在这个网站搜索 添加jar包顺序： 添加核心内容 spring webmvc/orm/spring-text MyBatis 添加数据库 c3p0 mysql /oracle 添加子框架 shiro/cxf/ 常用 log4j/slf4j/junit 添加其他 poi 设置web发布到root下 工程属性中查询web，进行设置。去掉Web Context-root。留下一个斜杠，它就会发布到ROOT下。这样访问时URL无需写虚拟路径。 注意发布到ROOT下时，如果之前有ROOT目录。会提示。有时myeclipse会无法点击finish按钮。这是它的BUG。关掉myeclipse，去目录下直接删除ROOT目录。在启动myeclipse就可以正常发布了。 执行maven命令tomcat：run直接发布执行速度比myeclipse 2013的maven web 工程发布快 保证pom.xml中的项目名称、坐标名称、buildname和项目名称相同；有时从别的项目中考过来就沿用了之前的项目名称；这样启动后发布的工程就会导致错误 在Run as 中配置bulider…，填写上tomcat:run 注意：首次运行会下载对应的jar包 问题：用myeclipse管理发布web工程，下载时中文文件名正常；但用tomcat:run命令会乱码； 设置发布端口，默认tomcat的8080 DTD编辑XML文件时有节点提示联网情况下，dtd约束文件编写时会有节点提示。但不联网，无缓存过时。就没提示。可以手工配置。 先拷贝链接 增加自定义的提示配置 复制链接到KEY中，选择KEY TYPE为URI，浏览dtd文件。事先从jar包中解压出dtd文件。 XSD文件提示Spring非常方便，它将xsd从jar报中单独放出来一份，这样方便我们开发时配置： 选择xsd文件后，key type自动改变，然后选择Schema location即可这样当xml文件找xsd文件时，就先到这里找http…，配置后就通过key去找本地配置的文件 设置文件对应的编辑器 例如jsp的默认编辑器 导出工作空间配置 导出工作空间配置 设置保存目录 新建工作空间创建目录，菜单/File/Swite Workspace/Other 选择新的工作空间目录重启myeclipse，这样所有配置默认，被初始化。导入旧的配置 随着引入的jar、插件，这个目录会越来越大，一个工作空间就一份。把备份配置导入 安装插件 方式1： 方式2： 把plugins中的所有jar拷贝到eclipse的plugins文件夹之中 把features中的所有文件夹拷贝到eclipse的features文件夹之中 重启eclipse，ok Eclipse 4.4 luna / Spring eclipse 创建Web工程跟myeclipse不太相同，myeclipse叫Web Project 一步步next，最后一步要设置选择产生web.xml否则需要手动添加 发布项目 移除 创建MavenProject，选择 Tomcat安装后所在路径：D:\javawse\.metadata\.plugins\org.eclipse.wst.server.core\tmp0 发布到ROOT目录，eclipse自动在tomcat下的server.xml中新增虚拟路径不能手工设置，因为它会被eclipse自动修改 增加80端口，方便测试。必须保证本机没有被80端口占用。 Eclipse中配置tomcat和myeclipse不同，它是作为类似工程一样，需要创建的。 选择已经配置的Tomcat 选择要发布的项目，进行发布 启动Tomcat 配置文件提示 去除校验加快eclipse显示，去掉校验，否则在导入工程时超慢。 Maven配置 开发Maven工程建议直接使用最新版本的MyEclipse 2014，早期版本 8.6/10.0/10.6/10.7开发时都容易出现问题。常见错误主要有发布文件失灵。例如属性文件，jar包等突然就无法发布到webapps下。导致项目启动失败。原因是，早期maven插件bug所致。 Activit5 在线安装画图插件 弹出框中录入下面内容Name: Activiti BPMN 2.0 designerLocation: http://activiti.org/designer/update/ 需要近10分钟，耐心等待 Activit5工作流画图后自动保存为一个png图片 设置jsp页面编码为U8 设置工程编码为U8 当项目报错时，但无法找到报错文件。这时打开Window/Show View/Problems就可以看到。 项目属性当项目报下面错误时12Description Resource Path Location TypeProject configuration is not up-to-date with pom.xml. Run Maven4MyEclipse-&gt;Update Project or use Quick Fix. jk line 1 Maven Configuration Problem PowerDesinger 12.5基础配置修改name修改时code连动的情况菜单/Tools/General Options/Dialog选项去掉 Name to Code mirroring 前面的勾即可 配置直接显示备注字段选择倒数第二个沙漏，找到Comment打上前面的勾即可。 PowerDesinger 15.1连线配置 直角剪头的都设置为直线的，然后要点击Set as Default，否则下次创建新文件，剪头又变成直线的。 数据库表逆向工程powerDesigner功能非常强大，可以庁数据库，通过现有数据库来逆向工程，生成表模型 需要配置一个数据源，下面操作mysql新建数据源 创建配置 填写驱动的各个参数，选择驱动的jar包，然后测试 选择刚才设置的配置，连接 上面的过程配置一次即可。选择要逆向工程的数据库，选择要逆向的表，确定即可。先全取消，然后选择数据库，再全选；否则选取所有数据库的所有表 有些警告信息可以忽略 Oracle 11gPL/SQL初始化配置工具菜单/浏览器过滤器 PL/SQL创建数据库 Oracle和其它数据库不同，其它数据库是创建数据库，创建表，表是挂在数据库下的；而Oracle是创建用户，创建表，表是挂在用户下的。 创建用户 设置其访问权限 客户端配置本地服务注意sqlPlus可以直接访问，但程序，pl/sql需要配置本地服务后才可以访问 手工配置本地服务，安装目录下的admin/tnsnames.oraC:\app\ProBook\product\11.2.0\dbhome_1\NETWORK\ADMIN\listener.ora 配置侦听tnsnames.ora 配置本地服务 复制配置成功的，修改IP就可以访问其他数据库服务器 PL/SQL导入 dmp格式导入 sql格式导入 PL/SQL导出（备份） 导出dmp格式文件PL/SLQ/工具菜单/导出表/ 可以选择表，默认选择所有；PL/SQL是调用oracle的命令exp，导出.dmp文件（二进制）； 导出sql语句，和建表语句 数据库无需开机启动服务在不用时可以禁止开机时启动，这样需要时候，启动即可；不会在不用时多占开机时间和系统资源 MySQL5 Orace Express Edition (简装版本，开发测试使用，安装包小，启动快)EX安装完自动创建EX本地服务；完整安装版本不会自动创建本地服务，必须自己创建。安装完有两个服务，OracleService[SID],Oracel[SID]TNSLIstener手动将服务属性修改为手动，然后停止服务，这样开机就不会加载，用时，启动即可。 EX修改HTTP服务端口，避免和TOMCAT端口冲突Oracel默认会启动HTTP服务，占有端口8080，但一般8080时TOMCAT的配置端口可以修改TOMCAT的端口，也可以修改EX的端口 使用DBA账号登陆system/system； 执行下面语句； 1234begin dbms_xdb.setHTTPPort(&apos;8008&apos;); dbms_xdb.setftpport(&apos;0&apos;);end; 修改下面二个internet快捷方式(位于oraclexe安装目录的product\11.2.0\server下) 12X:\oraclexe\app\oracle\product\11.2.0\server\Get_Started.urlX:\oraclexe\app\oracle\product\11.2.0\server\Database_homepage.url 用记事本打开这二个文件，把8080换成8008http://localhost:8008/apex PL/SQL oracle数据库访问工具 在使用这个工具时，必须先利用oracle客户端自带的Net Assistant，创建oracle的本地服务，这样才可以访问服务器端数据库。 设置sql窗口的字体，默认字体过小工具&gt;首选项&gt;用户界面&gt;字体 Window基础快速查询系统变量例如查询系统的临时目录对应的目录在Window7的运行中输入%TEMP% 配置JAVA_HOME和PATH电脑属性 新建系统环境变量 加入到PATH中 打开服务窗口运行窗口中输入services.msc 启动服务cmd窗口中输入dos命令net start mysql –启动mysql服务 常见错误导入项目报错Java compiler level does not match the version of the installed Java project facet Web.xml早期自动产生的内容重复123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:web=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;2.5&quot;&gt;报错：org.xml.sax.SAXParseException; systemId: jndi:/localhost/activitiWorkflow/WEB-INF/web.xml; lineNumber: 5; columnNumber: 42; 已经为元素 &quot;web-app&quot; 指定属性 &quot;xmlns&quot;。原因头引用了两次xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; 解决办法：删除一个即可 导入别人项目时报错 错误是由于别人的项目和你的项目配置的jdk路径和版本有差异，导入时提示unbound。 解决办法：关联一下即可 中文乱码一般开发时先设置工程为UTF-8，JSP页面为UTF-8，这样减少乱码引起的问题 如果中文返回出现？？字符，这表明没有加response.setCharacterEncoding(“UTF-8”);这句话。 如果返回的中文是“烇湫”这种乱码，说明浏览器的解析问题，应该检查下是否忘加response.setHeader(“Content-type”, “text/html;charset=UTF-8”);这句话。 Myeclipse中配置tomcat后，启动报错 将项目部署好后，启动tomcat后报错，`java.lang.NoClassDefFoundError: org/apache/juli/logging/LogFactory `` 报这个错说明你用的是tomcat7。 解决方法 打开`myeclipse，Preferentces-&gt;MyEclipse-&gt;Servers-&gt;Tomcat-&gt;Tomcat 7.x `` ,载入Tomcat7，在&quot;Paths&quot;下，在Prepend to classpath后点击“Add JAR/ZIP”,加载tomcat7下的……/bin/tomcat-juli.jar。点击“OK”.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[markdown]]></title>
      <url>%2F2015%2F11%2F18%2Fmarkdown%2F</url>
      <content type="text"><![CDATA[代码之外的软技能1&gt;这是引用 Markdown Tutorial(教程)Introduction 是一个轻量级标记语言 最重要的设计是可读性高 Markdown 基本语法12#### 标题标题使用 **#** 号来书写，#号之后跟标题内容 标题在写的时候，要注意，#号之后一定要跟一个空格，标题与标题之间要有一个空行 粗体和斜体1**粗体** *斜体* ####无序列表 1234567Markdown中的无序列表对应的就是html中的ul标签- 在段落中写入英文的时候，要注意两边加上空格，为了保持格式清晰 - 子列表，在列表中回车tab就会生成子列表- 列表使用一个- 开头，接着空格，然后是列表的内容- 列表3 有序列表123456789101112Markdown中的无序列表对应的就是html中的ol标签1. 有序列表1 1. 子列表1 2. 子列表22. 有序列表23. 有序列表3有序列表是根据tab缩进来识别的跟前面的数字没关系有序列表中也可以嵌套无序列表 链接跟图片1234[百度一下](http://www.baidu.com/) ![图片](网络地址，马克飞象不支持本地地址) 代码引用行内引用1234反引号esc下边的那个`在这里，我们可以使用`var`关键字来声明一个变量。 #####多行引用 多行引用就是html中的pre 1 aaaaa sssss aasd asdasd asdasd 123```#### 表格 表格其实就是html中的table书写的时候，分为thead tbody 中间的分割线 编号 姓名 年龄 1 john 18 2 lucy 17 3 mark 19 12###Markdown总结 标题 # 段落 直接写 无序列表跟有序列表 无序列表- 有序列表 1. 粗体跟斜体 **粗体的内容** * 斜体的内容 * 链接跟图片 [链接要显示的内容](链接的地址) ![图片的alt](图片的链接地址) 文本引用 &gt; 引用内容 代码引用 行内引用 `引用内容` 多行引用 \1- 表格 注：html代码在Markdown中也可以解析。]]></content>
    </entry>

    
  
  
</search>
