<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[easyUI]]></title>
      <url>%2F2016%2F11%2F23%2FeasyUI%2F</url>
      <content type="text"><![CDATA[easyUI什么是EasyUI JQuery EasyUI 是一组基于Jquery的UI插件集合体，而JQuery EasyUI的目标就是帮助Web开发者更轻松的打造出功能丰富并且美观的UI界面。开发者不需要编写复杂的javaScript，也不需要对Css样式有深入的了解，开发者需要了解的只是一点简单的HTML的标签 界面效果 是用于后台界面的 使用准备 下载，解压 找到需要的相应的jar包(2个)，还有两个css 导入 locale plugins themes ,里面有相应的界面需要的css，js等 1234&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;../themes/default/easyui.css&quot;&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;../themes/icon.css&quot;&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/jquery.easyui.min.js&quot;&gt;&lt;/script&gt; 使用 使用EasyUI有两种方式(超链接来做示范) 使用标签的方式&lt;a href=&quot;#&quot; class=&quot;easy-linkbutton&quot; data-options=&quot;iconCls:&#39;icon-search&#39;&quot;&gt;超链接&lt;/a&gt; iconCls:代表图片 使用js 12345678910&lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; $(&quot;#btn&quot;).linkbutton(&#123; iconCls:&apos;icon-add&apos; &#125;); &#125;);&lt;/script&gt;&lt;a id=&quot;btn&quot; href=&quot;#&quot;&gt;超链接&lt;/a&gt; 注意使用的时候就不能在引入jquery的包了，要不显示不出来（自己测得，不知道对不对） EasyUI的组件EasyUI 的组件：LayOut(布局) 在LayOut上加EasyUI的属性:data-options=&quot;fit:true&quot; //表示适应父类 上面的各个布局可以删除 属性split:true表示可以变换大小 上面的文字，大小都可以改 EasyUI 的组件：Accordion（分类）Accordion 的概述分类空间允许用户使用多面板，但在同一时间只会显示一个。每个面板都内建支持展开和折叠功能。点击一个面板的标题将会展开或折叠面板主体。面板内容可以通过指定的href属性使用ajax方式读取面板内容，用户可以定义一个被选中的面板，如果未指定，那么第一个面板就是默认的 Accodion的使用 我们可以更改或修改面板的一些功能以后再重新创建它。1234//定义在展开和折叠的时候是否显示动画效果。 默认是有的$(&apos;#aa&apos;).accordion(&#123; animate:false&#125;); 布局嵌套分类可以达到想要的结果 EasyUI 的组件：Tabs（选项卡） 选项卡是可以关的，因为上面有一个属性是：data-options:&quot;closabled:true&quot; 可以点一个按钮创建一个新的选项卡 如果存在打开，不存在新建一个新的选项卡 可以在选项卡中放内容，这里用到了&lt;iframe src=&quot;&quot;&gt; ,只要一打开这个选项卡，iframe中就会加载src的路径，会向服务器请求内容 为了防止a标签中的地址自己也打开一个界面,可以在方法中加一个return false; EasyUI 的组件：Datagrid（数据表格） EasyUI 的组件：Window（窗口）属性设置为closed:true是关闭窗口并隐藏的，所以可以加一个事件来弹出窗口 窗口里放一个表单，可以把其变成Ajax方式提交，返回参数后还需要变为json对象 因为没有json的参数 所以将字符串转换为Json var jsonData=eval(&quot;(&quot;+data+&quot;)&quot;) 显示消息： slide滑动 修改：弹出的key跟转json的key相同就会数据回显 text-decoration:none; 这个标签的属性会让链接的文字没有下划线]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[oracle第一阶段]]></title>
      <url>%2F2016%2F10%2F23%2Foracle01%2F</url>
      <content type="text"><![CDATA[OracleOracle 介绍 Oracle 的安装 因为Oracle很娇气，一旦安装失败很难完全卸载干净，所以最好用虚拟机挂载xp镜像 固定虚拟机的ip地址,先自动获取ip然后查看ip记住，在手动固定一下，防止下次启动虚拟机的时候因为网络配置原因导致Oracle不可用 虚拟机上的网络适配器改为 nat ，意思是能上网，要想局域网共享服务就要设置为桥接模式 拷贝安装包，解压缩，安装oracle，确定右边，口令管理中找到scott，解锁scott用户，默认密码是tigger scott 是Oracle是最老的一批开发者，为了纪念他所以保留了这些用户 如果安装的时候没设置也可以在通过sql语句来解锁alter user scott account unlock; alter user scott identified by tiger; Oracle需要修改两个ip地址的文件：C:\oracle\product\10.2.0\db_1\NETWORK\ADMIN 中的listener跟tnsnames中的ip改为虚拟机的ip 关闭虚拟机的防火墙 现在在虚拟机dos窗口中用 sqlplus 用户名/密码的方式来查看是否能进数据库 远程连接数据库本地安装plsql developer在虚拟机本地安装，PLSQL Developer 不用配置即可直接通过用户名密码登陆 远程连接 安装plsql dev 注意安装目录不能有中文跟空格 解压缩拷贝到本地instantclient_12_1，拷贝上面安装后改的配置文件tnsnames.ora到本地 其实instantclient_12_1才是真正的Oracle客户端，在虚拟机上因为本地安装了Oracle所以就不用再次安了，但是在远程中需要它 登陆plsql 破解一下 直接运行 keygen 即可获得对应得破解信息 第一次登陆plsql时，不要输入账号密码，直接进入，在tools ---&gt; preference 中配置 instantclient_12_1 对应的路劲后应用，确定 配置系统环境变量，名字TNS_ADMIN 路径是tnsnames.ora的所在路径 然后再次重启pplsql输入system账户跟密码就可以进去了 如果在安装的时候解锁了scott用户，就可以用输入scott账号跟密码进去，如果没解锁，可以通过sql语句解锁，上边有 如果不行的话，可以在虚拟机中重启listener跟service服务试试 Oracle的sql语句中文乱码问题 查看服务器编码select userenv(&#39;language&#39;)from dual;我实际查到的结果为:AMERICAN_AMERICA.ZHS16GBK 执行语句 select * from V$NLS_PARAMETERS查看第一行中PARAMETER项中为NLS_LANGUAGE对应的VALUE项中是否和第一步得到的值一样，如果不是，则需要配置环境变量 设置环境变量 新建变量名为NLS_LANG,变量值 ：第一步查到的值，我的是AMERICAN_AMERICA.ZHS16GBK 重新启动plsql，插入数据正常 sql语句 注： sql语句中，单引号可能不行，要双引号 要提示按 F6 dual 虚表，没有任何意义，只是为了补全Oracle查询语法 Orcale中要想访问scrott里的表，需要登录scrott用户或者 system用户中查询表用from scrott.emp Oracle的查询内容区分大小写，关键字不区分 转成日期类型的 to_date(‘1981-1-1’,’yyyy-MM-dd’) 转义 &#39;%/_%&#39; escape &#39;/&#39;,用什么转义用escape SQL优化的原则：尽量使用列名 SQL中的null : 包含null的表达式都为null,null永远!=null null值最大 null值：如果集合中含有null，不能使用not in；但可以使用in between and 1: 含有边界 2. 小值在前 大值在后 order by作用于后面所有的列，desc只作用于离他最近的列select * from emp order by deptno ,sal desc 希望：对于某些不成立的记录，任然希望包含在最后的结果中左外连接：当where e.deptno=d.deptno不成立的时候，等号左边的表任然被包含 写法：where e.deptno=d.deptno(+)右外连接：当where e.deptno=d.deptno不成立的时候，等号右边的表任然被包含 写法：where e.deptno(+)=d.deptno 自连接：通过表的别名，将同一张表视为多张表，自连接不适合操作大表 基本查询 1.查询出所有emp中的信息，并用中文进行字段重命名select * from scott.empselect empno &quot;编号&quot;,ename &quot;姓名&quot;,job &quot;工作&quot; from scott.emp 2.查询emp表中员工的job信息，并去除重复信息select distinct(job) from scott.emp 3.查询emp表中员工的全年的工资总和(sal总和)select sum(sal) from scott.emp 4.查询emp表中员工的全年收入总和(sal+comm的总和)select sum(sal)+sum(comm) from scott.emp 5.查询emp表中员工编号，姓名（输出格式如下：编号:xxx，姓名：xxx） Concat拼接方式,可以多层嵌套select concat(concat(&#39;编号:&#39;,empno),concat(&#39;,姓名:&#39;,ename)) from scott.emp Oracle的||方式,就是java里的+号select &#39;编号：&#39;||empno||&#39;，姓名：&#39;||ename from scott.emp 条件查询 1.查询工资大于1500的员工select ename,sal from scott.emp where sal&gt;1500 2.查询工资大于1500并且有奖金的雇员select ename,sal,comm from scott.emp where sal&gt;1500 and comm is not null 3.查询工资大于1500或者有奖金的雇员select ename,sal,comm from scott.emp where sal&gt;1500 or comm is not null 4.查询工资大于1500并且没有奖金的雇员select ename,sal,comm from scott.emp where sal&gt;1500 and comm is null 5.查询员工姓名为smith的员工,注意大小写select empno,ename from scott.emp where ename=&#39;SMITH&#39; 范围查询 1.查询工资大于1500但小于3000的全部雇员 /&gt;=,&lt;=方式select ename from scott.emp where sal&gt;=1500 and sal&lt;=3000 between and方式select ename from scott.emp where sal between 1500 and 3000 2.查询1981-1-1到1981-12-31号入职的雇员（between and）select ename from scott.emp where hiredate between to_date(&#39;1981-01-01&#39;,&#39;yyyy-MM-dd&#39;) and to_date(&#39;1981-12-31&#39;,&#39;yyyy-MM-dd&#39;); 3.查询员工编号是7369,7654,7566的员工 OR方式select empno,ename from scott.emp where empno=&#39;7369&#39; or empno=&#39;7654&#39; or empno=&#39;7566&#39; IN方式select empno,ename from scott.emp where empno in(7369,7654,7566) 4.查询雇员姓名是’SMITH’,’ALLEN’,’WARD’的雇员信息 (IN方式)select empno,ename from scott.emp where ename in(&#39;SMITH&#39;,&#39;ALLEN&#39;,&#39;WARD&#39;) 模糊查询like 1.查询所有雇员姓名中第二个字符有‘M’的雇员select ename from scott.emp where ename like &#39;_M%&#39; 2.查询名字中带有‘M’的雇员select ename from scott.emp where ename like &#39;%M%&#39; 3.查询雇员编号不是7369的雇员信息 &lt;&gt;方式select ename from scott.emp where empno &lt;&gt; 7369 !=方式select ename from scott.emp where empno != 7369 排序 order bynvl(字段名，0) 如果字段为null把null改为0 排序的时候，让null在最后边 desc nulls last 1.查询雇员的工资进行降序排序select ename,sal from scott.emp order by sal desc 2.查询雇员的奖金并做降序排序（关于nulls first/nulls last）select ename,nvl(comm,0) from scott.emp order by nvl(comm,0) desc 3.查询雇员的工资做降序排列并且其中奖金部分是升序排序select ename,sal,nvl(comm,0) from scott.emp order by sal desc,nvl(comm,0) asc 单行函数伪表，虚表：dual 没有任何的实际意义，只是为了补全Oracle查询语法 字符函数 1.将’smith’转换成大写–关键字:upper select upper(&#39;smith&#39;) from dual 2.将’SMITH’转换成小写–关键字:lower select lower(&#39;SMITH&#39;) from dual 3.将’smith’首字母大写–关键字:initcap select initcap(&#39;smith&#39;) from dual 4.将’helloworld’截取字符串成’hello’ 关键字substr,Orcale 默认是从1开始的，但是0也可以 select substr(&#39;helloworld&#39;,0,5) from dual select substr(&#39;helloworld&#39;,1,5) from dual 5.获取’hello’的字符串长度–关键字length select length(&#39;hello&#39;) from dual 6.将’hello’中的l用x进行替换–关键字replace select replace(&#39;hello&#39;,&#39;l&#39;,&#39;x&#39;) from dual 数值函数 1.将15.66进行四舍五入（从-2到2）–关键字round 123456select round(15.66) from dual //16select round(15.66,-2) from dual //0 小数点左边第二位进select round(15.66,-1) from dual //20 小数点左边第一位进select round(15.66,0) from dual //16select round(15.66,1) from dual //15.7 保留一位小数select round(15.66,2) from dual //15.66 保留两位小数 2.将15.66进行截断（从-2到2）–关键字trunc 123456select trunc(15.66) from dual //15从小数点截取select trunc(15.66,-2) from dual //0select trunc(15.66,-1) from dual //10select trunc(15.66,0) from dual //15select trunc(15.66,1) from dual //15.6select trunc(15.66,2) from dual //15.66 3.对15/3进行求余数–关键字mod select mod(15,3) from dual 日期函数 1.查询系统时间–关键字sysdateselect sysdate from dual 2.查询雇员进入公司的周数select ename,trunc((sysdate-hiredate)/7) as &quot;周&quot; from scott.emp 3.查询雇员进入公司的月数–关键字months_betweenselect round(months_between(sysdate,hiredate)) from scott.emp 4.求出三个月后的日期–关键字add_monthsselect add_months(sysdate,3) from dual 转化函数： 将系统日期显示为yyyy-mm-dd hh:mi:ss. 注意分钟是miselect to_char(sysdate,&#39;yyyy-mm-dd hh:mi:ss&#39;) from dual; 去掉补0,就是有的单位数会前面有个0select to_char(sysdate,&#39;fmyyyy-mm-dd hh:mi:ss&#39;) from dual; 显示成24小时制select to_char(sysdate,&#39;yyyy-mm-dd hh24:mi:ss&#39;) from dual; 显示成年月日select to_char(sysdate,&#39;yyyy&#39;)||&#39;年&#39; from dual； 将字符串1981-1-1转换成日期函数select to_date(&#39;1981-1-1&#39;,&#39;yyyy-mm-dd&#39;) from dual; 通用函数 空值的处理函数，有null置为0 select nvl(comm,0) from scott.emp; nvl2(判断值，非空返回值，空返回值) select nvl2(null,&#39;非空&#39;,&#39;空&#39;) from dual; 条件表达式 1.查询员工的job内容并转成中文显示 decode方式 ：在这里，要区分字段的大小写select ename,decode(job,&#39;CLERK&#39;,&#39;柜员&#39;,&#39;SALESMAN&#39;,&#39;销售&#39;，&#39;其他&#39;) from scott.emp //最后那个其他表示没有写出的，要不会转成null case when then end 方式select ename , case job when &#39;CLERK&#39; then &#39;柜员&#39; when &#39;SALESMAN&#39; then &#39;销售&#39; else &#39;其他&#39; end from scott.emp 多行(聚合)函数 查询的时候最好查哪个在count中放哪个字段，查询所有最好用主键 1.查询所有员工记录数–关键字countselect count(*) from scott.emp 2.查询佣金的总数–（如何查询某个字段的总数量）select sum(sal) from scott.emp 3.查询最低工资–关键字minselect min(sal) from scott.emp 4.查询最高工资–关键字maxselect max(sal) from scott.emp 5.查询平均工资–关键字avgselect avg(sal) from scott.emp 6.查询20号部门的员工工资总和select deptno,sum(sal) from scott.emp group by deptno having deptno=20 分组函数 (group by后边有什莫select后边就必须有什么) 1.查询部门编号及人数–分组查询关键字group byselect deptno,count(*) &quot;人数&quot; from scott.emp group by deptno 2.查询每个部门编号及平均工资select deptno,round(avg(sal)) from scott.emp group by deptno 3.查询部门名称，部门编号，平均工资select dname,s.deptno,round(avg(sal)) from scott.emp s, scott.dept d where s.deptno=d.deptno group by s.deptno,dname 4.查询出部门人数大于5人的部门select deptno,count(*) from scott.emp group by deptno having count(*)&gt;5 5.查询部门编号，部门名称，平均工资且平均工资大于2000select s.deptno,dname,round(avg(sal)) from scott.emp s,scott.dept d where s.deptno=d.deptno group by s.deptno,dname having round(avg(sal))&gt;2000 多表关联查询 查询员工编号,员工姓名,员工部门编号,员工部门名称,员工部门地址,中文显示员工工资等级,及领导编号,领导姓名,领导部门编号,领导部门名称,中文显示领导工资等级（可分为以下几个逻辑） 查询员工编号,员工姓名,领导编号,领导姓名select s1.empno,s1.ename,s2.empno,s2.ename from scott.emp s1,scott.emp s2 where s1.mgr=s2.empno 查询员工编号,员工姓名,员工部门编号,员工部门名称,员工部门地址,领导编号,领导姓名,领导部门编号,领导部门名称 123select s1.empno,s1.ename,s1.deptno,d1.dname,d1.loc,s2.empno,s2.ename,s2.deptno,d2.dname,d2.loc from scott.emp s1,scott.emp s2,scott.dept d1,scott.dept d2 where s1.mgr=s2.empno and s1.deptno=d1.deptno and s2.deptno=d2.deptno 查询员工编号,员工姓名,员工部门编号,员工部门名称,员工部门地址,员工工资等级,领导编号,领导姓名,领导部门编号,领导部门名称,领导工资等级 1234select s1.empno,s1.ename,s1.deptno,d1.dname,d1.loc,g1.grade,s2.empno,s2.ename,s2.deptno,d2.dname,d2.loc,g2.grade from scott.emp s1,scott.emp s2,scott.dept d1,scott.dept d2,scott.salgrade g1,scott.salgrade g2 where s1.mgr=s2.empno and s1.deptno=d1.deptno and s2.deptno=d2.deptno and s1.sal between g1.losal and g1.hisal and s2.sal between g2.losal and g2.hisal 询员工编号,员工姓名,员工部门编号,员工部门名称,员工部门地址,中文显示员工工资等级,领导编号,领导姓名,领导部门编号,领导部门名称,中文显示领导工资等级 1234select s1.empno,s1.ename,s1.deptno,d1.dname,d1.loc,decode(g1.grade,1,&apos;一级&apos;,2,&apos;二级&apos;,3,&apos;三级&apos;,4,&apos;四级&apos;),s2.empno,s2.ename,s2.deptno,d2.dname,d2.loc,decode(g2.grade,1,&apos;一级&apos;,2,&apos;二级&apos;,3,&apos;三级&apos;,4,&apos;四级&apos;)from scott.emp s1,scott.emp s2,scott.dept d1,scott.dept d2,scott.salgrade g1,scott.salgrade g2 where s1.mgr=s2.empno and s1.deptno=d1.deptno and s2.deptno=d2.deptno and s1.sal between g1.losal and g1.hisal and s2.sal between g2.losal and g2.hisal 外连接因为内连接有的时候，查不到没有关联的数据，所以用到了外连接 1.查询员工编号，姓名，领导编号，领导姓名，包括没领导的 left join on方式select s1.empno,s1.ename,s2.empno,s2.ename from scott.emp s1 left join scott.emp s2 on s1.mgr=s2.empno Orcl的(+)方式select s1.empno,s1.ename,s2.empno,s2.ename from scott.emp s1,scott.emp s2 where s1.mgr=s2.empno(+) 2.查询出所有部门信息(包括没员工的部门)及部门下的员工信息 123select d.deptno,dname,loc,empno,ename,sal,comm from scott.dept d left join scott.emp s on d.deptno=s.deptnoselect d.deptno,dname,loc,empno,ename,sal,comm from scott.dept d , scott.emp s where d.deptno=s.deptno(+) 多表关联查询的时候，如果逻辑不清楚可以考虑画图 抽屉]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[sublime]]></title>
      <url>%2F2016%2F09%2F18%2Fsublime%2F</url>
      <content type="text"><![CDATA[相关插件 Sublime - MarkdownEditing Sublime - MarkdownPreview [Chrome - Markdown Here] 自己实现一个Markdown文件转换器Sublime 插件使用和安装确认是否安装了Package Control通过快捷键：Ctrl + Shift +p 打开命令面板(Command Palate) 装 Package Control 打开Package Control 切换到Installiation 根据相应的Sublime 版本复制相应的代码 然后通过Ctrl +一个反引号 打开Sublime的控制面板，然后将上面的代码粘到Console面板上回车安装(注意需要联网) 基本使用Sublime 所有的插件都托管在Pageage Control网站上 Install:安装包 安装的时候需要联网，可能会被墙 List： 显示所有已安装的本地插件包 Remove： 删除指定的插件包 轻量级编辑器推荐 Sublime Microsoft: Visual Studio Code Electron: HTML +CSS+JavaScript +Node.js 使用Web技术构建跨平台的Desktop App Github： Atom 插件推荐网站：awesome 里边有markdown转换为ppt的插件，还有不少别的插件]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SVN]]></title>
      <url>%2F2016%2F09%2F14%2FSVN%2F</url>
      <content type="text"><![CDATA[SVNSVN的概述SVN 的概述 SVN简称Subversion的简称，是一个开放源码的版本控制系统，相较于RCS、CVS，它采用了分支管理系统，它的设计目标就是取代CVS。互联网上很多版本控制服务已从CVS迁移到Subversion.说的简单一点SVN就是用于多个人共同开发同一项目，共用资源的目的。 SVN的作用 主流的版本控制VSS ：Visual Source Safe 微软的CVSSVN : Apache的Git : SVN的安装SVN的使用的模式： SVN的使用模式： 复制 –&gt; 修改 –&gt; 合并的方案（主要） 锁定 –&gt; 修改 –&gt; 解锁的方案 SVN的体系 安装VisualSVN 注意端口，默认是443，很有可能被虚拟机占用，可以改为 8443(我用的8443),可以在命令行查看端口号 netstat -ano 可以命令行里输入 services.msc 查看服务是否启动。 创建仓库，创建工程SVN的基本的使用安装客户端软件安装 TortoiseSVN SVN的权限管理 在Users上创建用户 右键Create User，输入用户名跟密码 在Groups创建组，直接给用户名创建权限不太方便 右键Create Group，输入用户名跟描述 给组里添加用户 选中组，右键Edit —&gt; Add. 给仓库去设置权限 仓库右键 Properties 设置权限 在仓库中创建一个工程，内容一般放在trunk中，branches里放的是分支。 使用 不同的步骤文件对应的图标会变 创建两个文件夹（A，B），分别作为要测试的仓库 右键 CheckOut 输入用户名密码，完成跟服务器同步 若失败，想重新弄一下，需要 右键 ---&gt; setting --&gt; clear Data 清理一下缓存 在A的一端可以创建一个文件，然后 右键 ---&gt; TortoiseSVN ---&gt; Add 现在只是添加到SVN的管理(文件图标有一个小加号) 提交到SVN的服务器 右键 ---&gt; SVN Commit... (现在跟服务器上的代码是同步的文件图标有一个小对勾) B中要想在同步服务器中的东西，直接 右键 ---&gt;update 即可 在B的一段修改代码，文件会变成小叹号，表示与服务器端的不一样 在A的一端，要先更新，右键 ---&gt;update ，写完了再提交 也可以恢复历史版本， 右键 ---&gt; TortoiseSVN ---&gt; Update to Revision... 点 show log 恢复到指定的版本 解决冲突 当两个人共同操作的时候，一个人已经提交了，另外一个人的就不是最新的版本了，他在提交的时候就不是最新的了，就会出现冲突 解决：出现冲突后，删掉没用的文件，把叹号里的东西没用的都删除，在提交即可 还有一种方法，修改后，右键 —&gt; Resolve…(来标记冲突已经解决) SVN的 Eclipse 的插件安装 低版本的跟MyEclipse：site中的两个文件夹拉出来放到一个叫做SVN文件夹中，然后扔到Eclipse里 现在使用的Eclipse中安装： Help ---&gt; Install new SoftWare ---&gt; add ---&gt; Archive ---&gt; SVN插件的地址 如果没有联网的话，把下边最后一个对勾去掉，否则不会成功 检查是否安装：右上角点开看是否有SCV资源库研究 或 右键项目 Team —&gt; Share Project 有SVN则成功了 使用 发布一个项目 在Eclipse中的SVN模块中，新建一个资源库的位置，路径为SVN服务器上要发布的地址， 项目 右键 —&gt; share Project —&gt; svn —&gt;选择已有的项目 再在项目，右键 —&gt; teap —&gt;提交 下载，检出 在Eclipse中的SVN模块中，新建一个资源库的位置，路径为SVN服务器上要下载的地址。 则在这个路径底下就会有那个项目，在右键 —&gt; 检出为… —&gt; 输入项目名（注意不要重复） 使用 先更新，右键 —&gt; team —&gt; 更新 ， 在改代码 在提交，右键 —&gt; team —&gt; 提交 删除项目 因为项目已经被SVN管理，所以不要直接删除，要右键—&gt;断开连接，再删除 可以选择是否删除隐藏的 .snv 文件 小组协作12345678910其中一个人在自己的计算机上搭建一个 SVN 服务器（使用 VisualSVN搭建）然后给其它小组成员创建账号然后创建项目，给小组成员账号分配权限小组成员通过 TortoiseSVN 客户端 操作远程仓库注意：小组成员在 checkout 远程仓库地址的时候，SVN 服务器管理员要把仓库的地址告诉小组成员https://SVN服务器ip地址/svn/JD/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring第四阶段]]></title>
      <url>%2F2016%2F07%2F13%2FSpring%E7%AC%AC%E5%9B%9B%E9%98%B6%E6%AE%B5%2F</url>
      <content type="text"><![CDATA[Spring案例：CRM的保存案例(SSH完成)SSH 整合方式一：零障碍整合意思就是没有注解用所有的配置文件，最原始的那种写法 SSH基本回顾第一步：创建项目，引入jar包 33个 Struts2 中基本的开发包：struts-blanks中找 13个 struts2中的依赖包(看需求)：sturts/lib/ 例：spring :Struts2整合Spring convention :注解 json :整合AJAX的开发包 Hibernate5 基本： lib/required 里面的所有9个 还需要 日志记录 log4j 跟数据库驱动 connector 有可能用的到数据库的连接池： C3P0 （3个）：5的版本，3的版本的时候只需要一个C3P0即可 Spring 基本： IOC基本 6个，四个核心包，两个日志 AOP基本 4个，两个核心包，两个依赖 事务管理 ：tx JDBC :jdbc跟数据库驱动connector 整合web ：web 整合单元测试 ：test 整合其他框架（Hibernate反正在这）: orm Struts跟Hibernate同时包含了这个，删除一个低版本的 引入配置文件 Struts2 web.xml struts.xml Hibernate5 hibernate.cfg.xml 映射文件 Spring applicationContext.xml log4j.properties web.xml 核心监听器ContextLoaderListener 具体实现 创建包结构 引入相关的页面 修改页面的路径 Struts2 和Spring的整合 Action类由Struts2的自身创建 引入一个Struts2中的lib包中的spring包 在jar包中有一个配置文件：struts-plugins.xml 在struts核心包中的default.properties，有下面这个常量： Struts中的是默认将这个常量注释的，在插件包中将其开启，这个常量的开启会引发下面一系列常量的开启 开启后只需要在action中加一个Service的变量跟set方法，即可直接使用Service，配置文件中只要有名字跟他对上了即可使用 Action类交给Spring管理（建议使用） 在Spring中创建一个Action的实例， 因为Struts配置文件中已经有了action的实例，所以需要把Struts中的class改为spring中实例的id 注意：Actioin是多例的，所以要在Spring中的action实例中加一个scope=prototyte Service的属性需要在Spring中手动注入 建议使用交给Spring，因为Spring中有AOP，可以方便增强 Spring整合Hibernate 编写Dao，配置Dao 创建数据库和实体类，配置文件 因为隔离级别跟绑定当前线程都交给Spring管了，所以在这里就把配置文件中的删掉。 在Spring中引入Hibernate的信息 在Spring的配置文件中构建一个SessionFactory（注意版本5）,并注入configLoaction属性 定义Hibernate模板，并注入到Dao中去然后在Dao中写模板的变量跟set方法即可。 因为写一个Dao就得注入一次，特麻烦，所以可以让Dao继承HibernateDaoSupport,里面有模板的变量跟set方法 还能更简单：HibernateDaoSupport中有getHibernateTemplate的方法，里面的内容是有模板就能用，没有就创建一个模板，所以只需要在Dao中注入SessionFactory,然后再调用getHibernateTemplate方法即可。 在Spring跟Hibernate的整合上修改数据库时，必须使用事务管理，要不然会抛出read-only异常。 添加事务管理 配置事务管理器 123&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate5.HibernateTransactionManager&quot;&gt; &lt;property name=&quot;sesssionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;&lt;/bean&gt; 开启注解事务 1&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; /&gt; 在业务层添加注解 12@Transactionalpublic class CustomerServiceImpl implements CustomerService&#123;&#125; SSH整合方式二：不带Hibernate配置文件web 项目复制之后过去不能直接用，必须修改项目属性中的 Web Project Settings 在Spring中配置连接池 提供属性文件（数据库连接） 引入外部属性文件&lt;context:property-placeholder location=&quot;classspath:jdbc.properties&quot; /&gt; 配置连接池 123456&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.user&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;&lt;/bean&gt; 构建连接池，构建一个SessionFactory 12345678910111213&lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&gt; &lt;!-- 注入连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;!-- 设置Hibernate的属性 --&gt; &lt;property name=&quot;hibernateProperties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/prop&gt; &lt;prop key=&quot;hibernate.show_sql&quot;&gt;true&lt;/prop&gt; &lt;prop key=&quot;hibernate.format_sql&quot;&gt;true&lt;/prop&gt; &lt;prop key=&quot;hibernate.hbm2ddl.auto&quot;&gt;updata&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 设置Hibernate的映射文件 12345&lt;property name=&quot;mappingResources&quot;&gt; &lt;list&gt; &lt;value&gt;com/spring/ssh/...&lt;/value&gt; &lt;/list&gt;&lt;/property&gt; 在加载映射文件的时候还有很多种方式： 具体到包中所有的映射文件 : &lt;property name=&quot;mappingDirectoryLocations&quot;&gt; &lt;array&gt; &lt;value&gt;classpath:cn/itcast/domain&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; 使用通配符的概念加载映射文件 :&lt;property name=&quot;mappingLocations&quot;&gt; &lt;array&gt; &lt;value&gt;classpath:cn/itcast/domain/*.hbm.xml&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; Hibernation 模板的使用 save(Object obj) update(Object obj) delete(Object obj) T get(Class clazz,Serializable id); List/ find(String hql); List/ findByCriteria(DetachedCriteria c); 修改跟删除 查询一个 查询多个HQL: QBC: 延迟加载的解决 延迟加载问题：就是想用Load的时候，因为已经在service使用了事务，所以当延迟加载的时候，到Service的时候就把session关闭了，所以当action中用到查询的东西的时候，没有办法去获得数据了，就会报错 解决办法：用 OpenSessionInViewFilter 过滤器，把session的开启跟关闭放在action中。 12345678 &lt;filter&gt; &lt;filter-name&gt;OpenSessionInViewFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.orm.hibernate5.support.OpenSessionInViewFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;OpenSessionInViewFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/filter-mapping&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring第三阶段]]></title>
      <url>%2F2016%2F07%2F08%2FSpring%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5%2F</url>
      <content type="text"><![CDATA[SpringSpring的AOP的注解AOP注解的入门 创建项目，引入jar包 创建接口跟实现类 将类的创建交给Spring 123&lt;!-- 配置目标类--&gt; &lt;bean id=&quot;customerDao&quot; class=&quot;com.itheima.aop.demo1.CustomerDaoImpl&quot;&gt; &lt;/bean&gt; 编写切面类 开启AOP的注解 &lt;aop:aspectj-autoproxy /&gt; 切面类的注解开发 @Aspect 在方法上加注解 前置增强 @Before(value=&quot;execution(* com.spring...)&quot;) 后置增强,可以添加返回值 @AfterReturning(value=&quot;execution(* com.spring...)&quot;,returning=&quot;obj&quot;) 环绕增 @Around(value=&quot;execution(* com.spring...)&quot;) 异常捕获，可以获得异常信息 @AfterThrowing(value=&quot;execution(* com.spring...)&quot;,throwing=&quot;ex&quot;) 最终增强 @After(value=&quot;execution(* com.spring...)&quot;) 可以把切入点注解提取出来，在最后加一个没有内容的方法，然后上面注解加这个，然后，上面的每一个方法上需要切入哪，只需要在value中加一个 类名.方法名 即可。 12@Pointcut(value=&quot;execution(* com.spring...)&quot;)private void pointCut01()&#123;&#125; Spring的JDBCSpring 的JDBC的模板Spring是EE开发的一站式框架，一站式框架就有每层的解决方案（包括持久层）。 Spring的JDBC模板的入门spring里面了很多对于持久层的解决方案。(JDBC,hibernate均有) 创建项目，引入Spring的需要的jar包，还有Spring核心包中的两个包jdbc,tx 还有连接数据库的包 connection，Spring的版本还需要引入AOP的包 使用JDBC的模板 1234567891011//创建连接池DriverManagerDataSource dataSource = new DriverManagerDataSource();//设置连接数据库的相关的参数dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);dataSource.setUrl(&quot;jdbc:mysql:///数据库&quot;);dataSource.setUsername(&quot; &quot;);dataSource.setPassword(&quot; &quot;);JdbcTemplate jdbctemplate = new JdbcTemplate();JdbcTemplate.setDataSource(dataSource);jdbctemplate.update(&quot;sql语句&quot;,null,&quot;name&quot;,&quot;password&quot;); 这种方法是不好的，因为每次使用的时候还需要创建连接池，所以把连接池交给Spring管理 把连接池交给Spring管理 创建xml配置文件，引入beans的约束 配置内置连接池 123456&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;&quot; /&gt;&lt;/bean&gt; 把JDBC的模板交给Spring管理 1234&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;jdbcTemplate的路劲&quot; &gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;&lt;/bean&gt;//这里的name必须为dataSource,因为用的是JDBC的模板 测试类： 用JUnit跟Springde整合1234567891011@RunWith(SpringJUnit4ClassRunner.class)@contextConfiguration(&quot;classpath:applicationContext.xml&quot;)public class JdbcTemplateDemo2&#123; @Resource(name=&quot;jdbcTemplate&quot;) private JdbcTemplate jdbcTemplate; @Test public void demo01()&#123; jdbcTemplate.update(&quot;insert into account values (?,?)&quot;，&quot;张三&quot;，100d),; &#125;&#125; 引入外界连接池dpcp连接池 导包：依赖包中apache的commons中的dpcp跟pool，用之前的也行，跟这个一样 配置DBCP连接池 1234567//配置DBCP的连接池&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql,jdbc.Driver&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///数据库&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;&quot; /&gt;&lt;/bean&gt; 测试跟默认的一样 c3p0的连接池 导包,依赖包中c3p0的包 配置连接池,注意：配置属性跟之前的不一样 123456&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql,jdbc.Driver&quot; /&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql:///数据库&quot; /&gt; &lt;property name=&quot;user&quot; value=&quot;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;&quot; /&gt;&lt;/bean&gt; 提取属性文件(连接数据库的信息) 即使用配置文件，如果需要把项目交给别人也要改配置文件，所以提取出一个属性文件，改的时候只改属性文件即可 定义属性文件jdbc.properties 在Spring中配置文件引入属性文件： 通过&lt;bean&gt;引入123&lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;location&quot; value=&quot;classpath:jdbc.prorerties&quot;&gt;&lt;/bean&gt; 在配置配置文件: 但不经常用这个，经常用context标签引入12345678&lt;context:property-placeholder location=&quot;classpath:jdbc.prorerties&quot;&gt;&lt;!-- 配置C3P0连接池 --&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot; /&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.user&#125;&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;&lt;/bean&gt; JDBC模板进行CURD操作增删改 增删改的方法是通用的： update(sql语句，参数); 查询 单个数 : T queryForObject(String sql,Class/&lt;T/&gt; requiredType,Object… args) 某个对象 ：T queryForObject(String sql,RowMapper/&lt;T/&gt; rowMapper ,Object… args); List集合 ：List/&lt;T/&gt; query(String sql,RowMapper/&lt;T/&gt; rowMapper,Object… args); 查询属性 12//查询id为1的账号的名称String name=jdbcTemplate.queryForObject(sql语句，String.class,Object 参数); 统计个数 1Long count=jdbcTemplate.queryForObject(sql语句，Long.class,Object 参数); 查询某个对象 RowMapper类似于DBUtils中的 ResultSetHandler 12345678910111213Account account=jdbcTemplate.queryForObject(sql语句，new MyRowMapper(),参数);//可以创建一个内部类来实现RowMapper&lt;T&gt;class MyRowMapper implements RowMapper&lt;User&gt;&#123; @override public Account mapRow(ResultSet rs,int rowNum)&#123; Account account = new Account(); account.setId(rs.getInt(&quot;id&quot;)); account.setName(rs.getString(&quot;name&quot;)); account.setMoney(rs.getDouble(&quot;money&quot;)); return account; &#125;&#125; 查询多个对象 12List&lt;Account&gt; account = query(String sql,new MyRowMapper(),Object... args);//当然也需要创建一个RowMapper&lt;T&gt;接口的实现类，跟上边用一个就行 Spring的事务Spring的事务管理事务的回顾 事务的概念： 逻辑上一组操作，组成这组操作的各个逻辑单元，要么一起成功，要么一起失败 事务的特性： 原子性 一致性 隔离性 持久性 如果不考虑隔离性引发安全问题 读问题 脏读 不可重复读 虚读 写问题 丢失更新 解决读问题 设置事务隔离级别 read uncommitted read committed repeatable read serializable Spring的事务管理的API PlatformTransactionManager：平台事务管理器（Spring中真正管理事务的对象） DataSourceTransactionManager ：使用JDBC操作进行事务管理时候使用 HibernateTransactionManager ：使用Hibernate框架进行事务管理时候使用 TransactionDefinition ：事务的定义信息 事务的隔离级别 事务的传播行为 事务是否只读 事务超时信息 TransactionStatus ：事务的状态对象 是否已经完成 是否有保存点 三个对象的关系： Spring通过TransactionDefinition对事务进行定义，使用PlatformTransactionManager根据定义信息进行事务的管理，在事务管理过程中产生一些状态，将状态存入到TransactionStatus中。 事务的传播行为的作用和含义 事务传播行为的作用 事务的传播行为：解决复杂的事务的操作，业务层之间代码的相互调用 propagation 事务传播行为的取值：记标红的那个即可，主要是第一个根据上两幅图做出的解释： Spring的事务管理的方式 编程式事务管理： 手动编写代码实现事务管理 声明式事务管理： 通过配置实现事务管理 xml的配置方式 注解方式 Spring的事务管理实现：搭建事务管理的基本环境用转账的案例，先写出JDBC模板： 编写Dao 12345678910111213141516171819public class AccountDaoImpl implements AccountDao &#123; private JdbcTemplate jdbcTemplate; public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; &#125; @Override public void outMoney(String from, Double money) &#123; jdbcTemplate.update(&quot;update account set money = money - ? where name = ?&quot;, money,from); &#125; @Override public void inMoney(String to, Double money) &#123; jdbcTemplate.update(&quot;update account set money = money + ? where name = ?&quot;, money,to); &#125;&#125; 配置Dao 12345678910111213141516171819&lt;!-- 引入外部属性文件：方式二：通过context标签引入 --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!-- 配置C3P0连接池 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.user&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/bean&gt; &lt;!-- 将JDBC的模板交给Spring管理 --&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置DAO --&gt; &lt;bean id=&quot;accountDao&quot; class=&quot;com.itheima.tx.demo1.AccountDaoImpl&quot;&gt; &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;/&gt; &lt;/bean&gt; 编写Service 1234567891011121314151617181920public class AccountServiceImpl implements AccountService &#123; private AccountDao accountDao; public void setAccountDao(AccountDao accountDao) &#123; this.accountDao = accountDao; &#125; @Override /** * from：转出账号 * to：转入账号 * money：转账金额 */ public void transfer(String from, String to, Double money) &#123; accountDao.outMoney(from, money); accountDao.inMoney(to, money); &#125;&#125; 配置Service 1234&lt;!-- 配置Service --&gt; &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.tx.demo1.AccountServiceImpl&quot;&gt; &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;/&gt; &lt;/bean&gt; 编写测试类 1234567891011@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext2.xml&quot;)public class TransactionDemo1 &#123; @Resource(name=&quot;accountService&quot;) private AccountService accountService; @Test public void demo1()&#123; accountService.transfer(&quot;郝强勇&quot;, &quot;郝如花&quot;, 1000d); &#125;&#125; 编程式事务管理 配置事务管理器: 注：事务管理器的名称必须是transactionManager 1234&lt;!-- 配置事务管理器：Spring真正管理事务的类 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; 配置事务管理模板 123//配置事务管理的模板&lt;bean id=&quot;transactionTemplate&quot; class=&quot;org.springframework.transaction.support.TransactionTemplate&quot;&gt; &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot; /&gt;&lt;/bean&gt; 在业务层注入事务管理的模板 123456&lt;!-- 配置Service --&gt; &lt;bean id=&quot;accountService&quot; class=&quot;com.itheima.tx.demo1.AccountServiceImpl&quot;&gt; &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;/&gt; &lt;!-- 事务管理模板的注入 --&gt; &lt;property name=&quot;transactionTemplate&quot; ref=&quot;transactionTemplate&quot;/&gt; &lt;/bean&gt; 改写业务层 123456789101112131415161718192021222324252627282930313233public class AccountServiceImpl implements AccountService &#123; private AccountDao accountDao; public void setAccountDao(AccountDao accountDao) &#123; this.accountDao = accountDao; &#125; // 提供事务管理模板注入: private TransactionTemplate transactionTemplate; public void setTransactionTemplate(TransactionTemplate transactionTemplate) &#123; this.transactionTemplate = transactionTemplate; &#125; @Override /** * from：转出账号 * to：转入账号 * money：转账金额 */ public void transfer(final String from, final String to, final Double money) &#123; transactionTemplate.execute(new TransactionCallbackWithoutResult() &#123; @Override protected void doInTransactionWithoutResult(TransactionStatus status) &#123; accountDao.outMoney(from, money); int d = 1/ 0; accountDao.inMoney(to, money); &#125; &#125;); &#125;&#125; 声明式事务管理(底层用的就是AOP)XML方式 引入Aop的jar包 恢复一下转账的环境 配置事务管理器 1234&lt;!-- 配置事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; 配置事务的增强（规范） 123456789101112131415&lt;!-- 配置事务的增强（规范） --&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;!-- &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;/&gt; --&gt; &lt;tx:method name=&quot;transfer&quot; propagation=&quot;REQUIRED&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt;//propagaion :传播行为isolation :隔离级别read-only :是否为只读rollback-for :发生哪些异常事务会回滚，默认情况下，任何异常都会回滚no-rollback-for :发生哪些异常事务不会回滚 AOP的配置 12345 &lt;!-- AOP的配置--&gt; &lt;aop:config&gt; &lt;aop:pointcut expression=&quot;execution(* com.itheima.tx.demo2.AccountServiceImpl.transfer(..))&quot; id=&quot;pointcut1&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pointcut1&quot;/&gt; &lt;/aop:config&gt; 注解方式 恢复开发环境 配置事务管理器 开启注解事务 1&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; /&gt; 在要加注解的类上加一个@Transactional 要想加属性后边加一个(),按提示写]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring第二阶段]]></title>
      <url>%2F2016%2F07%2F05%2FSpring%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%2F</url>
      <content type="text"><![CDATA[SpringSpring的Bean的管理注解开发xml：结构清晰注解：开发方便(属性注入) Spring的IOC注解基础 引包(Spring-aop的包)，Spring4.x版本需要引，低的版本不用引了，都内置了 引入约束，在spring-framework-4.2.4.RELEASE\docs\spring-framework-reference\html\xsd-configuration.html 中找到context的约束。 要想设置离线提示信息，则要在window中的属性设置一下，约束文件设置context的约束文件 开启组件扫描 &lt;context:component-scan base-package=&quot;包路劲注意不要到类&quot;&gt;&lt;/component&gt; 加注解：在类上加 @Component(&quot;userDao&quot;) 要想用属性，可以在实体类中添加一个私有的属性注解直接加在属性上就行@Value(&quot; &quot;) ，如果有set方法则需要加在set方法上。 Spring的IOC的注解详情 定义Bean的注解： @Component:修饰类，相当于&lt;bean id=&quot;&quot;&gt; Spring 中提供了三个衍生注解： @Controller : 修饰web层类的 @Service : 修饰业务层类的 @Repository : 修饰DAO层类的 属性注入的注解： @Value ：注入普通类型的值 @Autowired ：对象类型的属性注入，但是默认是按类型注入的，不是按名称注入 要想按名称去注入，可以使用@Qulifer(value=””)的注解与@Autowired一起使用 还有一个Resource ：相当于@Qulifer(value=””)的注解与@Autowired一起使用的效果，此注解不是Spring包中的 Bean的作用范围的注解: @Scope(“ “) ：控制Bean的作用范围，默认是单例的，里面的属性跟xml里的一样。 Bean的生命周期的注解：(在要运行的方法上) PostConstruct：初始化注解 PreDestory：销毁注解 Spring的AOP什么是AOP AOP最初是AOP联盟开发出来的，Spring用的人家的。 AOP(Aspect Oriented Programming) ：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 AOP：面向切面编程，是OOP(面向对象编程)扩展和延伸，解决OOP中一些问题而出现。传统方式使用是纵向继承体系，AOP采用叫做横向抽取机制取代传统方式纵向继承机制对程序扩展和延伸 为什莫学习AOP 可以不修改源代码，对程序进行扩展。 主流应用：权限校验，日志记录，事务管理，性能检测。 AOP的底层实现原理（代理机制）Spring底层实现AOP的原理： JDK动态代理 ：对实现了接口的类才可以产生代理 1234567891011121314151617181920212223public class JdkProxy &#123; private UserDao userDao; public JdkProxy(UserDao userDao) &#123; this.userDao = userDao; &#125; public UserDao createProxy()&#123; UserDao proxy = (UserDao)Proxy.newProxyInstance(userDao.getClass().getClassLoader(), userDao.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object obj, Method method, Object[] args) throws Throwable &#123; if(method.getName().equals(&quot;save&quot;))&#123; System.out.println(&quot;权限校验===========&quot;); return method.invoke(userDao, args); &#125; return method.invoke(userDao, args); &#125; &#125;); return proxy; &#125;&#125; Cglib动态代理：对没有实现接口的类产生代理。底层字节码增强，产生子类对象。使用的时候直接把Spring的包引进来就行，因为，他里边已经集合了Cglib的包 1234567891011121314151617181920212223242526272829303132//这里边实现MethodInterceptor的意思是实现回掉函数，下边的intercept就相当于JDK代理中的invoke方法。所以增强方法中的setCallback中传入一个this即可public class CglibProxy implements MethodInterceptor&#123; private ProductDao productDao; public CglibProxy(ProductDao productDao)&#123; this.productDao = productDao; &#125; public ProductDao createProxy()&#123; // 创建Cglib的产生代理核心类： Enhancer enhancer = new Enhancer(); // 设置父类: enhancer.setSuperclass(productDao.getClass()); // 设置回调：类似InvocationHandler enhancer.setCallback(this); // 产生代理： ProductDao proxy = (ProductDao) enhancer.create(); return proxy; &#125; @Override public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; if(method.getName().equals(&quot;save&quot;))&#123; System.out.println(&quot;权限校验=========&quot;); return methodProxy.invokeSuper(proxy, args); &#125; return methodProxy.invokeSuper(proxy, args); &#125;&#125; SpringAOP中的相关的术语 JoinPoint：连接点，可以被拦截(增强)到的点。 Pointcut：切入点，真实被拦截到的点。 Advice： 通知/增强，增强的代码的实现。 权限校验代码/日志记录 的这种代码称为是通知，增强 Introduction：引介，增强的一种。类层面的增强。（一般不用） Target：目标，被增强的类（UserDao） Weaving：织入，将Advice应用到Target的过程。 Proxy：被增强织入以后产生的代理类 Aspect：切面，切面指的是多个切入点和多个通知的组合。 SpringAOP的入门 引入jar包 spring-aop-4.2.4.RESEASE.jar 还有依赖包中aop的联盟的包com.springsource.org.aopalliance 因为Spring用的AOP中aspectj的技术，所以还得引一个他们的依赖包：com.springsource.org.aspectj.weaver 还有一个Spring整合aspectj的包（在lib中）：sprin g-aspects 编写接口跟实现类 创建一个Spring的配置文件，约束引入AOP的部分 12345 &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; 将类配置到Spring中 1234 &lt;bean id=&quot;customerDao&quot; class=&quot;com.aop.demo3.CustomerDaoImpl&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;myAspectXml&quot; class=&quot;&quot; /&gt; 编写一个切类面 12345public class MyAspectXml&#123; public void checkPrivilege()&#123; syso(&quot;权限校验------&quot;); &#125;&#125; 配置切面类 12345678910 //配置Spring的AOP &lt;!-- 配置Spring的AOP --&gt; &lt;aop:config&gt; &lt;!-- 切入点: --&gt; &lt;aop:pointcut expression=&quot;execution(* com.itheima.aop.demo3.CustomerDaoImpl.save(..))&quot; id=&quot;pointcut1&quot;/&gt; &lt;!-- 配置切面 --&gt; &lt;aop:aspect ref=&quot;myAspectXml&quot;&gt; &lt;aop:before method=&quot;checkPrivilege&quot; pointcut-ref=&quot;pointcut1&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; Spring的AOP的切入点的表达式写法 语法：很灵活，随便写 [访问修饰符] 方法的返回值 类名.方法名(参数) 举例: * 表示任意类，任意返回值，任意方法 1234 public void com.aop.demo.CustomerDaoImpl.save(..); //save()跟save(..)效果是一样的 * *.*.demo.*DaoImpl.save(..); * com.aop.demo.CustomerDao+.save(..); // +表示它的实现类 * com.aop.demo..*DaoImpl.save(..); //表示任意包下的 Spring的AOP的通知的类型 前置通知（before） ： 在方法执行之前进行增强，可以获得切入点的信息 获得切入点的信息，传一个joinPoint对象进去123public void before(JoinPoint joinPoint)&#123; syso(前置通知=====joinPoint);&#125; 后置通知(after-returning) ：在方法执行之后进行增强，获取方法的返回值。 获得返回值：在配置文件标签上加一个resulting=&quot;result名字随便起&quot;然后再在增强的类中加一个123public void before(Object result)&#123; syso(后置通知=====result);&#125; 环绕通知(around) ：在方法执行之前跟执行之后进行增强，阻止目标方法的执行 //要想执行原有的目标方法要加一个ProceedingJoinPoint,因为增强的方法不知道是否有返回值所以一般会返回一个Object 123456public Object around(ProceedingJoinPoint joinPoint)&#123; syso(&quot;通知前&quot;); Object obj = joinPoint.proceed(); syso(&quot;通知后&quot;); return obj;&#125; 异常抛出通知(afterThrowing):在方法执行出现异常的时候进行增强，获取异常的信息。异常抛出之后后面的就不执行了，因为是运行时异常 可以获得异常的信息：在标签上加一个属性throwing=&quot;result任意起名&quot;123public void around(Throwable e)&#123; syso(&quot;异常抛出通知---&quot;+e.getMessage());&#125; 最终通知(after)：类似try，catch中的finally。无论方法是否成功都会执行. 引介通知(不关注) 如果一个类实现了接口，则Spring用JDK代理，如果不加接口就默认用Cglib动态代理实现。当然都不能加final，都要产生子类的 Spring与Junit的整合 引入test包spring-test(lib包中)，当然环境下有JUnit 然后再在测试类上加两个注解 12@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;) //全名 下边想用哪个类直接注入即可用 12@Resource(name=&quot;customerDao&quot;)private CustomerDao customerDao; 然后下边的Test单元测试中直接用customerDao即可，不用再加载配置文件那么麻烦 注：这里是只有是Spring跟JUnit整合的时候才能用，因为他里面已经做了一些操作，要想在别的地方使用注解的话，就必须要导包加扫描了 扩展XML和注解整合开发 xml：管理类 注解：属性注入 把service跟Dao都在配置文件中实例化了 不要开扫描否则会出错因为扫描会扫描类上的注解文件，但是类上面没有只有属性上有，所以开启&lt;context:annotation-config /&gt;即可， 支持@Resource，@Value,@Autowared等属性上的注解 12@Resource(name=&quot;UserDao&quot;)private UserDao userDao;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring第一阶段]]></title>
      <url>%2F2016%2F07%2F03%2FSpring%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%2F</url>
      <content type="text"><![CDATA[Spring学习路线 Spring 的第一天：Spring 的IOC的入门，Spring整合web项目 Spring的第二天：IOC的注解开发，Spring的AOP的xml开发 Spring的第三天：Spring的Aop的注解开发，Spring的事务管理 ssh 的整合 Spring的概述什么是Spring Spring是一个开源框架，Spring是于2003年兴起的一个轻量级的Java开发框架，由Rod Johnson创建，简单来说，Spring是一个分层的javaEE/EEfull-stack（一站式） 轻量级开源框架 Spring是SE/EE的一站式框架：Spring有EE开发中每一层解决的方案。 EE的三层结构： WEB层：Spring MVC 业务层：Spring的Bean管理，声明式事务 持久层：Spring的JDBC的模板，Spring的ORM模块 Spring的优点： Spring的版本Spring3.X Spring4.X Spring的IOC的入门IOC(Inversion of Control)IOC:控制反转，将对象的创建权反转给Spring。 解决程序的耦合性 Spring的入门 第一步：下载Spring的开发包 官网： spring 下载spring-framework-4.2.4.RELEASE-dist.zip 解压：Spring的开发包 docs libs schema 第二：导包:只需要导红色圈里的那几个就行，还有log4j的一个包，跟一个日志的接口包commons-logging 第三：编写接口跟实现类 123456789public interface UserDao &#123; public void sayHello();&#125;public class UserDaoImpl implements UserDao &#123; @Override public void sayHello() &#123; System.out.println(&quot;Hello Spring Demo1...&quot;); &#125;&#125; 第四：创建一个Spring的核心配置文件： 在src下创建 applicationContext.xml 名字可以变 引入约束 123456789101112//约束在spring-framework-4.2.4.RELEASE\docs\spring-framework-reference\html\xsd-configuration.html&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;.............................&lt;/beans&gt; 编写Spring配置文件 1&lt;bean id=&quot;userDao&quot; class=&quot;路径&quot;&gt;&lt;/bean&gt; 第五：编写测试类//Spring的方式：IOC的底层实现：工厂+反射+配置文件 123456public void demo2()&#123; ApplicationContext addli= new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); UserDao userDao=(UserDao) appli.getBean(&quot;userDao&quot;);; userDao.sayHello();&#125; DI DI:依赖注入。需要有IOC的环境 IOC和DI的区别： IOC：控制反转：将对象的创建权交给Spring DI:Spring在创建过程中，将类依赖的属性注入进来 123456//现在要配置的类中创建属性,并提供set方法//然后再在配置文件中配置&lt;bean id=&quot;UserDao&quot; class=&quot;UserDao路劲&quot;&gt; //注入属性 &lt;property name=&quot;name&quot; value=&quot;李四&quot;/&gt;&lt;/bean&gt; Spring的工厂类的概述BeanFactory BeanFactory是Spring 早期的工厂类，现在已经不用了 BeanFactory在调用getBean()的时候才会创建类的实例。 ApplicationContext ApplicationContext是Spring目前使用的工厂类 ApplicationContext支持比BeanFactory更加强大的功能(国际化) ApplicationContext在加载Spring的配置文件的时候，就会创建类的实例 在ApplicationContext下有两个实例： ClassPathXmlApplicationContext：加载类路劲下的配置文件 FileSystemXmlAppliocationContext ：加载本地硬盘上的配置文件 Spring的常见的配置&lt;bean id=&quot;&quot; class=&quot;&quot; scope=&quot;&quot; init-method=&quot;方法名&quot; destory-method=&quot;方法名&quot; /&gt; 后边的两个可以省略 Id和name的配置 id:用到了唯一的约束，都不要使用相同名称的值。Id中不能使用特殊字符 name:没有使用唯一的约束，都不要使用相同名称的值。name中可以使用特殊字符。 id跟name中如果有相同的值，运行时会报错。 在Struts1框架中，Action交给Spring管理&lt;bean name=&quot;/login&quot; class=&quot;xxx&quot;&gt; 因为有/所以只能用name。 scope的配置：Bean作用范围 singleton :默认值，单例的，在一个方法中不管创建多少次，都是同一个对象。 prototype ：多例的。 request ：在Web项目中使用，创建一个类，保存到request域中。 session ：在web项目中使用，创建一个类，保存到session中。 globalsession：在web项目中使用，而且Prolet环境，就是例如登陆了百度，就能访问百度云啊贴吧啊什么的。 bean的生命周期的配置(可以省略)初始化方法跟销毁方法都是要在UserDao类中定义的。 init-method=”方法名” ：Bean被创建的时候要去执行的方法 destory-method=”方法名” ：Bean被销毁的时候要去执行的方法 Bean 的创建必须是单例的，而且必须是关闭工厂ClassPathXmlApplicationContext对象.close() 配置不联网提示 windows属性 —&gt; xml catalog —&gt; 约束中的最后一个地址复制过来到key,上面选择本地中的spring-framework-4.2.4.RELEASE\schema\beans\4.2的那个，中间选择key type为Schema location Spring的Bean管理的xml的方式Spring的Bean的创建Spring中提供了三种Bean的实例化的方式： 无参构造的方式 12345678//bean类public class bean&#123; public bean()&#123; syso(&quot;无参构造被调用&quot;); &#125;&#125;//配置文件&lt;bean id=&quot;bean&quot; class=&quot;bean的地址&quot;&gt; 静态工厂实例化的方式 1234567891011121314//bean类public class bean&#123;&#125;//静态工厂类public class beanFactory&#123; public static Bean createBean()&#123; syso(&quot;静态工厂执行了&quot;); return new Bean(); &#125;&#125;//配置文件&lt;bean id=&quot;bean&quot; class=&quot;beanFactory的地址&quot; factory-method=&quot;createBean&quot;&gt; 实例工厂实例化的方式 123456789101112131415//bean类public class bean&#123;&#125;//实例工厂类public class beanFactory&#123; public Bean createBean()&#123; syso(&quot;实例工厂执行了&quot;); return new Bean(); &#125;&#125;//配置文件&lt;bean id=&quot;beanFactory&quot; class=&quot;beanFactory的地址&quot; /&gt;&lt;bean id=&quot;bean&quot; factory-bean=&quot;beanFactory&quot; factory-method=&quot;createBean&quot; /&gt; Bean的属性注入Bean的属性注入 构造方法的方式 set方法的属性注入 接口注入的方式 12345678910public interface Injection&#123; public void setUsername(String username);&#125;class User implements Injection&#123; private String username; public void setUsername(String username)&#123; this.username=username; &#125;&#125; Spring的Bean的属性注入Spring 中只支持前两种: 构造函数： 1234567//配置文件,当然前提是有这个实体类跟有参构造函数&lt;bean id=&quot;car&quot; class=&quot;car的路劲&quot; &gt; &lt;constructor-arg name=&quot;&quot; value=&quot;&quot; /&gt; &lt;constructor-arg name=&quot;&quot; value=&quot;&quot; /&gt;&lt;/bean&gt;//构造注入中的&lt;constructor-args name=&quot;&quot;&gt;name也可以换为index，从0开始表示第一个构造方法中的值是什么 set方法 12345//配置文件,当然前提是有这个实体类跟set方法&lt;bean id=&quot;car2&quot; class=&quot;com.itheima.spring.demo4.Car2&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;宝马/&gt; &lt;property name=&quot;price&quot; value=&quot;800000&quot;/&gt;&lt;/bean&gt; set中如果有对象的话 1234&lt;bean id=&quot;people&quot; class=&quot;people的路劲&quot; &gt; &lt;constructor-arg name=&quot;正常的属性名&quot; value=&quot;正常的属性值&quot; /&gt; &lt;constructor-arg name=&quot;正常的属性名&quot; ref=&quot;前面配置文件的id这里用car&quot; /&gt;&lt;/bean&gt; Spring2.5版本之后提供p名称空间的属性注入 引入p名称空间：xmlns:p=&quot;http://www.springframework.org/schema/p&quot; 完成属性注入： 格式： 普通属性 p:属性名=“属性值” 对象类型的属性 p:属性名-ref=“其他属性的id或name” 12345//普通&lt;bean id=&quot;car&quot; class=&quot;car路劲&quot; p:name=&quot;&quot; p:price=&quot;&quot; /&gt;//对象类型的&lt;bean id=&quot;people&quot; class=&quot;people的路劲&quot; p:name=&quot;&quot; p:car-ref=&quot;car&quot; /&gt; Spring3.X版本之后提供的 spEL 的属性注入： spEL：Spring Expression Language /#{} 1234567891011//普通类型&lt;bean id=&quot;car&quot; class=&quot;&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;#&#123;&apos;奔驰&apos;&#125;&quot;&gt; &lt;property name=&quot;price&quot; value=&quot;#&#123;123&#125;&quot;&gt;&lt;/bean&gt;//对象类型&lt;bean id=&quot;employee&quot; class=&quot;&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;#&#123;&apos;强强&apos;&#125;&quot;&gt; &lt;property name=&quot;car&quot; value=&quot;#&#123;car&#125;&quot;&gt;&lt;/bean&gt; 还能用另外一个类的属性或方法名来赋值，先创建这个类，要用属性的话，可以直接写get方法，不用定义成员变量的。 要想用哪个类中的方法，就得先实例化这个类 然后再 #{实例化类名.属性/方法} 就可以了 //定义要使用的类12345678910public class CarInfo &#123; //public String name; public String getName() &#123; return &quot;奔驰&quot;; &#125; public Double calculatePrice()&#123; return Math.PI * 100000; &#125;&#125; 复杂类型的属性注入list map propertise 等复杂的属性类型 list/数组 12345678910//如果list的是对象最里边可以用&lt;ref/&gt;&lt;bean id=&quot;&quot; class=&quot;&quot; &gt; &lt;property name=&quot;lists&quot;&gt; &lt;list&gt; &lt;value&gt;值&lt;/value&gt; &lt;value&gt;值&lt;/value&gt; &lt;value&gt;值&lt;/value&gt; &lt;list&gt; &lt;/property&gt;&lt;/bean&gt; map 12345678//如果map里边是对象&lt;entry key-ref=&quot;&quot; value-ref=&quot;&quot;/&gt;&lt;bean id=&quot;&quot; class=&quot;&quot; &gt; &lt;property name=&quot;maps&quot;&gt; &lt;map&gt; &lt;entry key=&quot;&quot; value=&quot;&quot; /&gt; &lt;map&gt; &lt;/property&gt;&lt;/bean&gt; map还有一种方式 需要生成set方法，并在map标签中添加 &lt;entry&gt; &lt;key&gt; &lt;value&gt;test1&lt;/value&gt; &lt;/key&gt; &lt;value&gt;AAA&lt;/value&gt; &lt;/entry&gt; propertise,键值对的形式 1234567&lt;bean id=&quot;&quot; class=&quot;&quot; &gt; &lt;property name=&quot;props&quot;&gt; &lt;props&gt; &lt;props key=&quot;&quot;&gt;值&lt;/props&gt; &lt;props&gt; &lt;/property&gt;&lt;/bean&gt; Spring的分模块开发就是可能有两个配置文件，分别配置不同的类 可以在加载配置文件时加载两个配置文件，用 ， 隔开 也可以只加载一个配置文件，然后在其中引入另外一个配置文件 &lt;import resource=&quot;applicationContext2.xml&quot;&gt; 如果引入的配置文件中的id有跟原配置文件的id相同的值，则会覆盖原来的。 案例中出现的问题将Dao配置到Spring 可以在配置service方法的时候把，Dao当作一个属性来配置，先把customerDao实例化，然后再引入到service配置文件中： 123456&lt;bean id=&quot;customerService&quot; class=&quot;com.itheima.crm.service.impl.CustomerServiceImpl&quot;&gt; &lt;property name=&quot;customerDao&quot; ref=&quot;customerDao&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;customerDao&quot; class=&quot;com.itheima.crm.dao.impl.CustomerDaoImpl&quot;&gt;&lt;/bean&gt; 配置监听器，使每次获取的都是同一个工厂类 为了避免每次用的时候，都创建一个工厂类，用监听器，在服务器启动的时候就让创建了工厂了，并存在ServletContext中，以后直接用就行 先引一个Spring的jar包：spring-web-4.2.4.RELEASE.jar 包中已经配好了监听器，直接配置就行： 在web下配置监听器 123456789 &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;//让上面那个监听器去加载下边的这个配置文件&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt; 获得工厂： 123456789//保存客户的方法:savepublic String save()&#123; //调用业务层，使用包中封装好的工具类获得servletContext中的工厂类 WebApplicationContext applicationContext = WebApplicationContextUtils.getWebApplicationContext(ServletActionContext.getServletContext_()); CustomerService customerService = (CustomerService) applicationContext.getBean(&quot;customerService&quot;); customerService.save(customer); return NONE;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Struts第四阶段]]></title>
      <url>%2F2016%2F06%2F25%2FStruts04%2F</url>
      <content type="text"><![CDATA[Struts2拦截器的概述什么是拦截器 拦截器是Struts2中的核心。其实就是一个类对Action的访问进行拦截。 拦截器与过滤器的区别： 过滤器过滤的是从客户端向服务器发送的请求。过滤器是可以过滤Html, JSP… 拦截器拦截的是从客户端向Action发送的请求。拦截器只能拦截Action，拦截器更细粒度的实施拦截。拦截到Action中具体的方法。 Struts2的执行流程： 请求访问Action，请求首先到达核心过滤器，过滤器会调用Dispather中的ServiceAction的方法 在这个方法内部，Struts2框架创建一个Action代理对象，执行代理对象中的execute方法，在execute内部方法调用Actioninvocatin中的invoke方法。 在invoke方法内部，递归调用拦截器的拦截的方法，如果没有下一个拦截器，执行目标Actioin，根据Action返回Result进行页面跳转，由Response做出响应。 自定义拦截器 实现Interceptor接口或者继承AbstractInterceptor类 配置拦截器 编写： 1234567891011121314public class InterceptorDemo1 extends AbstractInterceptor&#123; @Override public String intercept(ActionInvocation invocation) throws Exception &#123; System.out.println(&quot;InterceptorDemo1执行了...&quot;); String s = invocation.invoke(); System.out.println(&quot;InterceptorDemo1执行结束了...&quot;); return s; &#125;&#125; 配置拦截器 配置的时候会有顺序，默认的在前面，就先执行默认的，自己定义的在前面就先执行自己的 123456789//在&lt;package&gt;标签中配置&lt;interceptors&gt; &lt;interceptor name=&quot;名字&quot; class=&quot;拦截器路劲&quot; &gt;&lt;/interceptor&gt;&lt;/interceptors&gt;//**因为自定义之后默认的拦截器就不引用了，所以得引用一下默认的拦截器**&lt;interceptor-ref name=&quot;defaultStack&quot;&gt;//然后再&lt;action&gt; 标签中引用一下&lt;interceptor-ref name=&quot;拦截器名字&quot; /&gt; 2.还可以定义一个拦截器栈，在一块引用 123456789101112&lt;interceptors&gt; &lt;interceptor name=&quot;interceptor01&quot; class=&quot;路劲&quot; /&gt; &lt;interceptor name=&quot;interceptor02&quot; class=&quot;路劲&quot; /&gt; &lt;interceptor-stack name=&quot;myStack&quot;&gt; &lt;interceptor-ref name=&quot;defaultStack&quot;/&gt; &lt;interceptor-ref name=&quot;interceptor01&quot;/&gt; &lt;interceptor-ref name=&quot;interceptor02&quot;/&gt; &lt;/interceptor-stack&gt;&lt;/interceptors&gt;//引用的时候只需要引用拦截器栈就可以了&lt;interceptor-ref name=&quot;myStack&quot;/&gt; 案例：登陆页面错误信息回显错误信息：转发到登陆页面，否则actionerror用不了这里用到了actionerror 把错误信息存到值栈中 this.addactionError(&quot;错误信息&quot;); 在jsp中回显错误信息 &lt;s:actionerror/&gt; 登陆权限 编写拦截器 注：拦截一个方法用的是MethodFilterInterceptor 123456789101112131415public class PrivilegeInterceptor extends MethodFilterInterceptor&#123; @override protected String doIntercept(ActionInvocation invocation)&#123; //获得已存在的用户信息 User existUser = (User) ServletActionContext.getRequest().getSession().getAttribute(&quot;existUser&quot;); if(exiteUser!=null)&#123; return invocation.invoke(); &#125;else&#123; ActionSupport actionSupport=(ActionSupport)invocation.getAction(); actionSupport.addActionError(&quot;您还没有登陆！您还没有访问权限！&quot;); return actionSupport.LOGIN; &#125; &#125;&#125; 配置拦截器 12345678910//配置拦截器&lt;interceptors&gt; &lt;interceptor name=&quot;PrivilegeInterceptor&quot; class=&quot;。。。 &quot;/&gt;&lt;interceptors&gt;//在`action`中引用拦截器&lt;interceptor-ref name=&quot;PrivilegeInterceptor&quot;&gt; //因为在登陆的页面就不需要拦截了，所以可以加一个`param`来避免要拦截的页面 &lt;param name=&quot;excludeMethods&quot;&gt;登陆时的方法名&lt;/param&gt;&lt;/interceptor-ref&gt; 还得配一个全局的login，就拦截的信息转到login，dtd规定全局配置必须在拦截器下边 还有万一拦截之后发生错误，转到登陆页面，在登陆成功会发生嵌套效果，避免这种效果的方法是，在登陆的form标签上加一个target=&quot;_parent&quot; struts2的标签库通用的标签库Generi Tags 帮助文档中的Tag reference 传参数：&lt;s:param name=&quot;&quot; value=&quot;&quot;/&gt; 在遍历List集合的时候，放var里取出来时，可以加#,也可以不加，因为，他会在context中也放一个 123&lt;s:iterator value=&quot;&#123;&apos;a&apos;,&apos;b&apos;,&apos;c&apos;&#125;&quot; var=&quot;i&quot;&gt; &lt;s:property value=&quot;i&quot;/&gt;---&lt;s:property value=&quot;#i&quot;/&gt;&lt;/s:iterator&gt; 遍历一些数，把其中3的倍数变红，每次加10 123456789&lt;h2&gt;遍历&lt;/h2&gt;&lt;s:iterator begin=&quot;10&quot; end=&quot;300&quot; step=&quot;10&quot; var=&quot;i&quot; status=&quot;sta&quot;&gt; &lt;s:if test=&quot;#sta.count % 3 == 0&quot;&gt; &lt;font color=&quot;red&quot;&gt;&lt;s:property value=&quot;i&quot;/&gt;&lt;/font&gt; &lt;/s:if&gt; &lt;s:else&gt; &lt;s:property value=&quot;i&quot;/&gt; &lt;/s:else&gt;&lt;/s:iterator&gt; UI标签库 UI Tags 优势：点文字可以获得焦点，文本框会加一些基本的样式，例如换行啊。。。 会提供一套默认的样式样式 xhtml 可以不用，在表单上加一个theme=&quot;simple&quot;,或者在常量上改变，这样所有的就都不能用了 UI标签的数据回显：优点： 将查询到的数据显示到指定文本框 数据校验或类型转换出错情况下 数据除了密码都会回显，并且会显示错误信息，密码也要回显添加一个showpassword=true 是在root区存着的。 Struts2的注解开发 引包 struts-convention-plugin 写好action之后加123456789@ParentPackage(&quot;struts-default&quot;)@Namespace(&quot;/&quot;)public class HelloAction extends ActionSupport&#123; @Action(value=&quot;访问路劲相当于action中的name&quot;，results=&quot;返回值&quot;) public String execute()&#123; syso(); return ...; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[xml]]></title>
      <url>%2F2016%2F06%2F18%2Fxml%2F</url>
      <content type="text"><![CDATA[XML和反射技术XML技术什么是XML，作用是什么可扩展标记语言（Extensible Markup Language ），XML是一种数据格式，类似 HTML，是使用标签进行内容描述的技术，与HTML不 同的是，XML的标签和属性 都是根据业务需求自定义的。 XML在企业开发中主要有两种应用场景： XML可以作为数据交换的载体，也就是说使用XML格式进行数据的传输目前有一门数据交换的语言慢慢替代xml —- json XML可以作为配置文件的载体，例如后续我们学习的servlet、struts2、hibernate 的配置都是通过XML进行配置的（常使用的） 如何去写一个XML（重点） XML的编写要比HTML简单，根据实际的业务场景自行编写有意义的标签和属性， 例如创建一个以.xml为后缀名的文件，编写描述一个网上商城的商品信息的xml 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;store&gt; &lt;product category=&quot;手机数码&quot;&gt; &lt;pid&gt;100&lt;/pid&gt; &lt;pname&gt;华为手机&lt;/pname&gt; &lt;price&gt;3000&lt;/price&gt; &lt;/product&gt; &lt;product category=&quot;电脑办公&quot;&gt; &lt;pid&gt;200&lt;/pid&gt; &lt;pname&gt;三星笔记本&lt;/pname&gt; &lt;price&gt;5000&lt;/price&gt; &lt;/product&gt; &lt;product category=&quot;大型家电&quot;&gt; &lt;pid&gt;300&lt;/pid&gt; &lt;pname&gt;海尔洗衣机&lt;/pname&gt; &lt;price&gt;4000&lt;/price&gt; &lt;/product&gt;&lt;/store&gt; xml编写时也要符合一定的规则： xml文件的后缀名是.xml xml有且只有一个根标签 xml的标签是尖括号包裹关键字成对出现的，有开始标签有结束标签，关键字是自 定义的，xml也可以有空标签/自关闭标签 xml允许有属性，属性也是根据需要自定义的，属性格式：属性=“属性值”，多 个属性之间使用空格隔开 xml是区分大小写的 —– html不区分大小写 xml的组成： 文档声明：&lt;?xml version=”1.0” encoding=”UTF-8”?&gt; 根标签，例如： 其他标签，例如： 属性，例如：category=”电脑办公” 文本，例如：三星笔记本 注释，例如： CDATA区：CDATA区可以保证数据的原文输出例如：&lt;![CDATA[原文显示的内容]]&gt; 如何去约束一个XML（了解） 提到约束一个XML，必须要理解为什么对XML要进行约束？ 因为XML的标签都是自定义的，xml在作为框架配置时不能很好的规范开发者书写， 所以要使用约束告知开发者怎样去配置一个xml XML的约束有两种： DTD约束 Schema约束 DTD约束 例如：我们要约束上述编写的store.xml,相应 的DTD约束如下 123456&lt;!ELEMENT store (product+)&gt;&lt;!ELEMENT product (pid,pname,price)&gt;&lt;!ELEMENT pid (#PCDATA)&gt;&lt;!ELEMENT pname (#PCDATA)&gt;&lt;!ELEMENT price (#PCDATA)&gt;&lt;!ATTLIST product category CDATA #REQUIRED&gt; dtd的语法摘要： 使用ELEMENT描述元素 括号() 代表标签体的内容 子标签—标签名称 子标签有多少个？ 通过符号描述： 123+：代表一个或多个 至少有一个*：代表0个或的多个 有没有都行?：代表0个或一个 子标签的顺序： 使用逗号, 或 | 任意选择一个 文本—-#PCDATA 使用ATTLIST描述某个元素身上的属性属于哪个标签 属性名称 属性的类型 该属性的是否必须 该属性的是否必须：+ `#REQUIRED` 代表概述户型必须 + `#IMPLIED` 代表属性随意 写也行不写也行 引入约束 在xml中引入本地的DTD文件：&lt;!DOCTYPE store SYSTEM &quot;store.dtd&quot;&gt; 其中：SYSTEM代表本地dtd文件 在xml中引入互联网上的DTD文件： &lt;!DOCTYPE store PUBLIC &quot;//UNKNOWN/&quot; &quot;unknown.dtd&quot;&gt; 其中：PUBLIC代表互联网上的DTD + //UNKNOWN/：此位置代表为引入的DTD取一个名称，随意取 + unknown.dtd：此位置代表引入的DTD的路径，一般是互联网路径 Schema约束例如：我们要约束上述编写的store.xml,相应 的Schema约束如下 Schema中分为简单元素和复杂元素 简单元素：标签仅仅包含文本标签体的元素 复杂元素：标签包括子标签或属性的元素 Schema约束是怎样引入到XML中的？ 例如： web工程的核心配置文件web.xml spring的核心配置文件applicationContext.xml 如何去解析一个XML（了解） XML的解析就是将有用的信息从XML文档中解析出来，例如上述的store.xml，怎 样通过API将store.xml中的属性值和文本解析出来。 常用的解析方式 DOM解析：将文档整体加载到内存形成一个DOM树在解析，支持文档的增删改查 和文档的回写。 SAX解析：读取一行解析一行，只支持文档的查询，也不支持文档的回写。 PULL解析：类似SAX解析，Android的常用解析技术。 常用的解析技术 JAXP：SUN公司的官方解析技术，支持DOM解析和SAX解析 JSOUP：一种解析HTML的特定解析的开发包 JDOM：开源组织的DOM方式的解析技术 DOM4J：JDOM的分离版，开源，Hibernate底层的XML解析技术 DOM4J解析技术 DOM4J是第三方开源的解析技术，首先要下载dom4j.jar 将其中的jar包导入工程 解析XML的步骤： 在dom4j的lib目录下有一个jaxen-1.1-beta-6.jar，导入这个jar包可以进行XPath的解析。 XML的实际应用场景（理解） 实际开发中，我们一般会使用各种各样的框架的进行企业开发，而这些框架一般都会 将某些公共的功能写好了，我们需要做的只需要按照框架提供的约束进行框架的配置 就可以了，当我们使用XML配置好框架后，在运行时，框架底层会解析我们配置XML 文档获取有用的信息，从而根据我们的需求实现某些功能。 所以，实际开发中我们很少会自己编写XML约束和解析XML]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Struts第三阶段]]></title>
      <url>%2F2016%2F06%2F17%2FStruts03%2F</url>
      <content type="text"><![CDATA[Struts2OGNL的概述 OGNL(Object Graph Navigation Language):对象图导航语言是一个独立的表达式语言，Struts2感觉OGNL很强大，将OGNL引入到自身 OGNL比EL强大很多倍的表达式的语言。（EL获取的数据来源与四个作用域，EL提供11个Web对象） 作用： OGNL的要素context（OgnlContext），root(CompoundRoot)，表达式 OGNL在java中的使用(了解）1234567891011121314151617181920212223242526272829303132333435363738394041424344//获取对象的方法@Testpublic void demo01()&#123; //获得数据 OgnlContext context=new OgnlContext(); Object obj = Ognl.getValue(&quot;&apos;helloworld&apos;.length()&quot;,context,context.getRoot()); System.out.println(obj);&#125;//获取静态对象的方法@Testpublic void demo02()&#123; //获得数据 OgnlContext context=new OgnlContext(); Object obj = Ognl.getValue(&quot;@java.lang.Math@random()&quot;,context,context.getRoot()); System.out.println(obj); //打印一个1以内的小数&#125;//获取root中的数据@Testpublic void demo03()&#123; Product product = new Product(); product.setName(&quot;john&quot;); //获得数据 OgnlContext context=new OgnlContext(); context.setRoot(product); Object obj = Ognl.getValue(&quot;name&quot;,context,context.getRoot()); System.out.println(obj);&#125;//OGNL获取context的数据//context中存入的List集合，其他的普通的值//获取context数据需加#@Testpublic void demo03()&#123; //获得context OgnlContext context=new OgnlContext(); context.put(&quot;key&quot;,&quot;阿斯顿&quot;); Object obj =Ognl.getValue(&quot;#key&quot;,context,context.getRoot()); System.out.println(obj);&#125; 值栈什么是值栈 ValueStack：相当于Struts2的数据的中转站，ValueStack贯穿了整个action的生命周期。 Action是多例的，一次请求服务器请求就会创建一个Action，同时会为这个Action创建一个ValueStack对象。Struts2通过OGNL表达式获取值栈的数据。 ValueStack是Struck2的一个接口，OGNLValueStack是该接口的实现类。 值栈的内部结构 值栈分为root区跟context区，root(CompoundRoot)区是一个list集合，context(OgnlContext)是一个map 操作值栈一般是操作root context中存入了root，还有session等多个域 查看值栈的内部结构： debug看结构,在action中运行下面获取ValueStackValueStack valueStack=ActionContext.getContext().getValueStack(); 让其跳转到一个页面，页面上加一个&lt;s:debug/&gt;,运行后点开 ActionContext与值栈的关系 ActionContext：代表Action的上下文对象 通过源码查看：Struts的核心过滤器执行的过程中，创建ActionContext对象，在创建ActionContext对象的同时创建一个ValueStack，并且将ValueStack存入到ActionContext中。所以通过ActionContext对象，获得值栈。其实在ValueStack的内部有一个ActionContext的引用。 ActionContext中有ValueStack的引用，ValueStack中也有ActionStack的引用。 ActionContext之所以之能访问Servlet的API其实也是依赖了值栈的。 2.4如何获得值栈其实在request中也存放了ValueStack： 核心过滤器—&gt;执行action—&gt;serviceAction—&gt;proxy代理类中。 获取值栈：通过ActionContext获取 1ValueStack valueStack=ActionContext.getContext().getValueStack(); 通过request域对象 1ValueStack valueStack02=(ValueStack)ServletActionContext.getRequest().getAttribute(ServletActionContext.STRUTS_VALUESTACK_KEY); 两种获取值栈的方法是一样的，因为同一个action类只能加载一个值栈 如何操作值栈对象(操作root区)存入值栈一. 直接操作值栈对象, 在值栈中封装数据 123456//void set(String name,Object value); ----将数据封装到map集合中在存入，一般操作字符串valueStack.set(&quot;name&quot;,&quot;value&quot;);//void push(Object obj); -----直接将对象压入值栈中，一般操作对象valueStack.push(User); 二. 直接在Action对象中提供成员属性 当Action的实例被创建了，默认的情况下(没有手动操作值栈，没有实现模型驱动)，Action对象在栈顶的位置，Action的属性也会在栈顶位置，提供一个属性，对该属性提供一个get方法就可以了。 12345678910111213public class valueStackAction extends ActionSupport&#123; private String name; public String getName()&#123; return name; &#125; public String execute()&#123; name=&quot;张三&quot;; return SUCCESS; &#125;&#125; 获取值栈（root） 在jsp中需要先引标签库，&lt;%@ taglib uri=&quot;/struts-tags&quot; prefix=&quot;s&quot; %&gt; 使用OGNL表达式 1234567//s:property标签中value的属性放的是OGNL的表达式//调用对象的方法&lt;s:property value=&quot;&apos;HelloWorld&apos;.length()&quot;/&gt;//调用静态对象的方法//在struts中默认关掉了静态访问的方法，需要开开，现在struts.xml配置常量&lt;s:property value=&quot;@java.lang.Math@random&quot;/&gt; 取出存入的值 1234567//通过set存入的字符串值&lt;s:property value=&quot;name&quot;/&gt;//通过set存入的list集合,list集合中存放的对象中有name属性&lt;s:property value=&quot;list[0].name&quot;/&gt;//通过push存入对象&lt;s:property value=&quot;对象的属性&quot;/&gt; 操作context区域的区域在action存就是通过ActionContext对象,来操作API 在jsp取12345&lt;s:property value=&quot;#session.name&quot;/&gt;&lt;s:property value=&quot;#request.name&quot;/&gt;&lt;s:property value=&quot;#appliaction.name&quot;/&gt; &lt;s:property value=&quot;#attr.name&quot;/&gt; 表示取域最小中的值，没有的话找大一级的pageContext /&lt; request /&lt; session /&lt; application &lt;s:property value=&quot;#parameters.name&quot;/&gt;表示取传过来的属性值，没有就为空 EL也可以获取值栈的数据EL也能获取到值栈的数据，因为过滤器中，会增强request，查看值栈中是否有数据，有的话存到request域中。 OGNL中的特殊字符的使用#号 获取context部分的数据 构建map集合 单选按钮(其实也使用的map集合) 或 %号 强制解析OGNL表达式数据回显的时候，取出域中的值 强制不解析OGNL表达式 $符 在配置文件中获取值栈中的数据(通过OGNL获取)。 文件下载的时候： 123&lt;result type=&quot;stream&quot;&gt; &lt;param name=&quot;Content-Disposition&quot;&gt;attachement;filename=$&#123;fileName&#125;&lt;/param&gt;&lt;/result&gt; 国际化： 1234message_zh_CN.propertiesname=您好：$&#123;#request.name&#125;message_en_US.propertiesname=Hello:$&#123;#request.name&#125; OGNL遍历前提是list是一个Customer类型的集合： 123&lt;s:iterator value=&quot;list&quot;&gt; &lt;s:property value=&quot;custName&quot;/&gt;&lt;/s:iterator&gt; s标签不能嵌套s标签，html标签中能]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Struts第二阶段]]></title>
      <url>%2F2016%2F06%2F13%2FStruts02%2F</url>
      <content type="text"><![CDATA[struts2Struts2访问Servlet的API完全解耦和的方式实现Servlet的API的访问 获取ActionContextActionContext actionContex=ActionContext.getContext(); 接受参数：解耦和的方式通过ActionContext中的方法实现： 123456789101112Map&lt;String,Object&gt; getParamters(); //Object是一个字符串类型的数组Map&lt;String,Object&gt; getSession();Map&lt;String,Object&gt; getApplication();void setSession(Map&lt;String,Object&gt; session);void setApplication(Map&lt;String,Object&gt; application);//向request中存数据actionContext.put(String name,Object object);//向session中存数据actionContext.getSession.put(String name,Object object);//向application中存数据(ServletContext对象)actionContext.getApplication().put(String name,Object object); post提交不用管中文action会管了,get提交需要设置 通过实现特定的接口来实现Servlet的API的访问 让action类去实现ServletRequestAware接口，然后在成员位置定义一个HttpServletRequest变量，下边重写一个setServletRequest方法，让成员的request等于方法中的，可以当作正常的request用。 123456789101112131415161718192021222324252627282930313233public class RequestDemo2Action extends ActionSupport implements ServletRequestAware,ServletContextAware&#123; private HttpServletRequest request ; private ServletContext application; @Override public String execute() throws Exception &#123; // 接收参数:需要使用request对象。 Map&lt;String, String[]&gt; parameterMap = request.getParameterMap(); for (String key : parameterMap.keySet()) &#123; String[] value = parameterMap.get(key); System.out.println(key+&quot; &quot;+Arrays.toString(value)); &#125; // 向request域中存值: request.setAttribute(&quot;reqName&quot;, &quot;r郝天一&quot;); // 向session域中存值： request.getSession().setAttribute(&quot;sessName&quot;, &quot;s郝思聪&quot;); // 向application域中存值： application.setAttribute(&quot;appName&quot;, &quot;a郝冠希&quot;); return SUCCESS; &#125; @Override public void setServletRequest(HttpServletRequest request) &#123; this.request = request; &#125; @Override public void setServletContext(ServletContext application) &#123; this.application = application; &#125;&#125; 如果想用ServletContext对象，则在实现一个ServletContextAwre接口，方式跟上边的一样。 通过ServletActionContext的静态方法实现Servlet的API的访问 struts核心包中的api 12345//获取request对象HttpServletRequest request = ServletActionContext.getRequest();Map(String,String[]) paramterMap=request.getParameterMap();//获取ServletContext参数ServletContext application=ServletActionContext.getServletContext(); Struts2的数据的封装Struts2的多例 因为action是多例的，意思就是每次刷新页面都会重新执行action类多例的话就可以使用成员变量，创建Service的时候，就可以放成全局。 属性驱动 Struts既有控制层，又有模型层。 提供属性的set方法完成数据的封装 在action类中，定义要接受的属性的成员变量，只提供set方法，即可获取属性值 这种方式应用的不多，因为还需要手动装到对象中。 在页面中提供表达式（OGNL）的方式完成数据封装(直接封装到实体对象中) 在页面中这样写name,前面的user必须跟action中成员方式的对象名一致。 在action类中的成员位置加一个实体类对象，并提供get跟set方法。 123456789101112131415 public class User2Action extends ActionSupport&#123; private User user; // 需要提供get和set方法: public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; @Override public String execute() throws Exception &#123; System.out.println(user); return NONE; &#125;&#125; 注： 在第二种方法中，必须有get set方法 因为属性驱动是在拦截器中执行的，他需要把action中的对象实例化，所以要get到，如果不给提供get方法，则，每次封装的时候都会自动创建一个新的实例对象，这样会导致使用这个对象时只会有第一个封装进来的值 拦截器在strut-default.xml中 模型驱动采用模型驱动的方式来实现(推荐)： 页面即用普通页面。 让action来实现一个 ModelDriver/ 接口,里面必须手动构建对象。T是要封装的那个实体的类型 OGNL表达式的方式和模型驱动都有使用的。模型驱动通常会使用的方式。有一个缺点，就是只能封装到一个对象中，如果想封装到多个对象，就需要用到OGNL Struts2中复杂类型数据的封装封装到List集合中页面： 12345678910&lt;h1&gt;批量插入商品&lt;/h1&gt;&lt;form action=&quot;$&#123; pageContext.request.contextPath &#125;/product1Action.action&quot; method=&quot;post&quot;&gt; 商品名称:&lt;input type=&quot;text&quot; name=&quot;list[0].name&quot;&gt;&lt;br/&gt; 商品价格:&lt;input type=&quot;text&quot; name=&quot;list[0].price&quot;&gt;&lt;br/&gt; 商品名称:&lt;input type=&quot;text&quot; name=&quot;list[1].name&quot;&gt;&lt;br/&gt; 商品价格:&lt;input type=&quot;text&quot; name=&quot;list[1].price&quot;&gt;&lt;br/&gt; 商品名称:&lt;input type=&quot;text&quot; name=&quot;list[2].name&quot;&gt;&lt;br/&gt; 商品价格:&lt;input type=&quot;text&quot; name=&quot;list[2].price&quot;&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;批量导入&quot;&gt;&lt;/form&gt; Action： 123456789101112131415161718192021222324/** * Struts2复杂数据类型的封装：封装到List集合中 * @author jt * */public class Product1Action extends ActionSupport&#123; private List&lt;Product&gt; list; public List&lt;Product&gt; getList() &#123; return list; &#125; public void setList(List&lt;Product&gt; list) &#123; this.list = list; &#125; @Override public String execute() throws Exception &#123; for (Product product : list) &#123; System.out.println(product); &#125; return NONE; &#125;&#125; 封装到Map集合页面: 12345678910&lt;h1&gt;批量插入商品:封装到Map集合&lt;/h1&gt;&lt;form action=&quot;$&#123; pageContext.request.contextPath &#125;/product2Action.action&quot; method=&quot;post&quot;&gt; 商品名称:&lt;input type=&quot;text&quot; name=&quot;map[&apos;one&apos;].name&quot;&gt;&lt;br/&gt; 商品价格:&lt;input type=&quot;text&quot; name=&quot;map[&apos;one&apos;].price&quot;&gt;&lt;br/&gt; 商品名称:&lt;input type=&quot;text&quot; name=&quot;map[&apos;two&apos;].name&quot;&gt;&lt;br/&gt; 商品价格:&lt;input type=&quot;text&quot; name=&quot;map[&apos;two&apos;].price&quot;&gt;&lt;br/&gt; 商品名称:&lt;input type=&quot;text&quot; name=&quot;map[&apos;three&apos;].name&quot;&gt;&lt;br/&gt; 商品价格:&lt;input type=&quot;text&quot; name=&quot;map[&apos;three&apos;].price&quot;&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;批量导入&quot;&gt;&lt;/form&gt; Action: 12345678910111213141516171819202122232425/** * Struts2的复杂数据的封装：Map集合的封装 * @author jt * */public class Product2Action extends ActionSupport&#123; private Map&lt;String,Product&gt; map; public Map&lt;String, Product&gt; getMap() &#123; return map; &#125; public void setMap(Map&lt;String, Product&gt; map) &#123; this.map = map; &#125; @Override public String execute() throws Exception &#123; for (String key : map.keySet()) &#123; Product product = map.get(key); System.out.println(key+&quot; &quot;+product); &#125; return NONE; &#125;&#125; Struts中结果页面的配置结果页面的分类： 全局结果页面 可以对所有的action都有效 局部结果页面 在 /&lt; action /&gt; 内部配置 /&lt; result /&gt; ,只会对当前的Action有效。 如果有全局页面跟局部页面同时存在的时候，首先要看局部页面。 全局结果页面的配置12345&lt;package&gt; &lt;global-results&gt; &lt;result name=&quot;success&quot;&gt;地址。。。&lt;/result&gt; &lt;/global-results&gt;&lt;/package&gt; 局部结果页面的配置12345&lt;package&gt; &lt;action&gt; &lt;result name=&quot;success&quot;&gt;地址。。。&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; Struts2结果页面类型的配置 /&lt; result /&gt; 标签上还有一个属性： name ：逻辑视图名称。 type ：页面跳转的类型 dispather ：默认值，转发，转发到jsp页面 chain ：转发到一个Action redirect ：重定向。重定向到jsp redirectAction ：重定向到一个Action，重定向的时候如果不是在一个命名空间中，可以自己加上属性，（在result下面加param标签） stream ：文件下载的时候 struts2中内置数据类型的转换 会把传过来的特殊数据类型转换为实体中需要的类型，integer，date都能封装。 都是在拦截器执行的。 当转换失败时，会到Workflow拦截器，然后查看是否有这个错误，如果有会运行一个input视图中有错误信息，跳转到input的页面中。 例如Integer中添了一个字母。 可以在配置文件中，设置一个input的跳转页面，当有错误时，会跳转到这个页面 这个页面中可以加一个标签，显示错误信息 1234 &lt;%@ taglib uri=&quot;/struts-tags&quot; prefix=&quot;s&quot; %&gt; //可以加两个标签，是哪个错误会显示哪个错误 &lt;s:actionerror/&gt; &lt;s:fielderror/&gt; 注： 有的时候elipse会编译前一段时间的代码，修改之后不会及时编译最新的，可以把tomcat中的webapps项目中的class文件删除，然后再在elispe中，project/build all手动编译一下。 struts2中的带的log4j是2.2版本的，hibernate中是1.几版本的，所以不能把hibernate中的配置文件中copy过来直接用，可以在struts2提供的项目模板中找一个，2.2版本的配置文件是 .xml 的]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Struts第一阶段]]></title>
      <url>%2F2016%2F06%2F10%2FStruts01%2F</url>
      <content type="text"><![CDATA[strust2入门与介绍什么是Struts2是基于MVC设计模式的WEB层框架 WEB层框架Struts1，WebWork，Struts2，SpringMVC Struts2的内核是基于WebWork的 前端控制器模式 Struts2的入门 解压之后： apps ：Struts2 里面提供的一些测试的应用 docs ：Struts2 里面的帮助文档 lib ：Struts2的提供的开发的jar包 src ：Struts2提供的源码 导包，导最少的包，找到blank项目下的jar包，导这些即可 写一个jsp页面，跳转的目标的路径是xxx.action. &lt;h3&gt; &lt;a href=&quot;${pageContext.request.contextPath}/hello.action&quot;&gt;访问Struts2框架&lt;/a&gt;&lt;/h3&gt; 配置Struts2的核心过滤器，前端控制器(完成部分功能)，会默认执行拦截器（过滤器路径在struts2-core/包后边是filter/StrutsPrepareAndExecuteFilter.class），然后会跳到配置文件中 写action类里面有一个execute方法，方法的格式是固定的：必须是public ，返回值是String，方法名execute，方法中没有参数 配置action类的配置文件 struts2默认的配置文件是struts.xml，写在src下。 配置文件写法：copy约束，struts标签，里边有package package标签属性：name extends namespace package里边有action：name class类action的全路径 修改struts2配置文件：加一个result标签1234567&lt;struts&gt; &lt;package name=&quot;demo01&quot; extends=&quot;struts-default&quot; namespace=&quot;/&quot;&gt; &lt;action name=&quot;jsp中的xxx&quot; class=&quot;类action的全路径&quot;&gt; &lt;result name=&quot;success(action传过来的字符串)&quot;&gt;要跳转的路径&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; struts2的执行流程当一个页面发送一个请求的时候，首先经过核心过滤器(StrutsPrepareAndExecuteFilter),在这个过滤器中其实会执行一组拦截器(这组拦截器就完成了部分的功能)，执行完这组拦截器之后，执行目标Action，返回一个结果视图，根据返回结果跳转不同界面。 struts2常见的配置struts2的配置文件的加载顺序：（了解）过滤器StrutsPrepareAndExecuteFilter会在服务器启动时初始化。在过滤器中会执行dispatcher = init.initDispatcher(config);,然后在执行dispatcher.init();,再然后会执行下面的配置文件 123456init_DefaultProperties(); // [1] -----default.properties 核心包里第一个包下边呢init_TraditionalXmlConfigurations(); // [2] -----struts-default.xml,struts-plugin.xml,struts.xmlinit_LegacyStrutsProperties(); // [3] -----struts.propertiesinit_CustomConfigurationProviders(); // [5] -----客户自定义提供类init_FilterInitParameters() ; // [6] -----加载web.xml中过滤器中的参数init_AliasStandardObjects() ; // [7] -----加载自定义类 这几个值规定了加载配配置文件的顺序: default.properties struts-default.xml struts-plugin.xml struts.xml struts.properties web.xml 主要用的后三个，顺序是由上到下 struts2的主要配置文件：struts2中Action的配置(struts.xml) 包的配置(package) Struts2为了更好的管理Action，将Action分包进行管理的。 /&lt; package /&gt;包中的顺序 name :包名，一个配置文件中不要出现重复的包名 extends：继承别的包，通常继承struts-default namespace：名称空间，跟下边的/中的name属性共同决定访问路劲 namespace=””; 最后在找这个，在/之后 namespace=”/“; 没有指定的名称的执行这个，一般就会写这个 namespace=”/aaa”; 首先找带名称空间的，这个是最大化 abstract：是否可以被别的包继承，true表示可以应用于其他包的继承 Action的配置 /&lt; action /&gt; 的配置 name：与名称空间共同决定访问路劲 class：Action类的全路径 method：Action中要执行的方法的名称，默认值execute Structs2中常量的位置Struct中常量有三个配置的位置: struts.xml（推荐）&lt;constant name=&quot;struts.action.extension&quot; value=&quot;action&quot;&gt; struts.propertiesstruts.actioin.extension=action web.xml 12345 // &lt;filter&gt;中加一个 &lt;init-param&gt; &lt;param-name&gt;struts.actioin.extension&lt;/param-name&gt; &lt;param-value&gt;action&lt;/param-value&gt; &lt;/init-param&gt; 这里的struts.actioin.extension常量，表示访问的时候，路径的后缀名要加什么，默认是action, ,表示action跟空 Struts2分模块开发的配置在struts2.xml 配置文件中用&lt;include file=&quot;要包含的子配置文件&quot;/&gt; Action的编写Action本身是一个POJO的类POJO(plain ordinary java object)的类,简单的java类：没有继承任何类。 Action实现一个Action的接口在action的接口中，提供了个常量（逻辑视图名称） SUCCESS ：成功 NONE ：不跳转 ERROR ：跳转到错误的页面 INPUT ：表单校验 LOGIN ：跳转到登陆页面 Action继承一个ActionSupport的类ActionSupport实现Action的接口，还有好多扩展的方法在父类里面的execute里，直接返回的SUCCESS。 以后写的时候最好使用这种方法。 Action的访问现在已经可以访问到Action，但是一次请求对应了一个Action的，需要一个模块的多次请求添加到一个Action中。 可以在struts.xml中配配置1234567891011121314151617181920212223242526272829303132333435363738//页面&lt;h1&gt;客户管理&lt;/h1&gt;&lt;h3&gt;&lt;a href=&quot;$&#123; pageContext.request.contextPath &#125;/addCustomer.action&quot;&gt;添加客户&lt;/a&gt;&lt;/h3&gt;&lt;h3&gt;&lt;a href=&quot;$&#123; pageContext.request.contextPath &#125;/findCustomer.action&quot;&gt;查询客户&lt;/a&gt;&lt;/h3&gt;&lt;h3&gt;&lt;a href=&quot;$&#123; pageContext.request.contextPath &#125;/updateCustomer.action&quot;&gt;修改客户&lt;/a&gt;&lt;/h3&gt;&lt;h3&gt;&lt;a href=&quot;$&#123; pageContext.request.contextPath &#125;/deleteCustomer.action&quot;&gt;删除客户&lt;/a&gt;&lt;/h3&gt;//编写actionpublic class CustomerAction extends ActionSupport&#123; public String add()&#123; System.out.println(&quot;保存客户...&quot;); return NONE; &#125; public String find()&#123; System.out.println(&quot;查询客户...&quot;); return NONE; &#125; public String update()&#123; System.out.println(&quot;修改客户...&quot;); return NONE; &#125; public String delete()&#123; System.out.println(&quot;删除客户...&quot;); return NONE; &#125;&#125;//配置action&lt;!-- 配置package包 --&gt; &lt;package name=&quot;demo3&quot; extends=&quot;struts-default&quot; namespace=&quot;/&quot;&gt; &lt;!-- 配置action --&gt; &lt;action name=&quot;addCustomer&quot; class=&quot;com.itheima.struts2.action3.CustomerAction&quot; method=&quot;add&quot;/&gt; &lt;action name=&quot;findCustomer&quot; class=&quot;com.itheima.struts2.action3.CustomerAction&quot; method=&quot;find&quot;/&gt; &lt;action name=&quot;updateCustomer&quot; class=&quot;com.itheima.struts2.action3.CustomerAction&quot; method=&quot;update&quot;/&gt; &lt;action name=&quot;deleteCustomer&quot; class=&quot;com.itheima.struts2.action3.CustomerAction&quot; method=&quot;delete&quot;/&gt; &lt;/package&gt; 通配符的方式//第一个*代表的数就是传过来的那个参数的后部分，正好是method里的东西 12345678910111213141516171819202122232425262728293031//页面&lt;h1&gt;商品管理&lt;/h1&gt;&lt;h3&gt;&lt;a href=&quot;$&#123; pageContext.request.contextPath &#125;/product_add.action&quot;&gt;添加客户&lt;/a&gt;&lt;/h3&gt;&lt;h3&gt;&lt;a href=&quot;$&#123; pageContext.request.contextPath &#125;/product_find.action&quot;&gt;查询客户&lt;/a&gt;&lt;/h3&gt;&lt;h3&gt;&lt;a href=&quot;$&#123; pageContext.request.contextPath &#125;/product_update.action&quot;&gt;修改客户&lt;/a&gt;&lt;/h3&gt;&lt;h3&gt;&lt;a href=&quot;$&#123; pageContext.request.contextPath &#125;/product_delete.action&quot;&gt;删除客户&lt;/a&gt;&lt;/h3&gt;//编写Actionpublic class ProductAction extends ActionSupport&#123; public String add()&#123; System.out.println(&quot;保存商品...&quot;); return NONE; &#125; public String find()&#123; System.out.println(&quot;查询商品...&quot;); return NONE; &#125; public String update()&#123; System.out.println(&quot;修改商品...&quot;); return NONE; &#125; public String delete()&#123; System.out.println(&quot;删除商品...&quot;); return NONE; &#125;&#125;//配置Action: &lt;!-- 通配符的方式的配置 --&gt; &lt;action name=&quot;product_*&quot; class=&quot;com.itheima.struts2.action3.ProductAction&quot; method=&quot;&#123;1&#125;&quot;/&gt; 更通配的写法： 动态方法访问在struts2中默认是关闭的，需要开启，在default.porperties中，需要在配置文件中修改称true &lt;constant name=&quot;struts.enable.DynamicMethodInvocation&quot; value=&quot;true&quot;&gt; 12345678910//页面&lt;h1&gt;订单管理&lt;/h1&gt;&lt;h3&gt;&lt;a href=&quot;$&#123; pageContext.request.contextPath &#125;/order!add.action&quot;&gt;添加订单&lt;/a&gt;&lt;/h3&gt;&lt;h3&gt;&lt;a href=&quot;$&#123; pageContext.request.contextPath &#125;/order!find.action&quot;&gt;查询订单&lt;/a&gt;&lt;/h3&gt;&lt;h3&gt;&lt;a href=&quot;$&#123; pageContext.request.contextPath &#125;/order!update.action&quot;&gt;修改订单&lt;/a&gt;&lt;/h3&gt;&lt;h3&gt;&lt;a href=&quot;$&#123; pageContext.request.contextPath &#125;/order!delete.action&quot;&gt;删除订单&lt;/a&gt;&lt;/h3&gt;//配置。不用写method&lt;!-- 动态方法的访问 --&gt;&lt;action name=&quot;order&quot; class=&quot;com.itheima.struts2.action3.OrderAction&quot;/&gt; 跳转之后，如果result里边是success可以省略。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git]]></title>
      <url>%2F2016%2F05%2F26%2Fgit%2F</url>
      <content type="text"><![CDATA[github分布式管理控制 将远程仓库中克隆到本地 客户端将添加、修改、删除等操作的文件先添加到一个暂存区 将暂存区中的所有文件提交到版本库中 将本地版本库推送到远端仓库 github Github 是为开发者提供Git仓库的托管服务。是一个让开发者与朋友、同事及陌生人共享代码的完美平台。 http://www.github.com github的作用 帮你托管仓库 社交化编程（程序员的新浪微博） Git在一个项目的跟目录下可以添加一个README.md文件，在github项目中会在首页的下边显示他的内容，默认为开始界面 git基本命令 git clone 仓库名称 //从远程仓库拿到项目 git init 仓库名称 只要执行了该命令，git会帮你自动创建一个目录，然后在该目录下生成一个’.git’ git status 查看当前工作树的状态 git add 文件名 将操作的文件添加到暂存区，待提交 git add –all 把所有修改的文件存到暂存区 git commit -m “提交日志” –author=”你的用户名 &lt;邮箱&gt;” 上面这条命令表示将暂存区中的文件提交到本地仓库 使用 git commit, 最好告诉版本仓库，你这提交的作者是谁，还有邮箱，方便联系 git log 查看提交日志 配置用户名跟邮箱 git config –global user.name “用户名” git config –global user.email “邮箱” 将本地文件提交到远程仓库 git push 从远程仓库拉取最新东西 git pull github Pages部署静态网站 创建一个仓库，用户名必须是 用户名.github.io 以后访问的时候登陆这个域名即可 把项目clone到本地，然后把项目考进去，然后提交到本地仓库 push 到远程仓库即可 会把项目中的index.html设置为首页，直接访问用户名.github.io 就能看到项目的首页。 使用 hexo 快速搭建个人博客到Github 安装 note 环境 在你的终端执行：npm install hexo-cli -g 使用hexo init 目录名称 生成一个博客系统 切换到刚才生成的博客目录 然后执行 hexo server 启动一个本地服务器 修改博客 如果想新增博客，可以先退出服务器，然后进入博客的目录 hexo new 文件名称 会在source中的_posts中生成一个markdown笔记， 修改配置在 _config.yml 部署 HEXO 第一在 github 上新建一个空仓库(也就是你的域名仓库) 第二，修改 _config.yml 中的 deloy 选项为如下： 123deloy: type:git repo:刚才创建的仓库地址 第三：在终端执行npm install hexo -deployer -git --save安装一个自动提交插件 第四：在你的博客目录的根目录下执行 hexo deploy 这样的话Hexo就会自动帮你提交到这个仓库。 以后只需要通过 hexo new 文章名称 创建一篇博客，写完之后，直接通过 hexo deploy --generate 发布到github上。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hibernate第四阶段]]></title>
      <url>%2F2016%2F05%2F17%2FHibernate04%2F</url>
      <content type="text"><![CDATA[Hibernate1.Hibernate的检索方式Hibernate提供对于对象的查询的方式 1.1Hibernate中五种查询方式1.1.1OID检索：根据主键查询+ session 中的get 和load方法 1.1.2对象导航检索：通过一个对象获得到其关联对象。LinkMan linkMan = session.get(LinkMan.class,1L);Customer customer=Linkman.getCustomer(); 1.1.3HQL 检索：通过编写一个HQL语句检索1.1.3.1HQL的基本的查询，别名查询，排序查询 在创建实体类的时候，生成toString的时候，不要把两个实体都生成，要不会互相打印，形成死循环，可以去掉一个set集合 查询全部//里面不能使用select * . 123456789Query query = session.createQuery(&quot;from Customer c&quot;); //给Customer取得别名List&lt;Customer&gt; lists=query.list();//也可以这么写List&lt;Customer&gt; list=session.createQuery(&quot;select c from Customer c&quot;).list();//HQL还支持多肽查询,查询所有Object下的持久化类Query query=session.createQuery(&quot;from java.util.Object&quot;);List&lt;Object&gt; lists=query.list(); 排序查询 12//默认asc，可以加desc降序List&lt;Customer&gt; list=session.createQuery(&quot;from Customer order by cust_id&quot;).list(); 1.1.3.2HQL的条件查询 按位置绑定参数 123456Query query = session.createQuery(&quot;from Customer where cust_name=? and cust_id=?&quot;);query.setParameter(0,&quot;...&quot;);query.setParameter(1,&quot;...&quot;);List&lt;Customer&gt; lists=query.list();//如果确定一条结果可以用Customer customer=(Customer) query.uniqueResult(); 按名称绑定参数 123456Query query = session.createQuery(&quot;from Customer where cust_name=:name and cust_id=:id&quot;);query.setParameter(&quot;name&quot;,&quot;...&quot;);query.setParameter(&quot;id&quot;,&quot;...&quot;);List&lt;Customer&gt; lists=query.list();//如果确定一条结果可以用Customer customer=(Customer) query.uniqueResult(); 1.1.3.3HQL的分页查询1234Query query = session.createQuery(&quot;from LinkMan&quot;);query.setFirstResult(0);query.setMAxResults(10);List&lt;LinkMan&gt; lists=query.list(); 1.1.3.4HQL的投影查询 查询所有的名字 12Query query = session.createQuery(&quot;select cust_name from Customer&quot;);List&lt;String&gt; names=query.list(); 查询所有客户的id和名称 12345Query query = session.createQuery(&quot;select cust_id,cust_name from Customer&quot;);List&lt;Object[]&gt; lists=query.list();for(Object[] objects : list)&#123; System.out.println(Arrays.toString(objects));&#125; 构造查询,现在实体类中写出相应的构造方法//不要忘了加无参构造 12Query query = session.createQuery(&quot;select new Customer(cyst_id,cust_name) from Customer&quot;);List&lt;Customer&gt; lists=query.list(); 1.1.3.5HQL的分组统计查询 统计个数 12Query query = session.createQuery(&quot;select count(*) from Customer&quot;);Long count=query.uniqueResult(); 按名称分组统计 12345Query query = session.createQuery(&quot;select cust_name,count(*) from Customer group by cust_name&quot;);List&lt;Object[]&gt; lists=query.list();for(Object[] objects : list)&#123; System.out.println(Arrays.toString(objects));&#125; 按姓氏的名称统计个数 123456Query query = session.createQuery(&quot;select cust_name,count(*) from Customer where cust_name like ? group by cust_name&quot;);query.setParameter(0,&quot;郝%&quot;);List&lt;Object[]&gt; lists=query.list();for(Object[] objects : list)&#123; System.out.println(Arrays.toString(objects));&#125; 1.1.4QBC 检索：通过Criteria对象进行检索1.1.4.1基本查询12Criteria criteria=session.createCriteria(Customer.class);List&lt;Customer&gt; list=criteria.list(); 1.1.4.2排序查询123Criteria criteria=session.createCriteria(Customer.class);criteria.addOrder(Order.asc(&quot;cust_id&quot;)); //倒序换为desc即可List&lt;Customer&gt; list=criteria.list(); 1.1.4.3条件查询1Criteria criteria=session.createCriteria(Customer.class); crteria.add(Restrictions.下边的值()); 1234567891011 == eq &gt; gt great than &gt;= ge great equal &lt; lt less than &lt;= le less equal &lt;&gt; ne not equallike 模糊查询like模糊查询还有一种方式//MatchMode.START指的是前面的字在哪个位置crteria.add(Restrictions.like(&quot;cust_name&quot;,&quot;郝&quot;，MatchMode.START)); //crteria.add(Restrictions.。。 可以写多个，相当于and 1.1.4.4分页查询12345Criteria criteria=session.createCriteria(Customer.class);crteria.add(Restrictions.like(&quot;cust_name&quot;,&quot;郝&quot;));crteria.setFirstResult(2);crteria.setMaxResult(2);List&lt;Customer&gt; lists=criteria.list(); 1.1.4.5统计查询setProjection 是单独值，用来设置聚集函数 123Criteria criteria=session.createCriteria(Customer.class);crteria.setProjection(Projections.rowCount());Object result=criteria.uniqueResult(); 1.1.4.6离线查询 DetachedCriteria这个对象可以前期脱离session来使用，后期再绑定session。所以可以在web层中封装好一个DetachedCriteria对象，然后传到dao中，在调用getExecutableCriteria(session); 获取一个Criteria对象使用 1.1.5SQL检索 ：通过输入SQL语句进行检索1.2 多表查询1.2.1 SQL中连接查询1.2.2 HQL中的连接查询sql连接 交叉连接 内连接 隐式内连接，显式内连接 迫切内连接fetch可以通知Hibernate，把结果封装成一个customer对象，包括集合 但是有一个问题：封装对象的时候会有重复的对象，所以要去重 外连接 左外连接 右外连接 迫切外连接跟内连接一样加一个 fetch 2.Hibernate的抓取策略2.1Hibernate延迟加载机制 延迟加载(懒加载 lazy):指的是，当执行到这行操作的时候，不会马上与数据库进行交互，等到真正使用该对象的属性的时候，才会发送sql语句进行查询。 2.1.1类级别的延迟加载类级别的延迟加载：查询某个类(对象)的时候，这个对象是否采用延迟。主要体现在使用load方法查询某个对象的时候，这个对象是否采用了延迟加载(默认使用延迟加载) 使类级别的延迟加载失效，跟get的效果一样： 在实体类中加final 在配置文件中的class标签上设置lazy属性为false 2.1.2 关联级别的延迟加载关联级别的延迟加载：查询某个类以后，查询这个类的关联的对象的时候，关联对象是否采用延迟，默认为true是延迟加载。 使关联级别的延迟加载失效： 在实体类中加final 在配置文件中的set标签上设置lazy属性为false lazy上还有一个值 extra，只是在关联级别有，及其懒惰，要什么只查什么。 2.2Hibernate的抓取策略(关联关系上配置fetch属性)抓取策略：用来查询到一个对象之后抓取其关联对象。 2.2.1set上的fetch和lazy：fetch控制的SQL语句的格式：lazy控制关联对象是否一致被查询 set集合上配置fetch属性： select 默认值，普通的select查询语句 join 会发送一条迫切连接，将关联的信息一起查询出来，所以此时lazy会失效 subselect 子查询 ，用 in set集合上配置lazy属性： true 默认值，延迟加载 false 不使用延迟加载 extra 及其懒惰 一般情况下就用默认的，但是如果经常一查多的一方，可以fetch用join 2.2.2 many-to-one 上的fetch和lazy： many-to-one集合上配置fetch属性： select 默认值，普通的select查询语句 join 会发送一条迫切连接，将关联的信息一起查询出来，所以此时lazy会失效 many-to-one集合上配置lazy属性： proxy 默认值，具体的取值取决于一的一方的类的fetch的值 false 不使用延迟加载 no-proxy 一般情况下就用默认的 2.3批量抓取 本来是先查所有，在一个一个查查三个 发四条语句 在set上加一个batch-size=&quot;3&quot;; 一下查三个，共发2条语句 在many-to-one上没有batch-size，需要时要在一的一方的class上配]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hibernate第三阶段]]></title>
      <url>%2F2016%2F05%2F15%2FHibernate03%2F</url>
      <content type="text"><![CDATA[Hibernate1.Hibernate 的一对多的映射1.1表关系的分析与创建一对一：创建唯一外键约束，或唯一主键约束一对多：在多的一方创建外键多对多：创建中间表 1.2Hibernate 一对多的关系的映射 基本环境搭建 建持久类 在一的一方 放一个多的一方的set集合 在多的一方 放入一的一方的对象 建立两个关系映射文件 在多的一方：配&lt;many-to-one name=&quot;&quot; class=&quot;&quot; column=&quot;&quot;/&gt; name：关联的一的一方的对象的属性名称 class：关联的一的一方的全路径 column：关联的是表中的外键的名称 在一的一方：配&lt;set name=&quot;&quot; &gt; &lt;key column=&quot;&quot;/&gt; &lt;one-to-many class=&quot;&quot;&gt; &lt;/set&gt; name:关联的多的一方的set集合的属性名称 column：关联的是多的一方的外键的名称 class:关联的多的一方的全路径 在核心配置文件，引入两个映射配置文件 多的： 1234&lt;many-to-one name=&quot;customer&quot; cascade=&quot;save-update&quot; column=&quot;lkm_cust_id&quot; class=&quot;com.hibernate.domain.Customer&quot; &gt;&lt;/many-to-one&gt; 一的： 12345&lt;set name=&quot;linkmans&quot; inverse=&quot;true&quot; cascade=&quot;save-update&quot;&gt; &lt;key column=&quot;lkm_cust_id&quot;&gt;&lt;/key&gt; &lt;one-to-many class=&quot;com.hibernate.domain.Linkman&quot;/&gt; &lt;/set&gt; 1.3编写一对多的测试代码1.3.1保存 如果只保存一个，就会出现瞬时对象异常（TransientObjectException）：持久态对象关联了一个瞬时态对象异常 解决这个问题就用到了一对多的级联： 级联保存：保存一边的时候，同时将另一边的对象或集合保存 只保存一的一方的时候：在&lt;set&gt;中配置一个cascade=&quot;save-update&quot;属性 只保存多的一方的时候：在&lt;many-to-one&gt;中配置一个cascade=&quot;save-update&quot;属性 1.3.2删除级联删除要先查询在删除，要不没法用。 删除一方的时候：如果单纯的只删除一的一方，会把多的一方的外键置为null 删除一的一方级联删除：在 &lt;set&gt; 中配置一个cascade=&quot;delete&quot;属性,会把本身跟通过外键关联它的数据都删除。 删除多的一方的时候：单纯的删，就只删除多的一方 删除多的一方级联删除：在&lt;many-to-one&gt;中配置一个cascade=&quot;delete&quot;属性,会把本身跟通过外键的数据都删除。 1.4双向维护关系产生多余的SQL 会产生两次更改外键的update语句，多余的sql。 为了避免这种问题，就通常要一的一方放弃外键的维护权，在映射配置文件里面的&lt;set&gt;标签上加一个inverse=&quot;true&quot;(默认是false) 事实上只能在一的一方加inverse inverse跟cascade的区别 cascade:代表的是级联操作，操作一个对象的时候，另一个对象是否跟着一块inverse:外键的维护，能不能操作外键 例：在customer映射文件中配置了inverse跟cascade则在建表的时候，两个表都会生成，但是linkMan中外键为null 2.Hibernate 的多对多的映射 两个持久化类中，都是用的set集合来关联的 在映射配置文件中配置 123456789101112131415161718//配置关联关系// set:标签//name:对方集合的属性名称//table:中间表的名称&lt;set name=&quot;students&quot; table=&quot;stu_cour&quot;&gt;//key:标签// column：当前对象在中间表外键名称。&lt;key column=&quot;cno&quot;/&gt;//many-to-many:标签// class:另一方类的全路径//column:另外一个类在中间表外键的名称&lt;many-to-many class=&quot;com.itheima.hibernate.domain.Student&quot; column=&quot;sno&quot;/&gt;&lt;/set&gt; 加载到核心配置文件中库 2.1保存 如果保存的时候，是双向保存，所以保存的时候，都会在中间表中插入相同的主键，会发生冲突，所以要在一方设置放弃外键约束 inverse（通常是被动放弃） 或者设置成级联保存，不要双向保存也可以 只保存一边是不行的：记得做级联操作。 2.2级联删除 主要就是操作关系的集合]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hibernate第二阶段]]></title>
      <url>%2F2016%2F05%2F12%2FHibernate02%2F</url>
      <content type="text"><![CDATA[Hibernate1.Hibernate 持久化类的编写1.1什么是持久化类持久化类：指的就是一个java类与数据库表建立了映射关系以后，这个类就称为是持久化类持久化类=java类+映射文件 1.2持久化类的编写规则 对持久化类提供无参数的构造方法：hibernate需要反射来创建持久化类的实例。（new instance 就能创建了） 对持久化类的属性私有化，对私有属性提供共有的get/set方法： 在持久化类中提供一个oid与表中的主键映射 编写的时候，属性最好使用包装类 持久化类尽量不要使用fianl修饰（延迟加载时，需要产生代理对象，这个代理对象使用javassist技术实现，就是产生一个子类对象，所以不能用final） 2.Hibernate的主键生成策略2.1区分自然主键和代理主键 自然主键：自然主键指定是建表的时候使用对象中本身属性作为表的主键。创建一个人员表，人会有身份证号，身份证号是唯一不可重复的，现在使用了身份证作为主键的话，属于自然主键。 代理主键：代理主键指的是没有使用对象中的自身的属性作为表的主键，使用与对象不相关的属性作为表的主键。创建一个人员表，人会有身份证号，没有使用身份证号，在建表的时候使用id字段作为表的主键。 建表的时候建议使用代理主键，自然主键有可能会参与到业务逻辑中。有可能出现重复或者有的时候可能需要修改，这个时候主键不能修改的，所以说自然主键不能使用了。 2.2Hibernate主键生成策略主键不应该由用户自己输入，应该有程序生成。Hibernate框架提供了很多主键生成的方式。 increment： 自动增长，使用的是Hibernate中提供的自动增长的机制。适用于short,int,long. Hibernated底层使用查询一下表中的主键的最大值，select max(cust_id) from customer;然后将这个值+1作为下一条记录的主键。会有并发访问问题。 identity： 自动增长，使用的是数据库的自动增长机制。适用于short,int,long,适用于有自动增长机制的数据库（MySQL，SQLServer），Oracle没有自动增长，不能使用identity。 sequence： 序列，使用的是序列的方式完成数据库的主键的生成。(Oracle，DB2这种数据库可以使用序列)。适用于short,int,long native : 本地策略，根据底层数据库不同,自动选择使用identity还是sequence适用于short,int，long uuid : 适用于字符串类型的主键，产生随机字符串作为表的主键。 assigned : Hibernate不管理主键，用户手动设置主键的值。 3.hibernate持久化类的三种状态hibernate为了更好的管理持久化类，将持久类分为三种状态： 瞬时态(Transient)：没有唯一标识OID，没有被session管理。 持久态(Persister)：有唯一标识OID，被session管理。 脱管态(Detached)：有唯一标识OID，没有被session管理。 3.1 持久态对象特殊能力：自动更新数据库： 3.2持久化类的三种状态转化 瞬时态： 获得：Customer customer=new Customer(); 状态转化： 瞬时—&gt;持久：save,saveOrUpdate 瞬时—&gt;脱管：customer.setCust_id(1); 持久态： 获得：get/load/find/iterate(都是查询) 状态转换： 持久—&gt;瞬时：delete 持久—&gt;脱管：close/clear(清空所有对象)/evict(清空一个对象) 脱管态： 获得：Customer customer=new Customer();customer.setCust_id(1); 状态转换： 脱管—&gt;持久：update/saveOrUpdate 脱管—&gt;瞬时：customer.setCust_id(null); 4.Hibernate的一级缓存4.1什么是缓存缓存是内存中的一块空间，提升性能存在。将数据源数据存入到内存中，再次获取的时候从缓存中获取，不需要进行查询的操作。 4.2什么是一级缓存Hibernate的性能相对来说是比较差的，里面提供了很多性能优化手段，其中缓存就是优化的一部分。 Hibernate共分为两个级别的缓存： 一级缓存：称为session级别的缓存。自带的，不可卸载的。 二级缓存：称为sessionFactory级别的缓存。需要配置的缓存的插件。 一级缓存是由Session中的一系列java集合组成，生命周期贯穿了整个session周期，可以说是一个session级别的缓存。 而且缓存的是对象的地址：（第二遍的时候根本就没查询） 4.3一级缓存的快照区session有缓存区(sess/persistenceContext/entitiesByKey/table/?/value)跟快照区(sess/persistenceContext/entityEntryContext/head/entity/loadedState)缓存即使变化，快照区一旦生成就不变化，直到事务结束之后。 当提交事务的时候，比对一级缓存区和快照区的数据是否一致。如果一致，不修改数据库，如果不一致，就会更新数据库。 4.4一级缓存的管理的方法 close clear：清空所有一级缓存 evict：清空单个缓存对象 5.Hibernate事务的管理5.1事务的回顾 什么是事务：指的是逻辑上的一组操作，组成这组操作的各个单元要么一起成功要么一起失败 特性： 原子性：事务是不可分割的 一致性：事务执行的前后，数据完整性保持一致。 隔离性：一个事务的执行不应该受到其他事务的干扰 持久性：一旦事务结束，持久到数据库中 问题： 读问题： 脏读：一个事务读到另一个事务未提交的事务。 不可重复读：一个事务读到另一个事务已提交的update的数据 虚读/幻读：一个事务读到另一个事务已提交的insert的数据 写问题： 丢失更新(事务提交)就是在多个更新操作同时运行时，数据库可能丢失前面更新的数据。 丢失更新(事务回滚) 解决读问题： 设置事务的隔离级别： 未提交读(read uncommitted):以上情况都有可能发生。 已提交读(read committed)：避免脏读，但是不可重复读和虚度都有可能发生。 可重复读(repeatable read):避免脏读和不可重复读，但是虚度有可能发生。 串行化的(serializable)：解决所有问题 解决写问题 悲观锁： 在get方法中添加排它锁Customer customer=session.get(Customer.class,1L,LockMode.UPGRADE); 这样在同时运行多个更新操作时，一个运行完了才能运行下一个。 乐观锁： 在实体上加一个版本号：Integer version， 在映射文件中配置标签version，名字写上实体中的版本号名字 每次执行操作修改操作的时候，版本号就会自动加一， 如果同时开启两个更新操作，版本号不一致会会报错 5.2hibernate的事务管理 设置事务的隔离级别： 1—Read uncommitted isolation 2—Read committed isolation 4—Repeatable read isolation 8—Serializable isolation 与线程绑定的session的使用：设置了这个属性后就可以用： session.getCurrentSession(); //表示从当前线程上获取session而且用这种当时获取的session，不用session.close(),因为线程结束之后会自动关闭。手动关闭会报错。 5.3hibernate事务的其他的api Query ：HQL查询HQL(Hibernate Query Language)：Hibernate查询语言，语法与SQL类似，面向对象的查询方式。 123456789101112131415//查询所有Query query=session.createQuery(&quot;from Customer(理论上是全路劲名的)&quot;);List&lt;Customer&gt; lists=query.list();//模糊查询Query query=session.createQuery(&quot;from Customer where cust_name like ?&quot;);//可以是setInteger，也可以是setParameter：表示任意类型query.setParameter(0,&quot;xx%&quot;);List&lt;Customer&gt; lists=query.list();//分页查询Query query=session.createQuery(&quot;from Customer&quot;);query.setFirstResult(0);query.setMaxResults(2);List&lt;Customer&gt; lists=query.list(); Criteria ： QBC查询QBC(Query By Criteria)：条件查询，更加面向对象的方式 1234567891011121314//查询全部Criteria criteria=session.createCriteria(Customer.class);List&lt;Customer&gt; lists=criteria.list();//条件查询Criteria criteria=session.createCriteria(Customer.class);criteria.add(Restrictions.。。。);List&lt;Customer&gt; lists=criteria.list();//分页查询Criteria criteria=session.createCriteria(Customer.class);criteria.setFirstResult(0);criteria.setMaxResults(2);List&lt;Customer&gt; lists=criteria.list(); SQLQuery ： SQL查询 1234567891011//原始SQLQuery sqlQuery = session.createSQLQuery(&quot;select * from cst_customer&quot;);List&lt;Object[]&gt; list=sqlQuery.list();for(Object[] objects : lists) &#123; System.out.println(Arrays.toString(objects));&#125;//进化SQLQuery sqlQuery = session.createSQLQuery(&quot;select * from cst_customer&quot;);sqlQuery.addEntry(Customer.class);List&lt;customer&gt; list=sqlQuery.list();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hibernate第一阶段]]></title>
      <url>%2F2016%2F05%2F10%2FHibernate01%2F</url>
      <content type="text"><![CDATA[Hibernate1.Hibernate的学习路线2.Hibernate的概述框架：就是一个=软件的半成品，完成部分功能 2.1什么是Hibernate是持久层的ORM框架 2.2什么是ORMHibernate是一个优秀的ORM实现框架 ORM(Object-Relational Mapping):对象关系映射 开发语言是java是面向对象 数据库是Mysql 是关系型数据库让java跟数据库中的表之间产生关系，直接操作对象就可以操作数据库 传统方式的不足 表中的字段获得类中的属性发生变化，DAO中的代码都要跟着发生变化（修改程序源代码） 2.3为什莫学习Hibernate： 3.Hibernate的入门3.1下载Hibernate的开发包解压之后： documentation：Hibernate的开发文档跟规范，还有一些测试的项目 lib：Hibernate的开发包，required是必须的，别的是可选的 product：一些相关的项目的源代码模板 3.2创建项目，引入jar包，日志文件引入required必须包，还有他要用到的数据库驱动包connection还需要log4j的jar包 slf4j 简单日志门面，是一个接口，log4j是整合日志的一个规范 可以把日志文件的配置文件引入log4j.properties打开配置文件，可以在最后边更改，从而设置日志信息打印在哪，默认是在控制台，可以加一个file打印在文件中，路径上面可以更改。 3.3创建表跟实体类3.4创建映射文件(ORM框架) 映射文件通常是一个XML文件，而且这个文件是可以任意命名。通常情况下名称：类名.hbm.xml创建约束：Hibernate 的核心包core下第一个后边位置，找到3.0 mapping的约束里面的123&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt; ，copy过去 建立类和表的映射123456789101112&lt;hibernate-mapping&gt; &lt;class name=&quot;实体类路劲&quot; table=&quot;表名&quot;&gt; &lt;id name=&quot;实体主键属性名&quot; column=&quot;表主键名&quot;&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; //普通属性与表中字段建立映射 &lt;property name=&quot;实体名&quot; column=&quot;属性名&quot; /&gt; //两个名字是一样的 &lt;property name=&quot;&quot; column=&quot;&quot; /&gt; &lt;property name=&quot;&quot; column=&quot;&quot; /&gt; 。。。 &lt;/class&gt;&lt;/hibernate-mapping&gt; 3.5创建核心配置文件连接哪个数据库 src下创建一个固定名称的xml hibernate.cfg.xml创建约束：project下etc下的hibernate.cfg.xml里面的约束copy过去，或者找Hibernate 的核心包core下第一个后边位置，找到3.0 configuration的约束dtd里面的约束两个是一样的 参数：project下etc下的hibernate.properties是模板，找到参数写123456789101112131415161718192021222324&lt;hibernate-configuration&gt; &lt;session-factory&gt; //连接数据库的基本参数 &lt;property name=&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;hibernate.connection.url&quot;&gt;jdbc:mysql///表名&lt;/property&gt; &lt;property name=&quot;hibernate.connection.username&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;hibernate.connection.password&quot;&gt;123&lt;/property&gt; // 配置hibernate的属性： //hibernate的方言：(也是在上面那个文件中找，mysql是这莫写) &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; //可以配置一些其他的属性 //打印出sql语句 &lt;property name=&quot;hibernate.show_sql&quot;&gt;true&lt;/property&gt; //格式化一下 &lt;property name=&quot;hibernate.format_sql&quot;&gt;true&lt;/property&gt; //hbm2ddl.auto:对应数据库的ddl操作：create,create-drop,update,validate &lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/property&gt; //加载映射文件 &lt;mapping resource=&quot;com/itheima/domain/...xml（**映射文件的路劲**中间是/并且以src下面的第一个包开头前面不加/）&quot; /&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 3.6使用Hibernate123456789101112131415//加载配置文件Configuration con=new Configuration().configure();//创建一个SessionFactory：类似连接池SessionFactory sess=con.buildSessionFactory();//创建一个Session：相当于ConnectionSession session=sess.openSession();//开启事务：Transaction tran=session.beginTransaction();//操作：Customer customer=new Customer();customer.setCust_name(&quot;要田间的属性名&quot;);//提交事务：transaction.commit();//释放资源：session.close(); 4.Hibernate 常见的配置4.1配置文件的配置映射文件：将对象与表建立映射关系。类名.hbm.xml 配置没有网的时候，编写配置文件的提示信息： 先复制，约束下边的路劲在window属性中找到xml catalog点 add 在找本地的dtd约束，引入，改为url，粘贴刚才复制的。 4.1.1class标签：建立类与表的映射 name：实体类的全路劲 table：数据库的表名（如果类名与表明相同，则table可以省略） catalog:写数据库名（可以不写） 4.1.2id标签： 用来表中的主键与类中属性建立映射 name ：类中的属性名 column：表中的字段名（如果属性名跟字段名一致则可以省略） type (从这个以下可以省略)：数据的类型(hibernate类型，java类型，数据库类型) 也可以这么写： 4.1.3property标签：表中的字段与类中的属性的映射跟id大同小异 length ：代表表中的长度（因为hibernate可以帮助你建表，默认设置为255） 4.2核心配置文件不能联网的时候配置一下，就可以提醒了 如果没有写在src底下，在加载的时候记得传一个路劲过去。 4.2.1分类 hibernate.properties 格式：key=value键值对的形式，但是不能加载映射文件。（手动写） 加载：Configuration con=new Configuration(); hibernate.cfg.xml 格式：格式化的格式 加载：Configuration con=new Configuration().configure(); 4.2.2内容 配置基本配置参数 其他参数 加载映射文件&lt;mapping resource=&quot;com/itheima.domain/...xml&quot; /&gt; hbm2ddl.auto参数（hibernate mapping to ddl）:对应数据库的ddl操作：（一般会使用update，validata，别的一般用作测试） create： 如果数据库有表，先删掉，重新创建一个新的表 create-drop：如果数据库有表，先删掉，重新创建，使用完毕，会删除该表（没有表也会创建使用完再删除） update：如果有表使用原来的表，没有则创建新表，并且可以更新，插入的时候没有字段创建一个新的字段 validate：如果没表则报错，有表使用原来的表，并对表进行校验（实体对象的属性跟表的字段不一样时会报错） 5.Hibernate的常用API5.1Configuration：配置对象5.1.2加载核心配置文件因为核心配置文件有两种书写方式。 hibernate.properties 格式：key=value键值对的形式，但是不能加载映射文件。（手动写） 加载：Configuration con=new Configuration(); hibernate.cfg.xml 格式：格式化的格式 加载：Configuration con=new Configuration().configure(); 5.1.3 加载映射配置文件如果不用配置文件来加载映射文件可以手动加载映射文件：(两种方法)Configuration.addResource(路劲...);//这种方法有一个条件，就是实体类跟配置文件在同一个包中Configuration.addClass(实体类名.class); 5.2 SessionFactory SessionFactory 对象内部维护了连接池和二级缓存（不讲）。是一个线程安全重量级的对象，所以说一般情况下，一个项目只对应一个SessionFactory。 所以一般把他单独抽出来。 5.2.1抽取一个工厂的工具类1234567891011private static final Configuration cfg;private static final SessionFactory sf;static&#123; cfg=new Configuration().config(); sf=cfg.buildSessionFactory();&#125;public static Session getSession()&#123; return sf.openSession();&#125; 5.2.2配置连接池Hibernate中自带了连接池，但是可以自己配置c3p0 引入c3p0相关的jar包，包括hibernate跟其整合的包，在lib中option中的c3p0中 配置核心配置文件：在session-factory中 1234567891011&lt;!-- 配置C3P0连接池 --&gt; &lt;property name=&quot;connection.provider_class&quot;&gt;org.hibernate.connection.C3P0ConnectionProvider&lt;/property&gt; &lt;!--在连接池中可用的数据库连接的最少数目 --&gt; &lt;property name=&quot;c3p0.min_size&quot;&gt;5&lt;/property&gt; &lt;!--在连接池中所有数据库连接的最大数目 --&gt; &lt;property name=&quot;c3p0.max_size&quot;&gt;20&lt;/property&gt; &lt;!--设定数据库连接的过期时间,以秒为单位, 如果连接池中的某个数据库连接处于空闲状态的时间超过了timeout时间,就会从连接池中清除 --&gt; &lt;property name=&quot;c3p0.timeout&quot;&gt;120&lt;/property&gt; &lt;!--每3000秒检查所有连接池中的空闲连接 以秒为单位--&gt; &lt;property name=&quot;c3p0.idle_test_period&quot;&gt;3000&lt;/property&gt; 5.3session（完成基本的CRUD的操作）Session session=sessionFactory.openSession(); 相当于JDBC中的connection，生命周期是以事务的开始跟结束为界限 不是线程安全的，所以最好定义成局部变量 是数据库核心对象 5.3.1savesave方法中： 先查询在，修改对象里面的东西，save跟update的效果是一样的 新建一个对象，然后设置id跟其他的值后save，只要主键生成策略不是assigned，那么则不用手动设置id，设置了也没用 5.3.2查询get/load get: 查询一个：get(实体类的class,数据库id); //这里的id在实体里用的long型，所以加L Customer customer=sess.get(Customer.class, 1l); load 查询一个：load(实体类的class,数据库id); Customer customer=sess.load(Customer.class, 1l); 重要 **get跟load的区别：** 加载时间 get方法：当程序执行到这行的时候，马上发送一条sql语句，返回Customer的对象 load方法：当程序执行到这行的时候，没有马上发送sql语句(使用的是Hibernate中延迟加载的策略lazy，真正使用该对象的时候才会加载)（使用的时候才执行，不用根本不加载，只用id也不行，因为人家已经知道了） 返回值 load返回的实体类的代理对象 get返回实体类本身 查询找不到的对象 load抛出ObjectNotFoundException get 返回一个null，或报空指针 5.3.3 update修改 先创建对象在修改 先查询在修改 5.3.4 delete删除 直接创建对象 然后删除 先查询在删除(推荐，为以后的级联删除方便) 5.3.5 saveOrUpdate 保存或更新没有id即保存，有id即更新 5.3.6 查询全部HQL：Hibernate Query LanguageQuery query=session.createQuery(&quot;from Customer&quot;); List&lt;Customer&gt; lists=query.list(); 5.4 Transaction 事务操作beginTranscction（）； //开启事务commit（）； //提交事务 注：hibernate5中有一个特性，就是会自动提交，前提是必须使用内置的连接池，但是为了低版本跟防止多事务提交出现错误，一般都要手动提交]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Redis]]></title>
      <url>%2F2016%2F03%2F18%2FRedis%2F</url>
      <content type="text"><![CDATA[RedisNoSQL什么是NoSQLNoSQL(NoSQL=Not Only SQL) 意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。 为什么需要NoSQL High performance 对数据库高并发读写的需求 Huge Storage 对海量数据的高效率存储和访问的需求 High Scalability&amp;&amp;High Availability 高并发 主流NoSQL产品 键值（Key-Value）存储数据库 相关产品：Toko Canbinet/Tyrant、Redis、Voldemort、Berkeley DB 典型应用：内容缓存，主要用于处理大量的高访问负载 数据模型：一系列键值对 优势：快速查询 劣势：存储的数据库缺少结构化 列存储数据库 文档存储数据库 图形存储数据库 NoSQL特点 易扩展 大数据量，高性能 灵活的数据模型 高可用 Redis什么事RedisRedis是C语言开发的一个开源的高效能键值对数据库。 目前为止Redis 支持的键值的数据类型如下： 字符串类型 散列类型 列表类型 集合类型 有序集合类型 Resis的安装yum是一个很强大的命令，安装c语言环境必须在有网的情况下 redis在Linux上的安装 redis编译的c环境，yum install gcc-c++ 将redis-2.6.16.tar.gz上传到Linux系统中 解压到/usr/local下 tar -xvf redis-2.6.16.tar.gz -C /usr/local 进入redis-2.6.16目录 使用make命令编译redis 在redis-2.6.16目录中 使用make PREFIX=/usr/local/redis install命令安装redis到/usr/local/redis中 拷贝redis-2.6.16中的redis.conf到安装目录redis中 启动redis 在bin下执行命令redis-server redis.conf 如需远程连接redis，需配置redis端口6379在linux防火墙中开发 12/sbin/iptables -I INPUT -p tcp --dport 6379 -j ACCEPT/etc/rc.d/init.d/iptables save 启动后看到如上欢迎页面，但此窗口不能关闭，窗口关闭就认为redis也关闭了(类Tomcat通过bin下的startup.bat的方式) 解决方案：可以通过修改配置文件 配置redis后台启动，即服务器启动了但不会占据控制台窗口 将redis.conf文件中的**daemonize**从no修改成yes表示后台启动 使用命令查看6379端口是否启动ps -ef | grep redis 正常关闭数据库向客户端发送shutdown，即：./redis-cli shutdown ,或关闭窗口也可以 | 使用java去操作Redis步骤： 12345//下载Redis的驱动包---就是一个jar包 该jar封装是java操作redis的api Jedis jedis=new Jedis(host,port); //post:redis所在的主机 // 端口号 jedis.set(&quot;age&quot;,&quot;28&quot;); 使用连接池： 12345678910//设置池子的配置对象，可以设置一些参数JedisPoolConfig config=new JedisPoolConfig();config.setMaxTotal(20);config.setMaxIdle(10);//创建一个池子JedisPool pool =new JedisPool(config ， host ， post);//从池子中获取资源Jedis jedis=pool.getResource();//操作jedis.set(key,value); 可以封装成一个工具类 123456789101112131415161718private static JedisPoolConfig config=null;private static JedisPool pool=null;static&#123; config =new JedispoolConfig; config.setMaxTotal(20); config.setMaxIdle(10); pool=new JedisPool(config ， host ， post);&#125;public static Jedis getJedis()&#123; Jedis jedis=pool.getResource(); return jedis;&#125;//关闭public static void close(Jedis jedis)&#123; if(jedis!=null)(&#123; jedis.close(); &#125;&#125; Redis的常用命令redis是一种高级的key-value的存储系统 其中的key是字符串类型，尽可能满足如下几点： key不要太长，最好不要操作1024个字节，这不仅会消耗内存还会降低查找效率 key不要太短，如果太短会降低key的可读性 在项目中，key最好有一个统一的命名规范（根据企业的需求） 我们对Redis的学习，主要是对数据的存储，下面将来学习各种Redis的数据类型的存储操作： 存储字符串string字符串类型是Redis中最为基础的数据存储类型，它在Redis中是二进制安全的，这便意味着该类型可以接受任何格式的数据，如JPEG图像数据或Json对象描述信息等。在Redis中字符串类型的Value最多可以容纳的数据长度是512M 基本 set key value：设定key持有指定的字符串value，如果该key存在则进行覆盖操作。总是返回”OK” get key：获取key的value。如果与该key关联的value不是String类型，redis将返回错误信息，因为get命令只能用于获取String value；如果该key不存在，返回null。 getset key value：先获取该key的值，然后在设置该key的值。 扩展 incr key：将指定的key的value原子性的递增1.如果该key不存在，其初始值为0，在incr之后其值为1。如果value的值不能转成整型，如hello，该操作将执行失败并返回相应的错误信息。 decr key：将指定的key的value原子性的递减1.如果该key不存在，其初始值为0，在incr之后其值为-1。如果value的值不能转成整型，如hello，该操作将执行失败并返回相应的错误信息。 incrby key increment：将指定的key的value原子性增加increment，如果该key不存在，器初始值为0，在incrby之后，该值为increment。如果该值不能转成整型，如hello则失败并返回错误信息 decrby key decrement：将指定的key的value原子性减少decrement，如果该key不存在，器初始值为0，在decrby之后，该值为decrement。如果该值不能转成整型，如hello则失败并返回错误信息 append key value：如果该key存在，则在原有的value后追加该值；如果该 key 不存在，则重新创建一个key/value 存储lists类型在Redis中，List类型是按照插入顺序排序的字符串链表。和数据结构中的普通链表一样，我们可以在其头部(left)和尾部(right)添加新的元素。 在插入时，如果该键并不存在，Redis将为该键创建一个新的链表。与此相反，如果链表中所有的元素均被移除，那么该键也将会被从数据库中删除。List中可以包含的最大元素数量是 4294967295。 从元素插入和删除的效率视角来看，如果我们是在链表的两头插入或删除元素，这将会是非常高效的操作，即使链表中已经存储了百万条记录，该操作也可以在常量时间内完成。然而需要说明的是，如果元素插入或删除操作是作用于链表中间，那将会是非常低效的。 lpush key value1 value2...：在指定的key所关联的list的头部插入所有的 values，如果该key不存在，该命令在插入的之前创建一个与该key关联的空链表，之后再向该链表的头部插入数据。插入成功，返回元素的个数。 rpush key value1、value2…：在该list的尾部添加元素 lrange key start end：获取链表中从start到end的元素的值，start、end可为负数，若为-1则表示链表尾部的元素，-2则表示倒数第二个，依次类推… lpushx key value：仅当参数中指定的key存在时（如果与key管理的list中没有值时，则该key是不存在的）在指定的key所关联的list的头部插入value。 rpushx key value：在该list的尾部添加元素 lpop key：返回并弹出指定的key关联的链表中的第一个元素，即头部元素。 rpop key：从尾部弹出元素。 rpoplpush resource destination：将链表中的尾部元素弹出并添加到头部 llen key：返回指定的key关联的链表中的元素的数量。 lset key index value：设置链表中的index的脚标的元素值，0代表链表的头元素，-1代表链表的尾元素。 lrem key count value：删除count个值为value的元素，如果count大于0，从头向尾遍历并删除count个值为value的元素，如果count小于0，则从尾向头遍历并删除。如果count等于0，则删除链表中所有等于value的元素。 linsert key before|after pivot value：在pivot元素前或者后插入value这个元素。 存储sets类型在Redis中，我们可以将Set类型看作为没有排序的字符集合，和List类型一样，我们也可以在该类型的数据值上执行添加、删除或判断某一元素是否存在等操作。需要说明的是，这些操作的时间是常量时间。Set可包含的最大元素数是4294967295。和List类型不同的是，Set集合中不允许出现重复的元素。和List类型相比，Set类型在功能上还存在着一个非常重要的特性，即在服务器端完成多个Sets之间的聚合计算操作，如unions、intersections和differences。由于这些操作均在服务端完成，因此效率极高，而且也节省了大量的网络IO开销 基本 sadd key value1、value2…：向set中添加数据，如果该key的值已有则不会重复添加 smembers key：获取set中所有的成员 scard key：获取set中成员的数量 sismember key member：判断参数中指定的成员是否在该set中， 1表示存在， 0表示不存在或者该key本身就不存在 srem key member1、member2…：删除set中指定的成员 扩展 srandmember key：随机返回set中的一个成员 sdiff sdiff key1 key2：返回key1与key2中相差的成员，而且与key的顺序有关。即返回差集。 sdiffstore destination key1 key2：将key1、key2相差的成员存储在destination上 交并集操作 sinter key[key1,key2…]：返回交集。 sinterstore destination key1 key2：将返回的交集存储在destination上 sunion key1、key2：返回并集。 sunionstore destination key1 key2：将返回的并集存储在destination上 存储sortedsetSorted-Sets和Sets类型极为相似，它们都是字符串的集合，都不允许重复的成员出现在一个Set中。它们之间的主要差别是Sorted-Sets中的每一个成员都会有一个分数(score)与之关联，Redis正是通过分数来为集合中的成员进行从小到大的排序。然而需要额外指出的是，尽管Sorted-Sets中的成员必须是唯一的，但是分数(score)却是可以重复的。 在Sorted-Set中添加、删除或更新一个成员都是非常快速的操作，其时间复杂度为 集合中成员数量的对数。由于Sorted-Sets中的成员在集合中的位置是有序的，因此， 即便是访问位于集合中部的成员也仍然是非常高效的。事实上，Redis所具有的这一 特征在很多其它类型的数据库中是很难实现的，换句话说，在该点上要想达到和Redis 同样的高效，在其它数据库中进行建模是非常困难的。例如：游戏排名、微博热点话题等使用场景。 基本 zadd key score member score2 member2 …：将所有成员以及该成员的 分数存放到sorted-set中 zcard key：获取集合中的成员数量 zcount key min max：获取分数在[min,max]之间的成员的数量 zincrby key increment member：设置指定成员的增加的分数。 zrange key start end [withscores]：获取集合中脚标为start-end的成员，[withscores]参数表明返回的成员包含其分数。 zrangebyscore key min max [withscores] [limit offset count]：返回分数在[min,max]的成员并按照分数从低到高排序。[withscores]：显示分数；[limit offset count]：offset，表明从脚标为offset的元素开始并返回count个成员。 zrank key member：返回成员在集合中的位置。 zrem key member[member…]：移除集合中指定的成员，可以指定多个成员。 zscore key member：返回指定成员的分数 存储hashRedis中的Hashes类型可以看成具有String Key和String Value的map容器。所以该类型非常适合于存储值对象的信息。如Username、Password和Age等。如果 Hash中包含很少的字段，那么该类型的数据也将仅占用很少的磁盘空间。每一个Hash 可以存储4294967295个键值对。 hset key field value：为指定的key设定field/value对（键值对）。 hgetall key：获取key中的所有filed-vaule hget key field：返回指定的key中的field的值 hmset key fields：设置key中的多个filed/value hmget key fileds：获取key中的多个filed的值 hexists key field：判断指定的key中的filed是否存在 hlen key：获取key所包含的field的数量 hincrby key field increment：设置key中filed的值增加increment，如：age增加20 没有减少的命令，要想减少就用加上负数 keys的通用操作 keys pattern:获取所有与pattern匹配的key， 表示任意一个或多个 ？表示任意一个字符 del key1 key2:删除指定的key exits:判断该key是否存在 1 表示存在 0表示不存在 rename key newkey:为当前的key重命名 expire key:设置过期时间，单位：秒 ttl key:获取所剩的超时时间，如果没有设置超时，返回-1，如果返回-2表示超时不存在 type key:获取指定的key的类型，以字符串形式输出 string, list,set,hash,zset 如果不存在返回true Redis特性多数据库一个redis实例最多可以提供16个数据库，下标0到15，客户端默认连接第0号数据库，也可以通过select选择哪个数据库 select 1： 选择1号数据库 move newkey 1 :将当前的数据库移植到1号数据库 服务器命令 ping 测试链接是否存活 echo 在命令行打印一些内容 select 选择数据库 quit 退出连接 dbsize 返回key数目 info 获取服务器的信息和统计 flushdb 删除当前选择数据库中的所有key flushall 删除所有数据库中的key 消息订阅与发布 subscribe channel:订阅频道 psubscribe channel* :批量订阅频道 *表示为任意数量跟值 publish channel content:在指定的频道发布消息 channel表示频道，content表示消息 事务 MULTI：开启事务，其执行后的命令都会存入命令队列中，直到EXEC EXEC: 提交事务 DISCARD: 回滚 注：redis的事务跟关系型事务的不同之处是，不管有没有报错都会全部执行完毕，所以我觉得说是批处理更好一些 持久化1.RDB(默认支持无序配置) 该机制是指在指定的时间间隔内将内存中的数据集快照写入磁盘 优势：性能最大化，是将整个redis存到一个文件中，作为备份方便劣势：可用性低，容易丢失数据，文件过大可能导致停机 保存位置：配置文件中的 dbfilename dump.rdb 2.AFO 启动AOF持久化：配置文件中改appendonly no成yes 优势：安全性高，包含一个格式清晰的日志文件，方便数据重建劣势：AOF文件一般大于RDB，效率低 改变策略： redis在服务器中的访问过程：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[reflect]]></title>
      <url>%2F2016%2F03%2F08%2Freflect%2F</url>
      <content type="text"><![CDATA[反射技术什么是反射技术，作用是什么java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方 法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信 息以及动态 调用对象的方法的功能称为java语言的反射机制。 反射技术的API 通过反射获得类的字节码对象 获得运行时的java的字节码对象Class的方式有三种： 通过对象获得：obj.getClass(); 通过类名获得：className.class 通过类的全限定名获得：Class.forName(类的全限定名); 获得字节码对象Class之后，可以通过某人无参的构造方法创建对象newInstance() Class对象有一个获得加载该字节码文件的类加载器的方法ClassLoader loader = Class字节码对象.getClassLoader(); 通过反射获得构造方法 获得构造方法Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) 获得构造器后，可以通过构造器创建对象：T newInstance(Object... initargs) 通过反射获得字段 获得字段Field getField(String name) 获得字段内容Object get(Object obj) 设置字段内容set(Object obj, Object value) 通过反射获得方法 获得方法Method getMethod(String name, Class&lt;?&gt;... parameterTypes) 执行该方法method.invoke(Object obj, Object... args) 反射的实际应用场景 Spring框架是层与层直接解耦的“神器”，例如：我们不必在Service中使用new Dao 的方式创建Dao对象，那样具体的Dao实现就与Service层耦合死了，我们可以通过 工厂+反射+XML配置的方式降低层与层之间的耦合性 Service层代码： dao层代码： 使用工厂+反射+配置文件方式进行解耦 在src下编写配置文件bean.xml 创建bean工厂用来创建实体对象 修改service的代码 总结：我们可以所以切换bean.xml中的class实现类的地址而无需修改java代码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux]]></title>
      <url>%2F2016%2F03%2F07%2FLinux%2F</url>
      <content type="text"><![CDATA[Linux基础Linux的概述Linux是由Linus Torvalds（林纳斯·托瓦兹）起初开发的，由于源代码的开放性，现在已经衍生出了千上百种不同的Linux系统。 Android底层就是运行在Linux上的 Linux的分类linux根据市场需求不同，基本分为两个方向： 图行化界面版：注重用户体验，类似window操作系统，但目前成熟度不够 服务器版：没有好看的界面，是以在控制台窗口中输入命令操作系统的，类似于DOS，是我们架设服务器的最佳选择 Linux根据原生程度，又分为两种 内核版本：在Linus领导下的内核小组开发维护的系统内核的版本号 发行版本：一些组织或公司在内核版基础上进行二次开发而重新发行的版本 Linux发行版本不同，又可分为： ubuntu:注重用户界面 CentOS:免费，企业用的特别多 redhat 中标麒麟，红旗 （国产） 虚拟机的安装虚拟机分类 VMware（威睿）公司的虚拟机软件，功能强大，收费 VitrualBox虚拟机软件，Orale公司的虚拟机软件，免费商品 Linux的安装Linux的目录结构图 常用命令 基本命令 cd cd usr 切换到该目录下的usr cd ../ 换到上一目录 cd / 切换到跟目录 cd ` 切换到用户主目录 cd - 切换到上一个目录 查找 ls 展示目录列表 可以加参数 -l 表示列表详细信息 ls -l 可以简写成ll 加 -a 表示隐藏文件 也可以加 -la find 目录 参数 文件名称 搜索 find /root -name &#39;text*&#39; 搜目录下的文件名开头是text的文件(递归查找即找所有的文件) 增删改 mkdir 文件夹名 创建文件夹 mv aaa bbb 把aaa重命名为bbb mv全名是move mv可以对一切数据类型的文件重命名（文件，压缩包…） mv 目录名称 目录新的位置 剪切 mv可以对一切数据类型的文件剪切（文件，压缩包…） cp -r 文件名称 新的目标目录 复制，-r 表示递归 rm -rf 要删除的目录名 删除，-r 表示递归 -f 表示强迫(没有提示) 查看文件 touch 文件 创建文件 cat 文件名 查看文件内容,但是只能显示一页 more 文件名 可以查看文件，显示第一页，然后按空格显示下一页，回车显示下一行，按q退出 less 文件 可以查看文件，显示第一页，按pgup显示上一页，pgdn显示下一页 tail -num 可以查看文件的后num行 tail -f 可以动态查看文件 修改文件的内容(改) 为文件添加或修改内容 vim 是vi的升级版 vim 文件名 进到文件中编辑，此刻是命令模式（不能编辑），按 i 或 a 或 o进入编辑模式，编辑完之后，在点esc退出到命令模式，点 : 变成底行模式 底行模式下，wq 保存并退出， q! 退出不保存 解压跟压缩 打包并压缩文件 tar -zcvf 打包后的文件名 要打包的文件 Linux压缩文件一般是这种形式：xxx.tar.gz z：调用gzip压缩命令进行压缩 c：打包文件 v：显示运行过程 f：指定文件名 解压 tar -xvf 要解压的文件 tar -xvf 要解压的文件 -C 目录 把压缩包解压到指定的位置 权限 ll 查看列表之后的第一列表示权限 文件的类型： d：代表目录 -：代表文件 l：代表链接（可以认为是window中的快捷方式） 后面的9位分为3组，每3位置一组，分别代表属主的权限，与当前用户同组的用户的权限，其他用户的权限 r：代表权限是可读，r也可以用数字4表示 w：代表权限是可写，w也可以用数字2表示 x：代表权限是可执行，x也可以用数字1表示 修改文件/目录的权限的命令：chmod例如：chmod u=rwx,g=rw,o=r aaa.txt 还可以用数字表示：因为三个权限不同组合的数字肯定是不一样的 其他 pwd 查看当前所在的工作目录 ps -ef 查看当前进程 （第二列是端口号） kill 结束某一个进程 搜索命令： grep 要搜索的关键字 要搜索的文件 --color //加color表示要关键字高亮 管道命令： | 将前一个命令的结果作为下一个命令的输入 ifconfig 查看端口 netstat-an8.reboot重启 halt关机 注意： 按tab键可以自动补全要输入的文件名，前提是文件夹中有你想输入的 linux中没有扩展名，扩展名只是为了阅读方便 Ctrl + c 表示强制退出 ./代表当前文件夹下的所有内容 Linux安全性的一个体现在他的端口不是随意更改的一般为22 当某个命令不会用的时候，用 –help 显示提示信息 前面加 . 表示隐藏文件 远程连接工具的使用关于远程工具乱码的解决： 使用远程工具进行连接时，如果linux有中文文件或目录，显示时会出现乱码，原因是linux编码是UTF-8，而远程工具默认是当前系统本地编码即GBK。所以解决方案是统一两者编码就OK了，但是该SSH Secure工具不能设置编码，所以通过修改linux的系统编码的方式进行统一编码。 - 配置文件中改，进入配置文件夹**etc** - 进入cd sysconfig/ - 其中有一个 `i18n` 进入 vim i18n 再改GBK Linux的软件的安装rpm与软件相关的命令，相当于window下的软件助手 JDK的安装 查看当前Linux系统是否已经安装java输入rpm -qa | grep java 卸载两个openJDK输入rpm -e --nodeps 要卸载的软件 上传jdk到linux 解压jdk到/usr/local下 tar –xvf jdk-7u71-linux-i586.tar.gz –C /usr/local 配置jdk环境变量，打开/etc/profile配置文件，将下面配置拷贝进去 12345set java environmentJAVA_HOME=/usr/local/jdk1.7.0_71CLASSPATH=.:$JAVA_HOME/lib.tools.jarPATH=$JAVA_HOME/bin:$PATHexport JAVA_HOME CLASSPATH PATH 重新加载/etc/profile配置文件 source /etc/profile Mysql的安装1.查看CentOS自带的mysql 输入 rpm -qa | grep mysql 2.将自带的mysql卸载 3.上传Mysql到linux4.解压Mysql到/usr/local/下的mysql目录(mysql目录需要手动创建)内 cd /usr/local mkdir mysql tar -xvf MySQL-5.6.22-1.el6.i686.rpm- bundle.tar -C /usr/local/mysql会解压成几个.rpm文件，相当于window的.exe文件5.在/usr/local/mysql下安装mysql安装服务器端：rpm -ivh MySQL-server-5.6.22-1.el6.i686.rpm安装客户端：rpm -ivh MySQL-client-5.6.22-1.el6.i686.rpm6.启动mysqlservice mysql start7.将mysql加到系统服务中并设置开机启动加入到系统服务：chkconfig --add mysql自动启动：chkconfig mysql on8.登录mysqlmysql安装好后会生成一个临时随机密码，存储位置在/root/.mysql_secretmsyql –u root -p9.修改mysql的密码set password = password(&#39;root&#39;);10.开启mysql的远程登录默认情况下mysql为安全起见，不支持远程登录mysql，所以需要设置开启 远程登录mysql的权限登录mysql后输入如下命令：12grant all privileges on *.* to &apos;root&apos; @&apos;%&apos; identified by &apos;root&apos;;flush privileges; 11.开放Linux的对外访问的端口3306(重点) 12/sbin/iptables -I INPUT -p tcp --dport 3306 -j ACCEPT/etc/rc.d/init.d/iptables save ---将修改永久保存到防火墙中 Tomcat的安装 上传Tomcat到linux上 解压Tomcat到/usr/local下 开放Linux的对外访问的端口8080 12/sbin/iptables -I INPUT -p tcp --dport 8080 -j ACCEPT/etc/rc.d/init.d/iptables save 4.启动关闭Tomcat进入tomcat的bin下启动：./startup.sh进入tomcat的bin下关闭：./shutdown.sh]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[markdown]]></title>
      <url>%2F2015%2F11%2F18%2Fmarkdown%2F</url>
      <content type="text"><![CDATA[代码之外的软技能1&gt;这是引用 Markdown Tutorial(教程)Introduction 是一个轻量级标记语言 最重要的设计是可读性高 Markdown 基本语法12#### 标题标题使用 **#** 号来书写，#号之后跟标题内容 标题在写的时候，要注意，#号之后一定要跟一个空格，标题与标题之间要有一个空行 粗体和斜体1**粗体** *斜体* ####无序列表 1234567Markdown中的无序列表对应的就是html中的ul标签- 在段落中写入英文的时候，要注意两边加上空格，为了保持格式清晰 - 子列表，在列表中回车tab就会生成子列表- 列表使用一个- 开头，接着空格，然后是列表的内容- 列表3 有序列表123456789101112Markdown中的无序列表对应的就是html中的ol标签1. 有序列表1 1. 子列表1 2. 子列表22. 有序列表23. 有序列表3有序列表是根据tab缩进来识别的跟前面的数字没关系有序列表中也可以嵌套无序列表 链接跟图片1234[百度一下](http://www.baidu.com/) ![图片](网络地址，马克飞象不支持本地地址) 代码引用行内引用1234反引号esc下边的那个`在这里，我们可以使用`var`关键字来声明一个变量。 #####多行引用 多行引用就是html中的pre 1 aaaaa sssss aasd asdasd asdasd 123```#### 表格 表格其实就是html中的table书写的时候，分为thead tbody 中间的分割线 编号 姓名 年龄 1 john 18 2 lucy 17 3 mark 19 12###Markdown总结 标题 # 段落 直接写 无序列表跟有序列表 无序列表- 有序列表 1. 粗体跟斜体 **粗体的内容** * 斜体的内容 * 链接跟图片 [链接要显示的内容](链接的地址) ![图片的alt](图片的链接地址) 文本引用 &gt; 引用内容 代码引用 行内引用 `引用内容` 多行引用 \1- 表格 注：html代码在Markdown中也可以解析。]]></content>
    </entry>

    
  
  
</search>
